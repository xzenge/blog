{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/minos/source/images/check.svg","path":"images/check.svg","modified":0,"renderable":1},{"_id":"themes/minos/source/images/exclamation.svg","path":"images/exclamation.svg","modified":0,"renderable":1},{"_id":"themes/minos/source/images/info.svg","path":"images/info.svg","modified":0,"renderable":1},{"_id":"themes/minos/source/images/question.svg","path":"images/question.svg","modified":0,"renderable":1},{"_id":"themes/minos/source/images/quote-left.svg","path":"images/quote-left.svg","modified":0,"renderable":1},{"_id":"themes/minos/source/css/insight.scss","path":"css/insight.scss","modified":0,"renderable":1},{"_id":"themes/minos/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/minos/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/minos/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/minos/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/minos/_config.yml","hash":"ee1969d0383458a95f1bf4b9341c2db8b1a88e13","modified":1568123082051},{"_id":"themes/minos/package-lock.json","hash":"1fdf3ebc293bb2df47fe5c4f833c6797d5e8a546","modified":1568123082064},{"_id":"themes/minos/package.json","hash":"76b6439e405b7b479535d40bad6d982957ac4fa7","modified":1568123082064},{"_id":"source/_posts/JVM-整理.md","hash":"7b44bfe755f72bcc8171139cfa2140da217bb0b4","modified":1583067216683},{"_id":"source/_posts/hexo搭建问题【-no-layout-index-html】.md","hash":"1be1eb02ea07fea82d2bf0de762c44741c0098ed","modified":1568123081980},{"_id":"source/_posts/NIO.md","hash":"8ead196555b8d598e0f5219f6106229e78509f76","modified":1580302581196},{"_id":"source/_posts/一个事故引起的缓存.md","hash":"86431da9023475677bd070abfa185f1288ada40d","modified":1568123081982},{"_id":"source/_posts/分布式一致性算法整理.md","hash":"3fabac6594716259e343ceb1d6202ce8f252b098","modified":1583067600166},{"_id":"source/_posts/Spring-Boot.md","hash":"d5955ad7f7f0448aa515e2a559d4a12c0e3eadae","modified":1580454385984},{"_id":"source/_posts/分布式事务整理.md","hash":"a7a48277ab620618d9c1418cfc5894a156769c70","modified":1583067378438},{"_id":"source/_posts/搜寻流浪狗APP.md","hash":"da3798077751cb9526113d1f572d99eb4c1bb37f","modified":1568123081984},{"_id":"source/_posts/自己动手写Java虚拟机-笔记4.md","hash":"b4aad08cd9bcdf1b3ea0440c98570aab40cbddf6","modified":1569508266218},{"_id":"source/_posts/记一次序列化失败导致的生产问题.md","hash":"6b4a6dc64a788ba67b8770aab540ccc2677d0a27","modified":1569416064699},{"_id":"source/_posts/自己动手写Java虚拟机-笔记1.md","hash":"abb3897bcec40ba8bf9f07386ac3820a284f6054","modified":1568123081984},{"_id":"source/_posts/自己动手写Java虚拟机-笔记2.md","hash":"21c2f49bd18fa61934828232874d5fc15d0622da","modified":1568364415468},{"_id":"source/_posts/自己动手写Java虚拟机-笔记3.md","hash":"dbc3737adfd45fb433822e6dab03a34bcf14e5bc","modified":1568555428396},{"_id":"source/_posts/🐇.md","hash":"adfbcb468c817b983da9a7ad51c6a395d485827d","modified":1568123081985},{"_id":"source/about/index.md","hash":"bbf18ec9fc016f66677fb4ecbd2af36e0b84a524","modified":1568123082019},{"_id":"source/categories/index.md","hash":"ad9ccb8c69e08c4be734e7e43a7e4a6006ca2b48","modified":1568123082020},{"_id":"source/tags/index.md","hash":"cbee60ff133d01e398473d8e266136f13eeda969","modified":1568123082020},{"_id":"themes/minos/languages/es.yml","hash":"2492235c429294caef66d220d2b958d147d2a8e7","modified":1568123082052},{"_id":"themes/minos/languages/fr.yml","hash":"14fe6ca8e0dc50791e1c4d2e190bf75774c1bf0f","modified":1568123082052},{"_id":"themes/minos/languages/en.yml","hash":"b0106e055e348cff3dc04bbfa92eaf078887914a","modified":1568123082052},{"_id":"themes/minos/languages/ko.yml","hash":"5cdf4a031fc3fcbab392dec89053e2417485e4c7","modified":1568123082052},{"_id":"themes/minos/languages/ru.yml","hash":"c7d59fc5906eeb9230ca794515cabd6064e853bc","modified":1568123082053},{"_id":"themes/minos/languages/zh-tw.yml","hash":"235107d79bc8a6e0796d46fb409045c7c5142865","modified":1568123082053},{"_id":"themes/minos/languages/zh-cn.yml","hash":"ba7eabb49391804f1d83acd1a4e03d1a73e02089","modified":1568123082053},{"_id":"themes/minos/lib/i18n.js","hash":"89a99d1d69cf8ca6be326880a8b01809535e8ac8","modified":1568123082063},{"_id":"themes/minos/lib/rfc5646.js","hash":"50de178e1fcd2224c99db56227652eb1dbaabe40","modified":1568123082064},{"_id":"themes/minos/layout/category.ejs","hash":"587fc7dac77115589ed8cb368ed4a8a2a6f129af","modified":1568123082054},{"_id":"themes/minos/layout/archive.ejs","hash":"4239b7b97f02d86e83878ee0c32b0eccb9893420","modified":1568123082054},{"_id":"themes/minos/layout/categories.ejs","hash":"b609b00fd03b521689dfc2d267aead94d49fcc80","modified":1568123082054},{"_id":"themes/minos/layout/index.ejs","hash":"64c432857172b1c775bf82c0a60ca1ecdc7d9d21","modified":1568123082059},{"_id":"themes/minos/layout/layout.ejs","hash":"d1293320d738ac7f097869a4e74f6089a79d1c46","modified":1568123082059},{"_id":"themes/minos/layout/tag.ejs","hash":"b72bf2ebd9c5d9d7546f448a4331f13dc6b49950","modified":1568123082063},{"_id":"themes/minos/layout/post.ejs","hash":"bba00a681d797817baf34737467be2eca3bdcfbb","modified":1568123082061},{"_id":"themes/minos/scripts/01_check.js","hash":"799fee2a7e989e211a1727f3f52cec47ae887b18","modified":1568123082065},{"_id":"themes/minos/layout/tags.ejs","hash":"9b54bfb0c56e54ff89da9a0a390414ef13a14931","modified":1568123082063},{"_id":"themes/minos/scripts/99_config.js","hash":"c4496562e4ecae5e49dbc57490edae0682f77989","modified":1568123082065},{"_id":"themes/minos/scripts/99_content.js","hash":"d73731b1eecbef4874621bf35e4ed70ca3fd8979","modified":1568123082066},{"_id":"themes/minos/scripts/10_i18n.js","hash":"2383fb5519c9966d27081c276203f961fcb6b783","modified":1568123082065},{"_id":"themes/minos/scripts/99_tags.js","hash":"30b235e1deaa1a857aeb62bfd7c672a6e5762723","modified":1568123082066},{"_id":"source/_posts/hexo搭建问题【-no-layout-index-html】/nolayout.jpg","hash":"b7e6217718a630562255060b224ee116d1caf824","modified":1568123081981},{"_id":"source/_posts/一个事故引起的缓存/springCache.png","hash":"244dfd7e60a2e01dbd8ed66d5f0828db5737c32d","modified":1568123081982},{"_id":"source/_posts/自己动手写Java虚拟机-笔记1/gopath.png","hash":"651d1a1fb00e3250828a1e1570d1ee3f842774ca","modified":1568123081984},{"_id":"themes/minos/layout/comment/changyan.ejs","hash":"e0a2716e7a6c7da26182135fce4776596761a699","modified":1568123082055},{"_id":"themes/minos/layout/comment/facebook.ejs","hash":"cd2fe44bc6be457d4cb6dc43c75023e9f83d66f7","modified":1568123082055},{"_id":"themes/minos/layout/comment/isso.ejs","hash":"55bfe636859f118b40750bd36e2c3ef1a2ec4c0e","modified":1568123082056},{"_id":"themes/minos/layout/comment/livere.ejs","hash":"792a1e44b71ed8048903ea898aeaf74a6c109037","modified":1568123082056},{"_id":"themes/minos/layout/comment/gitment.ejs","hash":"033fb890dc1de71f7d3b97061d0d75f4564bd09a","modified":1568123082055},{"_id":"themes/minos/layout/comment/youyan.ejs","hash":"bcb4b7282a7bcfcb514133e752c0f9d606b3c4d5","modified":1568123082057},{"_id":"themes/minos/layout/common/article.ejs","hash":"8b553b16b23e4e2712442426d7a35f7ec80f22a7","modified":1568123082057},{"_id":"themes/minos/layout/comment/disqus.ejs","hash":"2e35b7578478cf25544ae7f4b3535521ad73c5a2","modified":1568123082055},{"_id":"themes/minos/layout/comment/valine.ejs","hash":"4400de3b0d2d16e2c3e79d1f6ea0841395bd5477","modified":1568123082056},{"_id":"themes/minos/layout/common/languages.ejs","hash":"9b503282ca6e665ca41412b277debf4cd15635fd","modified":1568123082058},{"_id":"themes/minos/layout/common/head.ejs","hash":"4b3085f2fe06f684b8e12184dcbbdffb05509d20","modified":1568123082058},{"_id":"themes/minos/layout/common/footer.ejs","hash":"c52c678e3fd336651dd1fd7e7241515adb52a897","modified":1568123082057},{"_id":"themes/minos/layout/common/paginator.ejs","hash":"2ea7e6c7349d4529bfcfd50c51088c7475743686","modified":1568123082058},{"_id":"themes/minos/layout/common/scripts.ejs","hash":"0262a28c2e0f4a9e57fe1da871c517909710eca3","modified":1568123082059},{"_id":"themes/minos/layout/common/navbar.ejs","hash":"075b13ec8d6450bad5f6080505449630ffecb66a","modified":1568123082058},{"_id":"themes/minos/layout/plugins/google-analytics.ejs","hash":"725fd626b6535c6d05b88e736eeefbca6d39e7e8","modified":1568123082060},{"_id":"themes/minos/layout/plugins/mathjax.ejs","hash":"461c9b17ceddfdfd15ce4ed648d903953d2c7e9b","modified":1568123082061},{"_id":"themes/minos/layout/plugins/clipboard.ejs","hash":"3ba8b96450707cef02f243c9ec4688b1adf06c72","modified":1568123082060},{"_id":"themes/minos/layout/plugins/gallery.ejs","hash":"a1b9814c597f0e6b74be2bb5550e50c2915ae482","modified":1568123082060},{"_id":"themes/minos/layout/plugins/katex.ejs","hash":"9fbd9065ead2f35a2f69f9e0b2421b5bc0ae81b5","modified":1568123082060},{"_id":"themes/minos/layout/share/addthis.ejs","hash":"9cc26da261527bbba8b0180e0f73e0c6ae5416b5","modified":1568123082062},{"_id":"themes/minos/layout/share/sharethis.ejs","hash":"307d905cd39ac4908ef5589829a18777f314428d","modified":1568123082062},{"_id":"themes/minos/layout/search/insight.ejs","hash":"2ef94c3ddae02db57c9dc5cf69da72b1c90c9236","modified":1568123082062},{"_id":"themes/minos/layout/search/google-cse.ejs","hash":"ab3aa6c57d7dd045b8838280548aa447ec38ffa6","modified":1568123082061},{"_id":"themes/minos/source/images/check.svg","hash":"16e9a53d7c49621be8e3f1a28b11bcf5e751105e","modified":1568123082067},{"_id":"themes/minos/source/images/exclamation.svg","hash":"213125a083bcef89806b4285190e050eef2660f2","modified":1568123082068},{"_id":"themes/minos/source/images/info.svg","hash":"60613abd8f8522c6cebdbb4bf7bf3fcc482245bd","modified":1568123082068},{"_id":"themes/minos/source/images/question.svg","hash":"e4005d2eabfbd3bdd291236f56a4d385e3b337b2","modified":1568123082068},{"_id":"themes/minos/source/images/quote-left.svg","hash":"d2561fa8d13e63ff196b71232a5968415ec6e372","modified":1568123082069},{"_id":"themes/minos/source/css/insight.scss","hash":"b7340f343e8bfe967b21b502d6cb5b78295fd9e0","modified":1568123082067},{"_id":"themes/minos/source/images/logo.png","hash":"4e012d9ba58cb8f87ee775262ef871c158ac5948","modified":1568123082068},{"_id":"themes/minos/source/css/style.scss","hash":"063f69c121ffab9f809c41bb088c1e177a9bd4c7","modified":1568123082067},{"_id":"themes/minos/source/js/script.js","hash":"b51152561a894d1b0afee2d908364e69b253bfc2","modified":1568123082069},{"_id":"themes/minos/source/js/insight.js","hash":"4be407e66c2c45333a8cf1a064a9302cd6d90422","modified":1568123082069},{"_id":"source/_posts/一个事故引起的缓存/多级缓存.png","hash":"22fa4a74b7c688ad6fbb3a3a56c585d2acf0dfef","modified":1568123081983},{"_id":"source/_posts/自己动手写Java虚拟机-笔记4/运行时数据区.png","hash":"5057a5c3a444bc1720a6bf1951d4d3c373386042","modified":1569507719971},{"_id":"source/_posts/记一次序列化失败导致的生产问题/wenti.png","hash":"e6843d420e7ad46c852f2f041812eb927fb1399d","modified":1569416064701},{"_id":"source/_posts/🐇/牌子.jpeg","hash":"24f95dd5ddc228a74e8ff4887a29431510ec6620","modified":1568123082019},{"_id":"source/_posts/🐇/全景.jpeg","hash":"147aba5c942fd21ed61065267d438905756dc1fb","modified":1568123082002},{"_id":"public/content.json","hash":"18d55bfcdbb4bd00074160b45587e698e6bb3564","modified":1583067606700},{"_id":"public/about/index.html","hash":"ba4da21247eb9fccbe99c8f53f1124d1198bb916","modified":1583067539570},{"_id":"public/tags/index.html","hash":"08c2e156a10ab71d961dec373d46491be87ca0c0","modified":1583067539570},{"_id":"public/categories/index.html","hash":"4a60bdbed2feb8ebf14128f796a9227780debc33","modified":1583067539817},{"_id":"public/2019/09/07/hexo搭建问题【-no-layout-index-html】/index.html","hash":"41863740b69924cb4f890a6de0920d9977d914d8","modified":1583067539819},{"_id":"public/2019/09/06/搜寻流浪狗APP/index.html","hash":"1a934a7fe7e2812c1a8dd70e8f5aa43685011081","modified":1583067539819},{"_id":"public/2019/09/05/🐇/index.html","hash":"ac30b443c8faa83301e3f92abd8b5b665edabf09","modified":1583067539823},{"_id":"public/2019/09/26/自己动手写Java虚拟机-笔记4/index.html","hash":"444944809796b6b0665a1af0a924748f14459005","modified":1583067539823},{"_id":"public/2020/02/22/JVM-整理/index.html","hash":"1ef069468b00c31614e7696e388c4840eeb905b6","modified":1583067539823},{"_id":"public/2019/09/24/记一次序列化失败导致的生产问题/index.html","hash":"69a2a1fa5d5f2c55c083bbbf007dd3b728940678","modified":1583067539823},{"_id":"public/2020/01/29/NIO/index.html","hash":"c0a4852e1fd679c3dbaa2d5f6911cd13f63fee48","modified":1583067539823},{"_id":"public/2020/01/29/Spring-Boot/index.html","hash":"25fd00bee934b4b686d170146c58499ec627107a","modified":1583067539823},{"_id":"public/2019/09/13/自己动手写Java虚拟机-笔记3/index.html","hash":"dd146fde36017c373eaed10e311605c1d8ba1d45","modified":1583067539823},{"_id":"public/2019/09/10/自己动手写Java虚拟机-笔记2/index.html","hash":"f12e13352adbdc85bdc2d6172faaec7faaad6521","modified":1583067539823},{"_id":"public/2019/09/09/自己动手写Java虚拟机-笔记1/index.html","hash":"d33ecc56da6516dbf22c5142e42d8b11a21d65e4","modified":1583067539823},{"_id":"public/2019/09/04/一个事故引起的缓存/index.html","hash":"51d04d2a01160c19f2555c75672b590897d80f2c","modified":1583067539823},{"_id":"public/2020/03/01/分布式事务整理/index.html","hash":"d98086f2b0dcf26993983a7ae6881643b7bff2df","modified":1583067539833},{"_id":"public/archives/page/2/index.html","hash":"f4499ffe4bd2ae033b0c0857f8b3d0496da5d4b7","modified":1583067539833},{"_id":"public/archives/index.html","hash":"f1b8f35f55558d9712444212d7e8cfd3f2b9ed93","modified":1583067539859},{"_id":"public/archives/2019/index.html","hash":"168d4c0eeb947c8f02d7456175b2d6af08f3ba6d","modified":1583067539859},{"_id":"public/archives/2019/09/index.html","hash":"445997507d842104132ae8f8ee2f90b40ff8cce7","modified":1583067539860},{"_id":"public/archives/2020/index.html","hash":"d5fcbe2f1e6fa22f7dd55ab2e48643c7fb442d9f","modified":1583067539860},{"_id":"public/archives/2020/02/index.html","hash":"66402db3e51bb1df70638954aa91b5833e6b0a7b","modified":1583067539860},{"_id":"public/archives/2020/01/index.html","hash":"e9423760f5e39a8e275a9ed96eabdbb3bf926ff5","modified":1583067539860},{"_id":"public/categories/Life/index.html","hash":"d3f234068050d1c2662a7619171098b02adc996e","modified":1583067539860},{"_id":"public/categories/Translation/index.html","hash":"ad618f1c248b0af7e36e7f9f492df034599b235b","modified":1583067539860},{"_id":"public/page/2/index.html","hash":"201a38f310c108edf854fc2998f079b1265b38e6","modified":1583067539860},{"_id":"public/tags/Redis/index.html","hash":"b00bd1d4a3426ef2675e925b14f84ed7dc94a115","modified":1583067539860},{"_id":"public/tags/Hexo/index.html","hash":"451bef58b5a37113e111b9af76710ecb61c24410","modified":1583067539860},{"_id":"public/tags/Cache/index.html","hash":"c6223ef5fa95a3fafdc3816d6b8d9bc3cfceb3b7","modified":1583067539860},{"_id":"public/tags/IO/index.html","hash":"f95090fe1e56185f6769ac4eefcff39cfc7aab5f","modified":1583067539860},{"_id":"public/tags/AI/index.html","hash":"708f8810ba3eddce2e46bf42cb2fb4fb7fc7823e","modified":1583067539860},{"_id":"public/tags/APP/index.html","hash":"572095292741fd3d73e8534c7607f51faed2098f","modified":1583067539860},{"_id":"public/tags/Spring-Boot/index.html","hash":"ea1fd79dcf4ae336325960f906dab330e0b49bf2","modified":1583067539860},{"_id":"public/tags/Go/index.html","hash":"02429281e5c85cb4e3d38a489a81611e54632448","modified":1583067539860},{"_id":"public/tags/Food/index.html","hash":"d78fd1fc8ae4f45a7abef1094919eaf0e72ed5cf","modified":1583067539860},{"_id":"public/tags/Springboot/index.html","hash":"8f868a2fadf364c18e1d1e170c628dae8c91efb2","modified":1583067539860},{"_id":"public/2020/03/01/分布式一致性算法整理/index.html","hash":"2aa9df904ae37fac34782e965bce2466c360af0f","modified":1583067607471},{"_id":"public/categories/Technology/index.html","hash":"b8e227f3f05f53bd8746fb81813bf32ed5ccbc03","modified":1583067607471},{"_id":"public/index.html","hash":"2b34ab43d9e5cd78dc9eeda6cf2cad1557758f9b","modified":1583067607471},{"_id":"public/tags/JVM/index.html","hash":"8e177eb8f2eca327e901cf87a49682e04c93e361","modified":1583067539861},{"_id":"public/tags/Java/index.html","hash":"4e4a2cdf34efd5b6a57813ddace264962ac92d06","modified":1583067607471},{"_id":"public/archives/2020/03/index.html","hash":"7e21d95007e3cce3ca910fd76ca1daf500954af5","modified":1583067539864},{"_id":"public/categories/Technology/page/2/index.html","hash":"ab2bd3deae9be4500c3a60bf2c7cf50b01550e04","modified":1583067539864},{"_id":"public/tags/Java/page/2/index.html","hash":"688ad619476953c51435f905a38fa6d22b4c8f28","modified":1583067539864},{"_id":"public/images/check.svg","hash":"16e9a53d7c49621be8e3f1a28b11bcf5e751105e","modified":1583067539864},{"_id":"public/images/exclamation.svg","hash":"213125a083bcef89806b4285190e050eef2660f2","modified":1583067539865},{"_id":"public/images/info.svg","hash":"60613abd8f8522c6cebdbb4bf7bf3fcc482245bd","modified":1583067539865},{"_id":"public/images/logo.png","hash":"4e012d9ba58cb8f87ee775262ef871c158ac5948","modified":1583067539865},{"_id":"public/images/question.svg","hash":"e4005d2eabfbd3bdd291236f56a4d385e3b337b2","modified":1583067539865},{"_id":"public/images/quote-left.svg","hash":"d2561fa8d13e63ff196b71232a5968415ec6e372","modified":1583067539865},{"_id":"public/2019/09/07/hexo搭建问题【-no-layout-index-html】/nolayout.jpg","hash":"b7e6217718a630562255060b224ee116d1caf824","modified":1583067539865},{"_id":"public/2019/09/09/自己动手写Java虚拟机-笔记1/gopath.png","hash":"651d1a1fb00e3250828a1e1570d1ee3f842774ca","modified":1583067539865},{"_id":"public/2019/09/04/一个事故引起的缓存/springCache.png","hash":"244dfd7e60a2e01dbd8ed66d5f0828db5737c32d","modified":1583067539865},{"_id":"public/2019/09/26/自己动手写Java虚拟机-笔记4/运行时数据区.png","hash":"5057a5c3a444bc1720a6bf1951d4d3c373386042","modified":1583067539874},{"_id":"public/2019/09/04/一个事故引起的缓存/多级缓存.png","hash":"22fa4a74b7c688ad6fbb3a3a56c585d2acf0dfef","modified":1583067539874},{"_id":"public/js/script.js","hash":"6b670ec4f90fb43b21a0bbd750a217af5d8aab6b","modified":1583067539884},{"_id":"public/2019/09/24/记一次序列化失败导致的生产问题/wenti.png","hash":"e6843d420e7ad46c852f2f041812eb927fb1399d","modified":1583067539885},{"_id":"public/js/insight.js","hash":"eb23c31141784eef7300f1d1c548950e77883f56","modified":1583067539893},{"_id":"public/css/insight.css","hash":"f376dcda6bb50b708f3206c15a49f7530b3c534d","modified":1583067539899},{"_id":"public/css/style.css","hash":"4e7a159e292129b1abbdcabc69aad37c4eb5fc8e","modified":1583067539906},{"_id":"public/2019/09/05/🐇/牌子.jpeg","hash":"24f95dd5ddc228a74e8ff4887a29431510ec6620","modified":1583067539926},{"_id":"public/2019/09/05/🐇/全景.jpeg","hash":"147aba5c942fd21ed61065267d438905756dc1fb","modified":1583067539929}],"Category":[{"name":"Technology","_id":"ck791jehz0004isnynhmvwyta"},{"name":"Translation","_id":"ck791jeid000nisnyxpdshmtw"},{"name":"Life","_id":"ck791jeii000xisnyvqum1so6"}],"Data":[],"Page":[{"title":"about","date":"2019-09-04T03:48:57.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-09-04 11:48:57\n---\n","updated":"2019-09-10T13:44:42.019Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck791jehw0001isnyu8xi7hqu","content":"","site":{"data":{}},"_categories":[],"_tags":[],"excerpt":"","more":""},{"title":"tags","date":"2019-09-04T03:48:44.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-09-04 11:48:44\n---\n","updated":"2019-09-10T13:44:42.020Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck791jehy0003isnyx37b72eq","content":"","site":{"data":{}},"_categories":[],"_tags":[],"excerpt":"","more":""},{"title":"categories","date":"2019-09-04T03:49:09.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-09-04 11:49:09\n---\n","updated":"2019-09-10T13:44:42.020Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck791jei10007isnyb46cg5sy","content":"","site":{"data":{}},"_categories":[],"_tags":[],"excerpt":"","more":""}],"Post":[{"title":"JVM 整理","date":"2020-02-22T07:03:19.000Z","_content":"\n# JVM 相关知识整理\n1. 内存分配\n2. 垃圾回收器的参数配置\n\n## 类的加载\n<!-- more -->\n加载->验证->准备->解析->初始化->使用->卸载\n\n### 加载流程\n\n- 加载\n\n  代码中使用到这个类的时候，.class字节码文件就会加载这个类到JVM内存中。\n\n- 链接\n\n\t- 验证\n\n\t  根据JVM规范，校验.class文件。\n\n\t- 准备\n\n\t  给加载的类分配内存空间，同时给类的static变量分配内存空间，并设置默认值0。\n\t  clint()\n\n\t- 解析\n\n\t  把符号引用替换为直接引用。\n\n- 初始化\n\n  为类变量赋值：静态方法，静态变量，静态块。\n  初始化一个类的时候，如果发现有父类还没初始化，会先初始化他的父类。\n\n### 类加载器\n\n- 加载器\n\n\t- BootStrap ClassLoader\n\n\t  加载lib目录下的类库\n\n\t- Extension ClassLoader\n\n\t  加载lib\\ext目录下的类库\n\n\t- Application ClassLoader\n\n\t  加载ClassPath下的类\n\n\t- 自定义加载器\n\n- 双亲委派机制\n\n  先找父亲加载，加载不了再找儿子加载\n\n## 内存结构\n\n### 方法区、元空间、永久代\n\n存放类的定义，常量池等。\nmatespace满后会触发Full GC。\n方法区垃圾回收：\n1.该类的所有实例已经被回收\n2.加载该类的ClassLoader已经被回收\n3.该类的Class对象没有被任何引用\n\n### 程序技术器\n\n记录当前执行的字节码指令的位置。\n线程私有。\n\n### Java虚拟机栈\n\n保存方法信息。\n线程私有。\n\n- 栈帧\n\n\t- 局部变量表\n\t- 操作数栈\n\t- 动态链接\n\t- 方法返回地址\n\t- 其他\n\n### Java堆内存\n\n存放类的实例对象。\n\n- 分代\n\n\t- 年轻代\n\n\t  新生代进入老年代：默认15次\n\n\t\t- Eden区\n\n\t\t  默认新生代80%空间。\n\t\t  新建对象产生在Eden区。\n\t\t  Eden区满后会发生Minor GC。\n\n\t\t- Survivor0,1区\n\n\t\t  默认年轻代20%。Survivor 0:10%  Survivor 1:10%。\n\t\t  默认对象幸存15次后，会进入老年区。\n\n\t\t\t- 动态年龄判断\n\n\t\t\t  当一批对象的大小大于Survivor区大小的50%，这批对象将不询问年龄，直接进入老年代。\n\n\t- 老年代\n\n\t\t- 进入老年代的规则\n\n\t\t\t- 年龄超过MaxTenuring\n\t\t\t- 动态年龄判断\n\t\t\t- 超过PretenureSize的大对象\n\t\t\t- Eden区幸存对象超过Survivor区大小\n\n- JVM参数\n\n\t- -Xms\n\n\t  Java堆内存的大小\n\n\t- -Xmx\n\n\t  Java堆内存的最大大小\n\n\t- -Xmn\n\n\t  Java对内存中的新生代大小。\n\t  老年代=总大小-新生代\n\n\t- -XX:PermSize\n\n\t  永久代大小\n\n\t- -XX:MaxPermSize\n\n\t  永久代最大大小\n\n\t- -XX:MetaspaceSize\n\n\t  元空间大小\n\n\t- -XX:MaxMetaspaceSize\n\n\t  元空间最大大小\n\n\t- -Xss\n\n\t  Java栈内存大小\n\n\t- -XX:MaxTenuringThreshold\n\n\t  对象在年轻代中幸存的最大轮数。\n\t  默认15，且不能超过15.\n\n\t- -XX:PretenureSizeThreshold\n\n\t  当对象大小超过该值时，对象直接进入老年代，不会进过年轻代。\n\t  避免大对象在Survivor中多次复制，减少无谓的操作。\n\n\t- -XX:-HandlePromotionFailure\n\n\t  判断老年代内存大小是否大于之前每一次Minor GC后进入老年代的对象的平均大小。\n\t  判断失败进行Full GC，再执行Minor GC。\n\n\t- -XX:SurvivorRatio\n\n\t  调整Eden区和Survivor区内存比率\n\t  - XX:SurvivorRatio=8  ： Eden 80%\n\n\t- -XX:+PrintGCDetils\n\n\t  打印详细的GC日志。\n\n\t- -XX:+PrintGCTimeStamps\n\n\t  打印GC发生的时间。\n\n\t- -Xloggc:gc.log\n\n\t  将CG日志输入到文件。\n\n\t- -XX:TraceClassLoading\n\n\t  追踪加载的类\n\n\t- -XX:TraceClassUnloading\n\n\t  追踪卸载的类\n\n\t- -XX:+HeapDumpOnOutOfMemoryError  \n\n\t  OOM时自动dump快照\n\n\t- -XX:HeapDumpPath=/usr/local/app/oom\n\n\t  将快照存放至指定目录\n\n\t- CMS\n\n\t\t- -XX:CMSInitiatingOccupancyFaction\n\n\t\t  设置老年代占用多少比例时触发CMS\n\n\t\t- -XX:+UseCMSCompactAtFullCollection\n\n\t\t  Full GC后STW，整理内存碎片。\n\n\t\t- -XX:CMSFullGCsBeforeCompaction\n\n\t\t  默认0，设置多少次Full GC后进行内存碎片整理。\n\n\t\t- -XX:+CMSParallelInitialMarkEnabled\n\n\t\t  初始标记阶段开启并发执行\n\n\t- G1\n\n\t\t- -XX:+UseG1GC\n\n\t\t  指定G1垃圾回收器。\n\n\t\t- -XX:G1HeapRegionSize\n\n\t\t  手动指定G1的Region的大小。\n\n\t\t- -XX:G1NewSizePercent\n\n\t\t  调整新生代在堆中的占比。\n\t\t  默认5%。\n\n\t\t- -XX:G1MaxNewSizePercent\n\n\t\t  新生代占比堆空间的最大大小。\n\n\t\t- -XX:MaxGCPauseMills\n\n\t\t  默认200ms。\n\t\t  设置G1垃圾回收器GC时的最大停顿时间。\n\n\t\t- -XX:InitiatingHeapOccupancyPercent\n\n\t\t  默认45%。\n\t\t  老年代占据的堆内存超多该值，将会进行新老生代的混合回收。\n\n\t\t- -XX:G1MixedGCCountTarget\n\n\t\t  一次G1混合回收过程中，最后阶段混合回收阶段分几次完成。\n\t\t  默认8。\n\n\t\t- -XX:G1HeapWastePercent\n\n\t\t  默认值5%。\n\t\t  混合回收阶段中，空间Region占比堆空间超多该值，会停止混合回收。\n\n\t\t- -XX:G1MixedGCLiveThresholdPercent\n\n\t\t  默认值85%。\n\t\t  一个Region中的存活对象低于该值时才会被回收。\n\n\t\t- -XX:+CMSScavengeBeforeRemark\n\n\t\t  重新标记前，尽量执行一次Young GC。\n\t\t  提前回收年轻代没有引用的对象，减少重新标记扫描的对象数，提高效率。\n\n- 垃圾回收\n\n\t- 可达性分析\n\n\t  对一个对象层层向上分析，判断是否有一个GC Root。\n\n\t\t- GC Root\n\n\t\t\t- 本地变量表中的局部变量\n\t\t\t- 方法区内的静态变量\n\n\t- java 引用类型\n\n\t\t- 强引用\n\n\t\t  GC不会回收强引用\n\n\t\t- 软引用\n\n\t\t  内存空间足够时，GC不会回收软引用\n\n\t\t- 弱引用\n\n\t\t  GC时必定回收弱引用\n\n\t\t- 虚引用\n\n\t\t  继承Object的finalize()方法，在该对象被回收的时候通知自己。\n\n\t- 垃圾回收算法\n\n\t\t- 年轻代\n\n\t\t\t- 复制\n\n\t\t\t  在新生代幸存者0,1区使用。将标记为可用的内存复制到另外一片连续的内存区域中，并删除当前内存区域中的全部数据。\n\n\t\t\t\t- 优点\n\n\t\t\t\t  不会产生内存碎片\n\n\t\t\t\t- 缺点\n\n\t\t\t\t  增加内存的消耗\n\n\t\t- 老年代\n\n\t\t\t- 标记整理\n\n\t\t\t  标记存活对象，删除死亡对象，整理内存碎片。\n\n\t\t\t\t- 优点\n\n\t\t\t\t  不会产生内存碎片。内存利用率高。\n\n\t\t\t\t- 缺点\n\n\t\t\t\t  比起标记清楚，执行效率慢。\n\n\t- JVM垃圾回收器\n\n\t\t- 年轻代\n\n\t\t\t- ParNew\n\n\t\t\t  多线程，复制算法。\n\t\t\t  开启：-XX:+UseParNewGC\n\t\t\t  调整回收线程数：-XX:ParallelGCThreads\n\n\t\t- 老年代\n\n\t\t\t- CMS\n\n\t\t\t  标记清理算法\n\n\t\t\t\t- 回收过程\n\n\t\t\t\t\t- 初始标记\n\n\t\t\t\t\t  STW。\n\t\t\t\t\t  标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。\n\n\t\t\t\t\t- 并发标记\n\n\t\t\t\t\t  寻找被GC Roots间接引用的对象。\n\n\t\t\t\t\t- 重新标记\n\n\t\t\t\t\t  STW。\n\t\t\t\t\t  重新标记并发标记时产生的新对象。\n\n\t\t\t\t\t- 并发清除\n\n\t\t\t\t\t  清理标记的对象。\n\n\t\t\t\t- 缺点\n\n\t\t\t\t  默认启动垃圾回收线程：（CPU核数 +3）/4。\n\t\t\t\t  本身会消耗CPU资源。\n\t\t\t\t  针对浮动垃圾，初始标记后产生的垃圾没法回收。\n\t\t\t\t  CMS回收期间，新生代进入老年代对象大于可用空间时，会发生Concurrent Mode Failure ，并自动使用Serial Old回收器替代CMS工作。\n\n\t\t- G1\n\n\t\t  基于复制算法。\n\t\t  把Java堆内存划分为多个大小相等的Region。\n\t\t  可以设置STW的时间，追踪每个Region里可回收对象的预估时间。\n\t\t  G1中的分代是逻辑上的分代，同一个Region会随着分配的内存对象不同，而属于不同分代。\n\t\t  每个Region的大小：堆大小/2048。\n\t\t  新生代的Region同时分Eden和Survivor，可通过-XX:SurvivorRatio调整占比。\n\t\t  适合大内存的机器，G1可以设置停顿时间，来确保对服务不会有较大的影响。\n\n\t\t\t- 大对象\n\n\t\t\t  超多Region大小50%即为大对象。\n\t\t\t  大对象可能横跨多个Region。\n\t\t\t  空的Region都可以存放大对象。\n\t\t\t  新老生代GC时都会回收大对象。\n\n\t\t\t- 回收过程\n\n\t\t\t\t- 初始标记\n\n\t\t\t\t  STW。\n\t\t\t\t  标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。\n\n\t\t\t\t- 并发标记\n\n\t\t\t\t  进行GC Roots的追踪，追踪所有存活对象。\n\t\t\t\t  同时JVM会记录该阶段中新建或失去引用的对象。\n\n\t\t\t\t- 最终标记\n\n\t\t\t\t  STW。\n\t\t\t\t  通过多并发标记中JVM堆新增或失去引用的对象，进行重新标记。\n\n\t\t\t\t- 混合回收\n\n\t\t\t\t  分析Region大小，执行效率。\n\t\t\t\t  STW。\n\t\t\t\t  在指定时间内进行回收。\n\n\t\t\t- 问题\n\n\t\t\t  回收中发现Region空间不够时，将会SWT，并单线程进行标记、清除、整理，效率很低。\n\n\t- CG触发时间\n\n\t\t- Minor GC\n\n\t\t  Eden区满时采用复制算法。\n\n\t\t- Old GC\n\n\t\t  1.老年代连续可用空间 < 新生代历次GC后升入老年代对象内存和的平均大小。\n\t\t  2.老年代不够存放，Minor GC后升入老年代的对象时。\n\t\t  3.老年代内存使用率超过92%时（可设置）。\n\n\t\t- 永久代GC\n\n\t\t  永久代不够使产生Full GC。\n\n### 本地方法栈\n\n存放native方法。\n\n### 堆外内存空间\n\n通过调用操作系统接口，直接分配对外内存空间。\nNIO->allocateDirect(DirectByteBuffer)\n\n## 工具\n\n### jstat\n\n通过jps查找java进程，再用jstat -gc PID查看GC状况。\n\n- 指标\n\n\t- S0C\n\n\t  From Survivor区大小\n\n\t- S1C\n\n\t  To Survivor区大小\n\n\t- S0U\n\n\t  From Survivor区当前使用大小\n\n\t- S1U\n\n\t  To Survivor区当前使用大小\n\n\t- EC\n\n\t  Eden区大小\n\n\t- EU\n\n\t  Eden区当前使用的大小\n\n\t- OC\n\n\t  老年代的大小\n\n\t- OU\n\n\t  老年代当前使用的大小\n\n\t- MC\n\n\t  方法区（永久代、元空间）的大小\n\n\t- MU\n\n\t  方法区（永久代、元空间）当前使用的大小\n\n\t- YGC\n\n\t  系统迄今为止Young GC的次数\n\n\t- YGCT\n\n\t  Young GC耗时\n\n\t- FGC\n\n\t  系统迄今为止Full GC的次数\n\n\t- FGCT\n\n\t  Full GC的耗时\n\n\t- GCT\n\n\t  所有GC的总耗时\n\n- 命令\n\n\t- jstat -gc PID\n\n\t  查看GC状况\n\n\t- jstat -gccapacity PID\n\n\t  堆内存分析\n\n\t- jstat -gcnew PID\n\n\t  新生代分析\n\n\t- jstat -gcnewcapacity PID\n\n\t  年轻代内存分析\n\n\t- jstat -gcold PID\n\n\t  老年代GC分析\n\n\t- jstat -gcoldcapacity PID\n\n\t  老年代内存分析\n\n\t- jstat -gcmetacapacity PID\n\n\t  元数据内存分析\n\n### jmap\n\n了解运行时的内存区域\n\n- 命令\n\n\t- jmap -heap PID\n\n\t  打印堆内存相关参数设置。\n\t  当前堆内各个区的基本情况。\n\n\t- jmap -histo PID\n\n\t  按照对象在内存中占用大小排序，降序。\n\t  可以了解哪个对象在堆中占用了大量的空间。\n\n\t- jmap -dump:live,format=b,file=dump.hprof PID\n\n\t  生成内存快照并输出到文件。\n\n### jhat\n\n分析堆内存快照，可以使用工具内置的浏览器查看。\n\n- 命令\n\n\t- jhat dump.hprof -port 7000\n\n\t  分析快照文件dump.hprof ，访问端口7000。\n\n### MAT\n\n内存分析工具\n\n## JVM优化总结\n\n### 调整新生代的大小\n\n尽量让每次Young GC后的存活对象⼩于Survivor区域的50%，都留存在年轻代⾥。尽量别让对象进 ⼊⽼年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响\n\n### 调整老年代碎片回收的频率\n\nCMS一次Full GC会产生内存随便，调整碎片整理的触发轮数，可以有效的降低Full  GC产生的碎片从而降低Full GC的频次。\n\n### JVM参数模板\n\n-Xms4096M -Xmx4096M -Xmn3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark - XX:+DisableExplicitGC -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError - XX:HeapDumpPath=/usr/local/app/oom\n\n### -XX:SoftRefLRUPolicyMSPerMB\n\n在有大量反射的情况下建议增大该值，保证软引用不会被马上回收\n\n### -XX:+DisableExplicitGC\n\n禁止显示执行GC\n性质System.gc()\n\n### 使用缓存淘汰机制\n\n避免本地缓存无限增大，使得老年代常驻对象无法回收，从而导致的内存溢出和频繁的Full GC。\n\n### 频繁Full GC的可能原因\n\n1.系统压力大，频繁Young GC后存活对象大于Survivor区，导致直接进入老年代。\n2.频繁产生大对象。\n3.对象始终不释放，导致内存泄漏。\n4.方法区频繁有类反射加载。\n5.错误使用System.gc()。\n\n*XMind: ZEN - Trial Version*","source":"_posts/JVM-整理.md","raw":"---\ntitle: JVM 整理\ndate: 2020-02-22 15:03:19\ntags: \n    - JVM\n    - Java\ncategories :\n    - Technology\n---\n\n# JVM 相关知识整理\n1. 内存分配\n2. 垃圾回收器的参数配置\n\n## 类的加载\n<!-- more -->\n加载->验证->准备->解析->初始化->使用->卸载\n\n### 加载流程\n\n- 加载\n\n  代码中使用到这个类的时候，.class字节码文件就会加载这个类到JVM内存中。\n\n- 链接\n\n\t- 验证\n\n\t  根据JVM规范，校验.class文件。\n\n\t- 准备\n\n\t  给加载的类分配内存空间，同时给类的static变量分配内存空间，并设置默认值0。\n\t  clint()\n\n\t- 解析\n\n\t  把符号引用替换为直接引用。\n\n- 初始化\n\n  为类变量赋值：静态方法，静态变量，静态块。\n  初始化一个类的时候，如果发现有父类还没初始化，会先初始化他的父类。\n\n### 类加载器\n\n- 加载器\n\n\t- BootStrap ClassLoader\n\n\t  加载lib目录下的类库\n\n\t- Extension ClassLoader\n\n\t  加载lib\\ext目录下的类库\n\n\t- Application ClassLoader\n\n\t  加载ClassPath下的类\n\n\t- 自定义加载器\n\n- 双亲委派机制\n\n  先找父亲加载，加载不了再找儿子加载\n\n## 内存结构\n\n### 方法区、元空间、永久代\n\n存放类的定义，常量池等。\nmatespace满后会触发Full GC。\n方法区垃圾回收：\n1.该类的所有实例已经被回收\n2.加载该类的ClassLoader已经被回收\n3.该类的Class对象没有被任何引用\n\n### 程序技术器\n\n记录当前执行的字节码指令的位置。\n线程私有。\n\n### Java虚拟机栈\n\n保存方法信息。\n线程私有。\n\n- 栈帧\n\n\t- 局部变量表\n\t- 操作数栈\n\t- 动态链接\n\t- 方法返回地址\n\t- 其他\n\n### Java堆内存\n\n存放类的实例对象。\n\n- 分代\n\n\t- 年轻代\n\n\t  新生代进入老年代：默认15次\n\n\t\t- Eden区\n\n\t\t  默认新生代80%空间。\n\t\t  新建对象产生在Eden区。\n\t\t  Eden区满后会发生Minor GC。\n\n\t\t- Survivor0,1区\n\n\t\t  默认年轻代20%。Survivor 0:10%  Survivor 1:10%。\n\t\t  默认对象幸存15次后，会进入老年区。\n\n\t\t\t- 动态年龄判断\n\n\t\t\t  当一批对象的大小大于Survivor区大小的50%，这批对象将不询问年龄，直接进入老年代。\n\n\t- 老年代\n\n\t\t- 进入老年代的规则\n\n\t\t\t- 年龄超过MaxTenuring\n\t\t\t- 动态年龄判断\n\t\t\t- 超过PretenureSize的大对象\n\t\t\t- Eden区幸存对象超过Survivor区大小\n\n- JVM参数\n\n\t- -Xms\n\n\t  Java堆内存的大小\n\n\t- -Xmx\n\n\t  Java堆内存的最大大小\n\n\t- -Xmn\n\n\t  Java对内存中的新生代大小。\n\t  老年代=总大小-新生代\n\n\t- -XX:PermSize\n\n\t  永久代大小\n\n\t- -XX:MaxPermSize\n\n\t  永久代最大大小\n\n\t- -XX:MetaspaceSize\n\n\t  元空间大小\n\n\t- -XX:MaxMetaspaceSize\n\n\t  元空间最大大小\n\n\t- -Xss\n\n\t  Java栈内存大小\n\n\t- -XX:MaxTenuringThreshold\n\n\t  对象在年轻代中幸存的最大轮数。\n\t  默认15，且不能超过15.\n\n\t- -XX:PretenureSizeThreshold\n\n\t  当对象大小超过该值时，对象直接进入老年代，不会进过年轻代。\n\t  避免大对象在Survivor中多次复制，减少无谓的操作。\n\n\t- -XX:-HandlePromotionFailure\n\n\t  判断老年代内存大小是否大于之前每一次Minor GC后进入老年代的对象的平均大小。\n\t  判断失败进行Full GC，再执行Minor GC。\n\n\t- -XX:SurvivorRatio\n\n\t  调整Eden区和Survivor区内存比率\n\t  - XX:SurvivorRatio=8  ： Eden 80%\n\n\t- -XX:+PrintGCDetils\n\n\t  打印详细的GC日志。\n\n\t- -XX:+PrintGCTimeStamps\n\n\t  打印GC发生的时间。\n\n\t- -Xloggc:gc.log\n\n\t  将CG日志输入到文件。\n\n\t- -XX:TraceClassLoading\n\n\t  追踪加载的类\n\n\t- -XX:TraceClassUnloading\n\n\t  追踪卸载的类\n\n\t- -XX:+HeapDumpOnOutOfMemoryError  \n\n\t  OOM时自动dump快照\n\n\t- -XX:HeapDumpPath=/usr/local/app/oom\n\n\t  将快照存放至指定目录\n\n\t- CMS\n\n\t\t- -XX:CMSInitiatingOccupancyFaction\n\n\t\t  设置老年代占用多少比例时触发CMS\n\n\t\t- -XX:+UseCMSCompactAtFullCollection\n\n\t\t  Full GC后STW，整理内存碎片。\n\n\t\t- -XX:CMSFullGCsBeforeCompaction\n\n\t\t  默认0，设置多少次Full GC后进行内存碎片整理。\n\n\t\t- -XX:+CMSParallelInitialMarkEnabled\n\n\t\t  初始标记阶段开启并发执行\n\n\t- G1\n\n\t\t- -XX:+UseG1GC\n\n\t\t  指定G1垃圾回收器。\n\n\t\t- -XX:G1HeapRegionSize\n\n\t\t  手动指定G1的Region的大小。\n\n\t\t- -XX:G1NewSizePercent\n\n\t\t  调整新生代在堆中的占比。\n\t\t  默认5%。\n\n\t\t- -XX:G1MaxNewSizePercent\n\n\t\t  新生代占比堆空间的最大大小。\n\n\t\t- -XX:MaxGCPauseMills\n\n\t\t  默认200ms。\n\t\t  设置G1垃圾回收器GC时的最大停顿时间。\n\n\t\t- -XX:InitiatingHeapOccupancyPercent\n\n\t\t  默认45%。\n\t\t  老年代占据的堆内存超多该值，将会进行新老生代的混合回收。\n\n\t\t- -XX:G1MixedGCCountTarget\n\n\t\t  一次G1混合回收过程中，最后阶段混合回收阶段分几次完成。\n\t\t  默认8。\n\n\t\t- -XX:G1HeapWastePercent\n\n\t\t  默认值5%。\n\t\t  混合回收阶段中，空间Region占比堆空间超多该值，会停止混合回收。\n\n\t\t- -XX:G1MixedGCLiveThresholdPercent\n\n\t\t  默认值85%。\n\t\t  一个Region中的存活对象低于该值时才会被回收。\n\n\t\t- -XX:+CMSScavengeBeforeRemark\n\n\t\t  重新标记前，尽量执行一次Young GC。\n\t\t  提前回收年轻代没有引用的对象，减少重新标记扫描的对象数，提高效率。\n\n- 垃圾回收\n\n\t- 可达性分析\n\n\t  对一个对象层层向上分析，判断是否有一个GC Root。\n\n\t\t- GC Root\n\n\t\t\t- 本地变量表中的局部变量\n\t\t\t- 方法区内的静态变量\n\n\t- java 引用类型\n\n\t\t- 强引用\n\n\t\t  GC不会回收强引用\n\n\t\t- 软引用\n\n\t\t  内存空间足够时，GC不会回收软引用\n\n\t\t- 弱引用\n\n\t\t  GC时必定回收弱引用\n\n\t\t- 虚引用\n\n\t\t  继承Object的finalize()方法，在该对象被回收的时候通知自己。\n\n\t- 垃圾回收算法\n\n\t\t- 年轻代\n\n\t\t\t- 复制\n\n\t\t\t  在新生代幸存者0,1区使用。将标记为可用的内存复制到另外一片连续的内存区域中，并删除当前内存区域中的全部数据。\n\n\t\t\t\t- 优点\n\n\t\t\t\t  不会产生内存碎片\n\n\t\t\t\t- 缺点\n\n\t\t\t\t  增加内存的消耗\n\n\t\t- 老年代\n\n\t\t\t- 标记整理\n\n\t\t\t  标记存活对象，删除死亡对象，整理内存碎片。\n\n\t\t\t\t- 优点\n\n\t\t\t\t  不会产生内存碎片。内存利用率高。\n\n\t\t\t\t- 缺点\n\n\t\t\t\t  比起标记清楚，执行效率慢。\n\n\t- JVM垃圾回收器\n\n\t\t- 年轻代\n\n\t\t\t- ParNew\n\n\t\t\t  多线程，复制算法。\n\t\t\t  开启：-XX:+UseParNewGC\n\t\t\t  调整回收线程数：-XX:ParallelGCThreads\n\n\t\t- 老年代\n\n\t\t\t- CMS\n\n\t\t\t  标记清理算法\n\n\t\t\t\t- 回收过程\n\n\t\t\t\t\t- 初始标记\n\n\t\t\t\t\t  STW。\n\t\t\t\t\t  标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。\n\n\t\t\t\t\t- 并发标记\n\n\t\t\t\t\t  寻找被GC Roots间接引用的对象。\n\n\t\t\t\t\t- 重新标记\n\n\t\t\t\t\t  STW。\n\t\t\t\t\t  重新标记并发标记时产生的新对象。\n\n\t\t\t\t\t- 并发清除\n\n\t\t\t\t\t  清理标记的对象。\n\n\t\t\t\t- 缺点\n\n\t\t\t\t  默认启动垃圾回收线程：（CPU核数 +3）/4。\n\t\t\t\t  本身会消耗CPU资源。\n\t\t\t\t  针对浮动垃圾，初始标记后产生的垃圾没法回收。\n\t\t\t\t  CMS回收期间，新生代进入老年代对象大于可用空间时，会发生Concurrent Mode Failure ，并自动使用Serial Old回收器替代CMS工作。\n\n\t\t- G1\n\n\t\t  基于复制算法。\n\t\t  把Java堆内存划分为多个大小相等的Region。\n\t\t  可以设置STW的时间，追踪每个Region里可回收对象的预估时间。\n\t\t  G1中的分代是逻辑上的分代，同一个Region会随着分配的内存对象不同，而属于不同分代。\n\t\t  每个Region的大小：堆大小/2048。\n\t\t  新生代的Region同时分Eden和Survivor，可通过-XX:SurvivorRatio调整占比。\n\t\t  适合大内存的机器，G1可以设置停顿时间，来确保对服务不会有较大的影响。\n\n\t\t\t- 大对象\n\n\t\t\t  超多Region大小50%即为大对象。\n\t\t\t  大对象可能横跨多个Region。\n\t\t\t  空的Region都可以存放大对象。\n\t\t\t  新老生代GC时都会回收大对象。\n\n\t\t\t- 回收过程\n\n\t\t\t\t- 初始标记\n\n\t\t\t\t  STW。\n\t\t\t\t  标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。\n\n\t\t\t\t- 并发标记\n\n\t\t\t\t  进行GC Roots的追踪，追踪所有存活对象。\n\t\t\t\t  同时JVM会记录该阶段中新建或失去引用的对象。\n\n\t\t\t\t- 最终标记\n\n\t\t\t\t  STW。\n\t\t\t\t  通过多并发标记中JVM堆新增或失去引用的对象，进行重新标记。\n\n\t\t\t\t- 混合回收\n\n\t\t\t\t  分析Region大小，执行效率。\n\t\t\t\t  STW。\n\t\t\t\t  在指定时间内进行回收。\n\n\t\t\t- 问题\n\n\t\t\t  回收中发现Region空间不够时，将会SWT，并单线程进行标记、清除、整理，效率很低。\n\n\t- CG触发时间\n\n\t\t- Minor GC\n\n\t\t  Eden区满时采用复制算法。\n\n\t\t- Old GC\n\n\t\t  1.老年代连续可用空间 < 新生代历次GC后升入老年代对象内存和的平均大小。\n\t\t  2.老年代不够存放，Minor GC后升入老年代的对象时。\n\t\t  3.老年代内存使用率超过92%时（可设置）。\n\n\t\t- 永久代GC\n\n\t\t  永久代不够使产生Full GC。\n\n### 本地方法栈\n\n存放native方法。\n\n### 堆外内存空间\n\n通过调用操作系统接口，直接分配对外内存空间。\nNIO->allocateDirect(DirectByteBuffer)\n\n## 工具\n\n### jstat\n\n通过jps查找java进程，再用jstat -gc PID查看GC状况。\n\n- 指标\n\n\t- S0C\n\n\t  From Survivor区大小\n\n\t- S1C\n\n\t  To Survivor区大小\n\n\t- S0U\n\n\t  From Survivor区当前使用大小\n\n\t- S1U\n\n\t  To Survivor区当前使用大小\n\n\t- EC\n\n\t  Eden区大小\n\n\t- EU\n\n\t  Eden区当前使用的大小\n\n\t- OC\n\n\t  老年代的大小\n\n\t- OU\n\n\t  老年代当前使用的大小\n\n\t- MC\n\n\t  方法区（永久代、元空间）的大小\n\n\t- MU\n\n\t  方法区（永久代、元空间）当前使用的大小\n\n\t- YGC\n\n\t  系统迄今为止Young GC的次数\n\n\t- YGCT\n\n\t  Young GC耗时\n\n\t- FGC\n\n\t  系统迄今为止Full GC的次数\n\n\t- FGCT\n\n\t  Full GC的耗时\n\n\t- GCT\n\n\t  所有GC的总耗时\n\n- 命令\n\n\t- jstat -gc PID\n\n\t  查看GC状况\n\n\t- jstat -gccapacity PID\n\n\t  堆内存分析\n\n\t- jstat -gcnew PID\n\n\t  新生代分析\n\n\t- jstat -gcnewcapacity PID\n\n\t  年轻代内存分析\n\n\t- jstat -gcold PID\n\n\t  老年代GC分析\n\n\t- jstat -gcoldcapacity PID\n\n\t  老年代内存分析\n\n\t- jstat -gcmetacapacity PID\n\n\t  元数据内存分析\n\n### jmap\n\n了解运行时的内存区域\n\n- 命令\n\n\t- jmap -heap PID\n\n\t  打印堆内存相关参数设置。\n\t  当前堆内各个区的基本情况。\n\n\t- jmap -histo PID\n\n\t  按照对象在内存中占用大小排序，降序。\n\t  可以了解哪个对象在堆中占用了大量的空间。\n\n\t- jmap -dump:live,format=b,file=dump.hprof PID\n\n\t  生成内存快照并输出到文件。\n\n### jhat\n\n分析堆内存快照，可以使用工具内置的浏览器查看。\n\n- 命令\n\n\t- jhat dump.hprof -port 7000\n\n\t  分析快照文件dump.hprof ，访问端口7000。\n\n### MAT\n\n内存分析工具\n\n## JVM优化总结\n\n### 调整新生代的大小\n\n尽量让每次Young GC后的存活对象⼩于Survivor区域的50%，都留存在年轻代⾥。尽量别让对象进 ⼊⽼年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响\n\n### 调整老年代碎片回收的频率\n\nCMS一次Full GC会产生内存随便，调整碎片整理的触发轮数，可以有效的降低Full  GC产生的碎片从而降低Full GC的频次。\n\n### JVM参数模板\n\n-Xms4096M -Xmx4096M -Xmn3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark - XX:+DisableExplicitGC -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError - XX:HeapDumpPath=/usr/local/app/oom\n\n### -XX:SoftRefLRUPolicyMSPerMB\n\n在有大量反射的情况下建议增大该值，保证软引用不会被马上回收\n\n### -XX:+DisableExplicitGC\n\n禁止显示执行GC\n性质System.gc()\n\n### 使用缓存淘汰机制\n\n避免本地缓存无限增大，使得老年代常驻对象无法回收，从而导致的内存溢出和频繁的Full GC。\n\n### 频繁Full GC的可能原因\n\n1.系统压力大，频繁Young GC后存活对象大于Survivor区，导致直接进入老年代。\n2.频繁产生大对象。\n3.对象始终不释放，导致内存泄漏。\n4.方法区频繁有类反射加载。\n5.错误使用System.gc()。\n\n*XMind: ZEN - Trial Version*","slug":"JVM-整理","published":1,"updated":"2020-03-01T12:53:36.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jehs0000isnyc0svlri0","content":"<h1 id=\"JVM-相关知识整理\"><a href=\"#JVM-相关知识整理\" class=\"headerlink\" title=\"JVM 相关知识整理\"></a>JVM 相关知识整理</h1><ol>\n<li>内存分配</li>\n<li>垃圾回收器的参数配置</li>\n</ol>\n<h2 id=\"类的加载\"><a href=\"#类的加载\" class=\"headerlink\" title=\"类的加载\"></a>类的加载</h2><a id=\"more\"></a>\n<p>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>\n<h3 id=\"加载流程\"><a href=\"#加载流程\" class=\"headerlink\" title=\"加载流程\"></a>加载流程</h3><ul>\n<li><p>加载</p>\n<p>代码中使用到这个类的时候，.class字节码文件就会加载这个类到JVM内存中。</p>\n</li>\n<li><p>链接</p>\n<ul>\n<li><p>验证</p>\n<p>根据JVM规范，校验.class文件。</p>\n</li>\n<li><p>准备</p>\n<p>给加载的类分配内存空间，同时给类的static变量分配内存空间，并设置默认值0。<br>clint()</p>\n</li>\n<li><p>解析</p>\n<p>把符号引用替换为直接引用。</p>\n</li>\n</ul>\n</li>\n<li><p>初始化</p>\n<p>为类变量赋值：静态方法，静态变量，静态块。<br>初始化一个类的时候，如果发现有父类还没初始化，会先初始化他的父类。</p>\n</li>\n</ul>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><ul>\n<li><p>加载器</p>\n<ul>\n<li><p>BootStrap ClassLoader</p>\n<p>加载lib目录下的类库</p>\n</li>\n<li><p>Extension ClassLoader</p>\n<p>加载lib\\ext目录下的类库</p>\n</li>\n<li><p>Application ClassLoader</p>\n<p>加载ClassPath下的类</p>\n</li>\n<li><p>自定义加载器</p>\n</li>\n</ul>\n</li>\n<li><p>双亲委派机制</p>\n<p>先找父亲加载，加载不了再找儿子加载</p>\n</li>\n</ul>\n<h2 id=\"内存结构\"><a href=\"#内存结构\" class=\"headerlink\" title=\"内存结构\"></a>内存结构</h2><h3 id=\"方法区、元空间、永久代\"><a href=\"#方法区、元空间、永久代\" class=\"headerlink\" title=\"方法区、元空间、永久代\"></a>方法区、元空间、永久代</h3><p>存放类的定义，常量池等。<br>matespace满后会触发Full GC。<br>方法区垃圾回收：<br>1.该类的所有实例已经被回收<br>2.加载该类的ClassLoader已经被回收<br>3.该类的Class对象没有被任何引用</p>\n<h3 id=\"程序技术器\"><a href=\"#程序技术器\" class=\"headerlink\" title=\"程序技术器\"></a>程序技术器</h3><p>记录当前执行的字节码指令的位置。<br>线程私有。</p>\n<h3 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h3><p>保存方法信息。<br>线程私有。</p>\n<ul>\n<li><p>栈帧</p>\n<ul>\n<li>局部变量表</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法返回地址</li>\n<li>其他</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Java堆内存\"><a href=\"#Java堆内存\" class=\"headerlink\" title=\"Java堆内存\"></a>Java堆内存</h3><p>存放类的实例对象。</p>\n<ul>\n<li><p>分代</p>\n<ul>\n<li><p>年轻代</p>\n<p>新生代进入老年代：默认15次</p>\n<ul>\n<li><p>Eden区</p>\n<p>默认新生代80%空间。<br>新建对象产生在Eden区。<br>Eden区满后会发生Minor GC。</p>\n</li>\n<li><p>Survivor0,1区</p>\n<p>默认年轻代20%。Survivor 0:10%  Survivor 1:10%。<br>默认对象幸存15次后，会进入老年区。</p>\n<ul>\n<li><p>动态年龄判断</p>\n<p>当一批对象的大小大于Survivor区大小的50%，这批对象将不询问年龄，直接进入老年代。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>老年代</p>\n<ul>\n<li><p>进入老年代的规则</p>\n<ul>\n<li>年龄超过MaxTenuring</li>\n<li>动态年龄判断</li>\n<li>超过PretenureSize的大对象</li>\n<li>Eden区幸存对象超过Survivor区大小</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM参数</p>\n<ul>\n<li><p>-Xms</p>\n<p>Java堆内存的大小</p>\n</li>\n<li><p>-Xmx</p>\n<p>Java堆内存的最大大小</p>\n</li>\n<li><p>-Xmn</p>\n<p>Java对内存中的新生代大小。<br>老年代=总大小-新生代</p>\n</li>\n<li><p>-XX:PermSize</p>\n<p>永久代大小</p>\n</li>\n<li><p>-XX:MaxPermSize</p>\n<p>永久代最大大小</p>\n</li>\n<li><p>-XX:MetaspaceSize</p>\n<p>元空间大小</p>\n</li>\n<li><p>-XX:MaxMetaspaceSize</p>\n<p>元空间最大大小</p>\n</li>\n<li><p>-Xss</p>\n<p>Java栈内存大小</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold</p>\n<p>对象在年轻代中幸存的最大轮数。<br>默认15，且不能超过15.</p>\n</li>\n<li><p>-XX:PretenureSizeThreshold</p>\n<p>当对象大小超过该值时，对象直接进入老年代，不会进过年轻代。<br>避免大对象在Survivor中多次复制，减少无谓的操作。</p>\n</li>\n<li><p>-XX:-HandlePromotionFailure</p>\n<p>判断老年代内存大小是否大于之前每一次Minor GC后进入老年代的对象的平均大小。<br>判断失败进行Full GC，再执行Minor GC。</p>\n</li>\n<li><p>-XX:SurvivorRatio</p>\n<p>调整Eden区和Survivor区内存比率</p>\n<ul>\n<li>XX:SurvivorRatio=8  ： Eden 80%</li>\n</ul>\n</li>\n<li><p>-XX:+PrintGCDetils</p>\n<p>打印详细的GC日志。</p>\n</li>\n<li><p>-XX:+PrintGCTimeStamps</p>\n<p>打印GC发生的时间。</p>\n</li>\n<li><p>-Xloggc:gc.log</p>\n<p>将CG日志输入到文件。</p>\n</li>\n<li><p>-XX:TraceClassLoading</p>\n<p>追踪加载的类</p>\n</li>\n<li><p>-XX:TraceClassUnloading</p>\n<p>追踪卸载的类</p>\n</li>\n<li><p>-XX:+HeapDumpOnOutOfMemoryError  </p>\n<p>OOM时自动dump快照</p>\n</li>\n<li><p>-XX:HeapDumpPath=/usr/local/app/oom</p>\n<p>将快照存放至指定目录</p>\n</li>\n<li><p>CMS</p>\n<ul>\n<li><p>-XX:CMSInitiatingOccupancyFaction</p>\n<p>设置老年代占用多少比例时触发CMS</p>\n</li>\n<li><p>-XX:+UseCMSCompactAtFullCollection</p>\n<p>Full GC后STW，整理内存碎片。</p>\n</li>\n<li><p>-XX:CMSFullGCsBeforeCompaction</p>\n<p>默认0，设置多少次Full GC后进行内存碎片整理。</p>\n</li>\n<li><p>-XX:+CMSParallelInitialMarkEnabled</p>\n<p>初始标记阶段开启并发执行</p>\n</li>\n</ul>\n</li>\n<li><p>G1</p>\n<ul>\n<li><p>-XX:+UseG1GC</p>\n<p>指定G1垃圾回收器。</p>\n</li>\n<li><p>-XX:G1HeapRegionSize</p>\n<p>手动指定G1的Region的大小。</p>\n</li>\n<li><p>-XX:G1NewSizePercent</p>\n<p>调整新生代在堆中的占比。<br>默认5%。</p>\n</li>\n<li><p>-XX:G1MaxNewSizePercent</p>\n<p>新生代占比堆空间的最大大小。</p>\n</li>\n<li><p>-XX:MaxGCPauseMills</p>\n<p>默认200ms。<br>设置G1垃圾回收器GC时的最大停顿时间。</p>\n</li>\n<li><p>-XX:InitiatingHeapOccupancyPercent</p>\n<p>默认45%。<br>老年代占据的堆内存超多该值，将会进行新老生代的混合回收。</p>\n</li>\n<li><p>-XX:G1MixedGCCountTarget</p>\n<p>一次G1混合回收过程中，最后阶段混合回收阶段分几次完成。<br>默认8。</p>\n</li>\n<li><p>-XX:G1HeapWastePercent</p>\n<p>默认值5%。<br>混合回收阶段中，空间Region占比堆空间超多该值，会停止混合回收。</p>\n</li>\n<li><p>-XX:G1MixedGCLiveThresholdPercent</p>\n<p>默认值85%。<br>一个Region中的存活对象低于该值时才会被回收。</p>\n</li>\n<li><p>-XX:+CMSScavengeBeforeRemark</p>\n<p>重新标记前，尽量执行一次Young GC。<br>提前回收年轻代没有引用的对象，减少重新标记扫描的对象数，提高效率。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>垃圾回收</p>\n<ul>\n<li><p>可达性分析</p>\n<p>对一个对象层层向上分析，判断是否有一个GC Root。</p>\n<ul>\n<li><p>GC Root</p>\n<ul>\n<li>本地变量表中的局部变量</li>\n<li>方法区内的静态变量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>java 引用类型</p>\n<ul>\n<li><p>强引用</p>\n<p>GC不会回收强引用</p>\n</li>\n<li><p>软引用</p>\n<p>内存空间足够时，GC不会回收软引用</p>\n</li>\n<li><p>弱引用</p>\n<p>GC时必定回收弱引用</p>\n</li>\n<li><p>虚引用</p>\n<p>继承Object的finalize()方法，在该对象被回收的时候通知自己。</p>\n</li>\n</ul>\n</li>\n<li><p>垃圾回收算法</p>\n<ul>\n<li><p>年轻代</p>\n<ul>\n<li><p>复制</p>\n<p>在新生代幸存者0,1区使用。将标记为可用的内存复制到另外一片连续的内存区域中，并删除当前内存区域中的全部数据。</p>\n<ul>\n<li><p>优点</p>\n<p>不会产生内存碎片</p>\n</li>\n<li><p>缺点</p>\n<p>增加内存的消耗</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>老年代</p>\n<ul>\n<li><p>标记整理</p>\n<p>标记存活对象，删除死亡对象，整理内存碎片。</p>\n<ul>\n<li><p>优点</p>\n<p>不会产生内存碎片。内存利用率高。</p>\n</li>\n<li><p>缺点</p>\n<p>比起标记清楚，执行效率慢。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM垃圾回收器</p>\n<ul>\n<li><p>年轻代</p>\n<ul>\n<li><p>ParNew</p>\n<p>多线程，复制算法。<br>开启：-XX:+UseParNewGC<br>调整回收线程数：-XX:ParallelGCThreads</p>\n</li>\n</ul>\n</li>\n<li><p>老年代</p>\n<ul>\n<li><p>CMS</p>\n<p>标记清理算法</p>\n<ul>\n<li><p>回收过程</p>\n<ul>\n<li><p>初始标记</p>\n<p>STW。<br>标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。</p>\n</li>\n<li><p>并发标记</p>\n<p>寻找被GC Roots间接引用的对象。</p>\n</li>\n<li><p>重新标记</p>\n<p>STW。<br>重新标记并发标记时产生的新对象。</p>\n</li>\n<li><p>并发清除</p>\n<p>清理标记的对象。</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<p>默认启动垃圾回收线程：（CPU核数 +3）/4。<br>本身会消耗CPU资源。<br>针对浮动垃圾，初始标记后产生的垃圾没法回收。<br>CMS回收期间，新生代进入老年代对象大于可用空间时，会发生Concurrent Mode Failure ，并自动使用Serial Old回收器替代CMS工作。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>G1</p>\n<p>基于复制算法。<br>把Java堆内存划分为多个大小相等的Region。<br>可以设置STW的时间，追踪每个Region里可回收对象的预估时间。<br>G1中的分代是逻辑上的分代，同一个Region会随着分配的内存对象不同，而属于不同分代。<br>每个Region的大小：堆大小/2048。<br>新生代的Region同时分Eden和Survivor，可通过-XX:SurvivorRatio调整占比。<br>适合大内存的机器，G1可以设置停顿时间，来确保对服务不会有较大的影响。</p>\n<ul>\n<li><p>大对象</p>\n<p>超多Region大小50%即为大对象。<br>大对象可能横跨多个Region。<br>空的Region都可以存放大对象。<br>新老生代GC时都会回收大对象。</p>\n</li>\n<li><p>回收过程</p>\n<ul>\n<li><p>初始标记</p>\n<p>STW。<br>标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。</p>\n</li>\n<li><p>并发标记</p>\n<p>进行GC Roots的追踪，追踪所有存活对象。<br>同时JVM会记录该阶段中新建或失去引用的对象。</p>\n</li>\n<li><p>最终标记</p>\n<p>STW。<br>通过多并发标记中JVM堆新增或失去引用的对象，进行重新标记。</p>\n</li>\n<li><p>混合回收</p>\n<p>分析Region大小，执行效率。<br>STW。<br>在指定时间内进行回收。</p>\n</li>\n</ul>\n</li>\n<li><p>问题</p>\n<p>回收中发现Region空间不够时，将会SWT，并单线程进行标记、清除、整理，效率很低。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CG触发时间</p>\n<ul>\n<li><p>Minor GC</p>\n<p>Eden区满时采用复制算法。</p>\n</li>\n<li><p>Old GC</p>\n<p>1.老年代连续可用空间 &lt; 新生代历次GC后升入老年代对象内存和的平均大小。<br>2.老年代不够存放，Minor GC后升入老年代的对象时。<br>3.老年代内存使用率超过92%时（可设置）。</p>\n</li>\n<li><p>永久代GC</p>\n<p>永久代不够使产生Full GC。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>存放native方法。</p>\n<h3 id=\"堆外内存空间\"><a href=\"#堆外内存空间\" class=\"headerlink\" title=\"堆外内存空间\"></a>堆外内存空间</h3><p>通过调用操作系统接口，直接分配对外内存空间。<br>NIO-&gt;allocateDirect(DirectByteBuffer)</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h3><p>通过jps查找java进程，再用jstat -gc PID查看GC状况。</p>\n<ul>\n<li><p>指标</p>\n<ul>\n<li><p>S0C</p>\n<p>From Survivor区大小</p>\n</li>\n<li><p>S1C</p>\n<p>To Survivor区大小</p>\n</li>\n<li><p>S0U</p>\n<p>From Survivor区当前使用大小</p>\n</li>\n<li><p>S1U</p>\n<p>To Survivor区当前使用大小</p>\n</li>\n<li><p>EC</p>\n<p>Eden区大小</p>\n</li>\n<li><p>EU</p>\n<p>Eden区当前使用的大小</p>\n</li>\n<li><p>OC</p>\n<p>老年代的大小</p>\n</li>\n<li><p>OU</p>\n<p>老年代当前使用的大小</p>\n</li>\n<li><p>MC</p>\n<p>方法区（永久代、元空间）的大小</p>\n</li>\n<li><p>MU</p>\n<p>方法区（永久代、元空间）当前使用的大小</p>\n</li>\n<li><p>YGC</p>\n<p>系统迄今为止Young GC的次数</p>\n</li>\n<li><p>YGCT</p>\n<p>Young GC耗时</p>\n</li>\n<li><p>FGC</p>\n<p>系统迄今为止Full GC的次数</p>\n</li>\n<li><p>FGCT</p>\n<p>Full GC的耗时</p>\n</li>\n<li><p>GCT</p>\n<p>所有GC的总耗时</p>\n</li>\n</ul>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>jstat -gc PID</p>\n<p>查看GC状况</p>\n</li>\n<li><p>jstat -gccapacity PID</p>\n<p>堆内存分析</p>\n</li>\n<li><p>jstat -gcnew PID</p>\n<p>新生代分析</p>\n</li>\n<li><p>jstat -gcnewcapacity PID</p>\n<p>年轻代内存分析</p>\n</li>\n<li><p>jstat -gcold PID</p>\n<p>老年代GC分析</p>\n</li>\n<li><p>jstat -gcoldcapacity PID</p>\n<p>老年代内存分析</p>\n</li>\n<li><p>jstat -gcmetacapacity PID</p>\n<p>元数据内存分析</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h3><p>了解运行时的内存区域</p>\n<ul>\n<li><p>命令</p>\n<ul>\n<li><p>jmap -heap PID</p>\n<p>打印堆内存相关参数设置。<br>当前堆内各个区的基本情况。</p>\n</li>\n<li><p>jmap -histo PID</p>\n<p>按照对象在内存中占用大小排序，降序。<br>可以了解哪个对象在堆中占用了大量的空间。</p>\n</li>\n<li><p>jmap -dump:live,format=b,file=dump.hprof PID</p>\n<p>生成内存快照并输出到文件。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jhat\"><a href=\"#jhat\" class=\"headerlink\" title=\"jhat\"></a>jhat</h3><p>分析堆内存快照，可以使用工具内置的浏览器查看。</p>\n<ul>\n<li><p>命令</p>\n<ul>\n<li><p>jhat dump.hprof -port 7000</p>\n<p>分析快照文件dump.hprof ，访问端口7000。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MAT\"><a href=\"#MAT\" class=\"headerlink\" title=\"MAT\"></a>MAT</h3><p>内存分析工具</p>\n<h2 id=\"JVM优化总结\"><a href=\"#JVM优化总结\" class=\"headerlink\" title=\"JVM优化总结\"></a>JVM优化总结</h2><h3 id=\"调整新生代的大小\"><a href=\"#调整新生代的大小\" class=\"headerlink\" title=\"调整新生代的大小\"></a>调整新生代的大小</h3><p>尽量让每次Young GC后的存活对象⼩于Survivor区域的50%，都留存在年轻代⾥。尽量别让对象进 ⼊⽼年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响</p>\n<h3 id=\"调整老年代碎片回收的频率\"><a href=\"#调整老年代碎片回收的频率\" class=\"headerlink\" title=\"调整老年代碎片回收的频率\"></a>调整老年代碎片回收的频率</h3><p>CMS一次Full GC会产生内存随便，调整碎片整理的触发轮数，可以有效的降低Full  GC产生的碎片从而降低Full GC的频次。</p>\n<h3 id=\"JVM参数模板\"><a href=\"#JVM参数模板\" class=\"headerlink\" title=\"JVM参数模板\"></a>JVM参数模板</h3><p>-Xms4096M -Xmx4096M -Xmn3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark - XX:+DisableExplicitGC -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError - XX:HeapDumpPath=/usr/local/app/oom</p>\n<h3 id=\"XX-SoftRefLRUPolicyMSPerMB\"><a href=\"#XX-SoftRefLRUPolicyMSPerMB\" class=\"headerlink\" title=\"-XX:SoftRefLRUPolicyMSPerMB\"></a>-XX:SoftRefLRUPolicyMSPerMB</h3><p>在有大量反射的情况下建议增大该值，保证软引用不会被马上回收</p>\n<h3 id=\"XX-DisableExplicitGC\"><a href=\"#XX-DisableExplicitGC\" class=\"headerlink\" title=\"-XX:+DisableExplicitGC\"></a>-XX:+DisableExplicitGC</h3><p>禁止显示执行GC<br>性质System.gc()</p>\n<h3 id=\"使用缓存淘汰机制\"><a href=\"#使用缓存淘汰机制\" class=\"headerlink\" title=\"使用缓存淘汰机制\"></a>使用缓存淘汰机制</h3><p>避免本地缓存无限增大，使得老年代常驻对象无法回收，从而导致的内存溢出和频繁的Full GC。</p>\n<h3 id=\"频繁Full-GC的可能原因\"><a href=\"#频繁Full-GC的可能原因\" class=\"headerlink\" title=\"频繁Full GC的可能原因\"></a>频繁Full GC的可能原因</h3><p>1.系统压力大，频繁Young GC后存活对象大于Survivor区，导致直接进入老年代。<br>2.频繁产生大对象。<br>3.对象始终不释放，导致内存泄漏。<br>4.方法区频繁有类反射加载。<br>5.错误使用System.gc()。</p>\n<p><em>XMind: ZEN - Trial Version</em></p>\n","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"JVM","path":"tags/JVM/"},{"name":"Java","path":"tags/Java/"}],"excerpt":"<h1 id=\"JVM-相关知识整理\"><a href=\"#JVM-相关知识整理\" class=\"headerlink\" title=\"JVM 相关知识整理\"></a>JVM 相关知识整理</h1><ol>\n<li>内存分配</li>\n<li>垃圾回收器的参数配置</li>\n</ol>\n<h2 id=\"类的加载\"><a href=\"#类的加载\" class=\"headerlink\" title=\"类的加载\"></a>类的加载</h2>","more":"<p>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>\n<h3 id=\"加载流程\"><a href=\"#加载流程\" class=\"headerlink\" title=\"加载流程\"></a>加载流程</h3><ul>\n<li><p>加载</p>\n<p>代码中使用到这个类的时候，.class字节码文件就会加载这个类到JVM内存中。</p>\n</li>\n<li><p>链接</p>\n<ul>\n<li><p>验证</p>\n<p>根据JVM规范，校验.class文件。</p>\n</li>\n<li><p>准备</p>\n<p>给加载的类分配内存空间，同时给类的static变量分配内存空间，并设置默认值0。<br>clint()</p>\n</li>\n<li><p>解析</p>\n<p>把符号引用替换为直接引用。</p>\n</li>\n</ul>\n</li>\n<li><p>初始化</p>\n<p>为类变量赋值：静态方法，静态变量，静态块。<br>初始化一个类的时候，如果发现有父类还没初始化，会先初始化他的父类。</p>\n</li>\n</ul>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><ul>\n<li><p>加载器</p>\n<ul>\n<li><p>BootStrap ClassLoader</p>\n<p>加载lib目录下的类库</p>\n</li>\n<li><p>Extension ClassLoader</p>\n<p>加载lib\\ext目录下的类库</p>\n</li>\n<li><p>Application ClassLoader</p>\n<p>加载ClassPath下的类</p>\n</li>\n<li><p>自定义加载器</p>\n</li>\n</ul>\n</li>\n<li><p>双亲委派机制</p>\n<p>先找父亲加载，加载不了再找儿子加载</p>\n</li>\n</ul>\n<h2 id=\"内存结构\"><a href=\"#内存结构\" class=\"headerlink\" title=\"内存结构\"></a>内存结构</h2><h3 id=\"方法区、元空间、永久代\"><a href=\"#方法区、元空间、永久代\" class=\"headerlink\" title=\"方法区、元空间、永久代\"></a>方法区、元空间、永久代</h3><p>存放类的定义，常量池等。<br>matespace满后会触发Full GC。<br>方法区垃圾回收：<br>1.该类的所有实例已经被回收<br>2.加载该类的ClassLoader已经被回收<br>3.该类的Class对象没有被任何引用</p>\n<h3 id=\"程序技术器\"><a href=\"#程序技术器\" class=\"headerlink\" title=\"程序技术器\"></a>程序技术器</h3><p>记录当前执行的字节码指令的位置。<br>线程私有。</p>\n<h3 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h3><p>保存方法信息。<br>线程私有。</p>\n<ul>\n<li><p>栈帧</p>\n<ul>\n<li>局部变量表</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法返回地址</li>\n<li>其他</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Java堆内存\"><a href=\"#Java堆内存\" class=\"headerlink\" title=\"Java堆内存\"></a>Java堆内存</h3><p>存放类的实例对象。</p>\n<ul>\n<li><p>分代</p>\n<ul>\n<li><p>年轻代</p>\n<p>新生代进入老年代：默认15次</p>\n<ul>\n<li><p>Eden区</p>\n<p>默认新生代80%空间。<br>新建对象产生在Eden区。<br>Eden区满后会发生Minor GC。</p>\n</li>\n<li><p>Survivor0,1区</p>\n<p>默认年轻代20%。Survivor 0:10%  Survivor 1:10%。<br>默认对象幸存15次后，会进入老年区。</p>\n<ul>\n<li><p>动态年龄判断</p>\n<p>当一批对象的大小大于Survivor区大小的50%，这批对象将不询问年龄，直接进入老年代。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>老年代</p>\n<ul>\n<li><p>进入老年代的规则</p>\n<ul>\n<li>年龄超过MaxTenuring</li>\n<li>动态年龄判断</li>\n<li>超过PretenureSize的大对象</li>\n<li>Eden区幸存对象超过Survivor区大小</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM参数</p>\n<ul>\n<li><p>-Xms</p>\n<p>Java堆内存的大小</p>\n</li>\n<li><p>-Xmx</p>\n<p>Java堆内存的最大大小</p>\n</li>\n<li><p>-Xmn</p>\n<p>Java对内存中的新生代大小。<br>老年代=总大小-新生代</p>\n</li>\n<li><p>-XX:PermSize</p>\n<p>永久代大小</p>\n</li>\n<li><p>-XX:MaxPermSize</p>\n<p>永久代最大大小</p>\n</li>\n<li><p>-XX:MetaspaceSize</p>\n<p>元空间大小</p>\n</li>\n<li><p>-XX:MaxMetaspaceSize</p>\n<p>元空间最大大小</p>\n</li>\n<li><p>-Xss</p>\n<p>Java栈内存大小</p>\n</li>\n<li><p>-XX:MaxTenuringThreshold</p>\n<p>对象在年轻代中幸存的最大轮数。<br>默认15，且不能超过15.</p>\n</li>\n<li><p>-XX:PretenureSizeThreshold</p>\n<p>当对象大小超过该值时，对象直接进入老年代，不会进过年轻代。<br>避免大对象在Survivor中多次复制，减少无谓的操作。</p>\n</li>\n<li><p>-XX:-HandlePromotionFailure</p>\n<p>判断老年代内存大小是否大于之前每一次Minor GC后进入老年代的对象的平均大小。<br>判断失败进行Full GC，再执行Minor GC。</p>\n</li>\n<li><p>-XX:SurvivorRatio</p>\n<p>调整Eden区和Survivor区内存比率</p>\n<ul>\n<li>XX:SurvivorRatio=8  ： Eden 80%</li>\n</ul>\n</li>\n<li><p>-XX:+PrintGCDetils</p>\n<p>打印详细的GC日志。</p>\n</li>\n<li><p>-XX:+PrintGCTimeStamps</p>\n<p>打印GC发生的时间。</p>\n</li>\n<li><p>-Xloggc:gc.log</p>\n<p>将CG日志输入到文件。</p>\n</li>\n<li><p>-XX:TraceClassLoading</p>\n<p>追踪加载的类</p>\n</li>\n<li><p>-XX:TraceClassUnloading</p>\n<p>追踪卸载的类</p>\n</li>\n<li><p>-XX:+HeapDumpOnOutOfMemoryError  </p>\n<p>OOM时自动dump快照</p>\n</li>\n<li><p>-XX:HeapDumpPath=/usr/local/app/oom</p>\n<p>将快照存放至指定目录</p>\n</li>\n<li><p>CMS</p>\n<ul>\n<li><p>-XX:CMSInitiatingOccupancyFaction</p>\n<p>设置老年代占用多少比例时触发CMS</p>\n</li>\n<li><p>-XX:+UseCMSCompactAtFullCollection</p>\n<p>Full GC后STW，整理内存碎片。</p>\n</li>\n<li><p>-XX:CMSFullGCsBeforeCompaction</p>\n<p>默认0，设置多少次Full GC后进行内存碎片整理。</p>\n</li>\n<li><p>-XX:+CMSParallelInitialMarkEnabled</p>\n<p>初始标记阶段开启并发执行</p>\n</li>\n</ul>\n</li>\n<li><p>G1</p>\n<ul>\n<li><p>-XX:+UseG1GC</p>\n<p>指定G1垃圾回收器。</p>\n</li>\n<li><p>-XX:G1HeapRegionSize</p>\n<p>手动指定G1的Region的大小。</p>\n</li>\n<li><p>-XX:G1NewSizePercent</p>\n<p>调整新生代在堆中的占比。<br>默认5%。</p>\n</li>\n<li><p>-XX:G1MaxNewSizePercent</p>\n<p>新生代占比堆空间的最大大小。</p>\n</li>\n<li><p>-XX:MaxGCPauseMills</p>\n<p>默认200ms。<br>设置G1垃圾回收器GC时的最大停顿时间。</p>\n</li>\n<li><p>-XX:InitiatingHeapOccupancyPercent</p>\n<p>默认45%。<br>老年代占据的堆内存超多该值，将会进行新老生代的混合回收。</p>\n</li>\n<li><p>-XX:G1MixedGCCountTarget</p>\n<p>一次G1混合回收过程中，最后阶段混合回收阶段分几次完成。<br>默认8。</p>\n</li>\n<li><p>-XX:G1HeapWastePercent</p>\n<p>默认值5%。<br>混合回收阶段中，空间Region占比堆空间超多该值，会停止混合回收。</p>\n</li>\n<li><p>-XX:G1MixedGCLiveThresholdPercent</p>\n<p>默认值85%。<br>一个Region中的存活对象低于该值时才会被回收。</p>\n</li>\n<li><p>-XX:+CMSScavengeBeforeRemark</p>\n<p>重新标记前，尽量执行一次Young GC。<br>提前回收年轻代没有引用的对象，减少重新标记扫描的对象数，提高效率。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>垃圾回收</p>\n<ul>\n<li><p>可达性分析</p>\n<p>对一个对象层层向上分析，判断是否有一个GC Root。</p>\n<ul>\n<li><p>GC Root</p>\n<ul>\n<li>本地变量表中的局部变量</li>\n<li>方法区内的静态变量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>java 引用类型</p>\n<ul>\n<li><p>强引用</p>\n<p>GC不会回收强引用</p>\n</li>\n<li><p>软引用</p>\n<p>内存空间足够时，GC不会回收软引用</p>\n</li>\n<li><p>弱引用</p>\n<p>GC时必定回收弱引用</p>\n</li>\n<li><p>虚引用</p>\n<p>继承Object的finalize()方法，在该对象被回收的时候通知自己。</p>\n</li>\n</ul>\n</li>\n<li><p>垃圾回收算法</p>\n<ul>\n<li><p>年轻代</p>\n<ul>\n<li><p>复制</p>\n<p>在新生代幸存者0,1区使用。将标记为可用的内存复制到另外一片连续的内存区域中，并删除当前内存区域中的全部数据。</p>\n<ul>\n<li><p>优点</p>\n<p>不会产生内存碎片</p>\n</li>\n<li><p>缺点</p>\n<p>增加内存的消耗</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>老年代</p>\n<ul>\n<li><p>标记整理</p>\n<p>标记存活对象，删除死亡对象，整理内存碎片。</p>\n<ul>\n<li><p>优点</p>\n<p>不会产生内存碎片。内存利用率高。</p>\n</li>\n<li><p>缺点</p>\n<p>比起标记清楚，执行效率慢。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM垃圾回收器</p>\n<ul>\n<li><p>年轻代</p>\n<ul>\n<li><p>ParNew</p>\n<p>多线程，复制算法。<br>开启：-XX:+UseParNewGC<br>调整回收线程数：-XX:ParallelGCThreads</p>\n</li>\n</ul>\n</li>\n<li><p>老年代</p>\n<ul>\n<li><p>CMS</p>\n<p>标记清理算法</p>\n<ul>\n<li><p>回收过程</p>\n<ul>\n<li><p>初始标记</p>\n<p>STW。<br>标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。</p>\n</li>\n<li><p>并发标记</p>\n<p>寻找被GC Roots间接引用的对象。</p>\n</li>\n<li><p>重新标记</p>\n<p>STW。<br>重新标记并发标记时产生的新对象。</p>\n</li>\n<li><p>并发清除</p>\n<p>清理标记的对象。</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<p>默认启动垃圾回收线程：（CPU核数 +3）/4。<br>本身会消耗CPU资源。<br>针对浮动垃圾，初始标记后产生的垃圾没法回收。<br>CMS回收期间，新生代进入老年代对象大于可用空间时，会发生Concurrent Mode Failure ，并自动使用Serial Old回收器替代CMS工作。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>G1</p>\n<p>基于复制算法。<br>把Java堆内存划分为多个大小相等的Region。<br>可以设置STW的时间，追踪每个Region里可回收对象的预估时间。<br>G1中的分代是逻辑上的分代，同一个Region会随着分配的内存对象不同，而属于不同分代。<br>每个Region的大小：堆大小/2048。<br>新生代的Region同时分Eden和Survivor，可通过-XX:SurvivorRatio调整占比。<br>适合大内存的机器，G1可以设置停顿时间，来确保对服务不会有较大的影响。</p>\n<ul>\n<li><p>大对象</p>\n<p>超多Region大小50%即为大对象。<br>大对象可能横跨多个Region。<br>空的Region都可以存放大对象。<br>新老生代GC时都会回收大对象。</p>\n</li>\n<li><p>回收过程</p>\n<ul>\n<li><p>初始标记</p>\n<p>STW。<br>标记所有GC Roots直接引用的对象，被直接引用的对象所引用的对象不会被标记。</p>\n</li>\n<li><p>并发标记</p>\n<p>进行GC Roots的追踪，追踪所有存活对象。<br>同时JVM会记录该阶段中新建或失去引用的对象。</p>\n</li>\n<li><p>最终标记</p>\n<p>STW。<br>通过多并发标记中JVM堆新增或失去引用的对象，进行重新标记。</p>\n</li>\n<li><p>混合回收</p>\n<p>分析Region大小，执行效率。<br>STW。<br>在指定时间内进行回收。</p>\n</li>\n</ul>\n</li>\n<li><p>问题</p>\n<p>回收中发现Region空间不够时，将会SWT，并单线程进行标记、清除、整理，效率很低。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CG触发时间</p>\n<ul>\n<li><p>Minor GC</p>\n<p>Eden区满时采用复制算法。</p>\n</li>\n<li><p>Old GC</p>\n<p>1.老年代连续可用空间 &lt; 新生代历次GC后升入老年代对象内存和的平均大小。<br>2.老年代不够存放，Minor GC后升入老年代的对象时。<br>3.老年代内存使用率超过92%时（可设置）。</p>\n</li>\n<li><p>永久代GC</p>\n<p>永久代不够使产生Full GC。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>存放native方法。</p>\n<h3 id=\"堆外内存空间\"><a href=\"#堆外内存空间\" class=\"headerlink\" title=\"堆外内存空间\"></a>堆外内存空间</h3><p>通过调用操作系统接口，直接分配对外内存空间。<br>NIO-&gt;allocateDirect(DirectByteBuffer)</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><h3 id=\"jstat\"><a href=\"#jstat\" class=\"headerlink\" title=\"jstat\"></a>jstat</h3><p>通过jps查找java进程，再用jstat -gc PID查看GC状况。</p>\n<ul>\n<li><p>指标</p>\n<ul>\n<li><p>S0C</p>\n<p>From Survivor区大小</p>\n</li>\n<li><p>S1C</p>\n<p>To Survivor区大小</p>\n</li>\n<li><p>S0U</p>\n<p>From Survivor区当前使用大小</p>\n</li>\n<li><p>S1U</p>\n<p>To Survivor区当前使用大小</p>\n</li>\n<li><p>EC</p>\n<p>Eden区大小</p>\n</li>\n<li><p>EU</p>\n<p>Eden区当前使用的大小</p>\n</li>\n<li><p>OC</p>\n<p>老年代的大小</p>\n</li>\n<li><p>OU</p>\n<p>老年代当前使用的大小</p>\n</li>\n<li><p>MC</p>\n<p>方法区（永久代、元空间）的大小</p>\n</li>\n<li><p>MU</p>\n<p>方法区（永久代、元空间）当前使用的大小</p>\n</li>\n<li><p>YGC</p>\n<p>系统迄今为止Young GC的次数</p>\n</li>\n<li><p>YGCT</p>\n<p>Young GC耗时</p>\n</li>\n<li><p>FGC</p>\n<p>系统迄今为止Full GC的次数</p>\n</li>\n<li><p>FGCT</p>\n<p>Full GC的耗时</p>\n</li>\n<li><p>GCT</p>\n<p>所有GC的总耗时</p>\n</li>\n</ul>\n</li>\n<li><p>命令</p>\n<ul>\n<li><p>jstat -gc PID</p>\n<p>查看GC状况</p>\n</li>\n<li><p>jstat -gccapacity PID</p>\n<p>堆内存分析</p>\n</li>\n<li><p>jstat -gcnew PID</p>\n<p>新生代分析</p>\n</li>\n<li><p>jstat -gcnewcapacity PID</p>\n<p>年轻代内存分析</p>\n</li>\n<li><p>jstat -gcold PID</p>\n<p>老年代GC分析</p>\n</li>\n<li><p>jstat -gcoldcapacity PID</p>\n<p>老年代内存分析</p>\n</li>\n<li><p>jstat -gcmetacapacity PID</p>\n<p>元数据内存分析</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jmap\"><a href=\"#jmap\" class=\"headerlink\" title=\"jmap\"></a>jmap</h3><p>了解运行时的内存区域</p>\n<ul>\n<li><p>命令</p>\n<ul>\n<li><p>jmap -heap PID</p>\n<p>打印堆内存相关参数设置。<br>当前堆内各个区的基本情况。</p>\n</li>\n<li><p>jmap -histo PID</p>\n<p>按照对象在内存中占用大小排序，降序。<br>可以了解哪个对象在堆中占用了大量的空间。</p>\n</li>\n<li><p>jmap -dump:live,format=b,file=dump.hprof PID</p>\n<p>生成内存快照并输出到文件。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jhat\"><a href=\"#jhat\" class=\"headerlink\" title=\"jhat\"></a>jhat</h3><p>分析堆内存快照，可以使用工具内置的浏览器查看。</p>\n<ul>\n<li><p>命令</p>\n<ul>\n<li><p>jhat dump.hprof -port 7000</p>\n<p>分析快照文件dump.hprof ，访问端口7000。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MAT\"><a href=\"#MAT\" class=\"headerlink\" title=\"MAT\"></a>MAT</h3><p>内存分析工具</p>\n<h2 id=\"JVM优化总结\"><a href=\"#JVM优化总结\" class=\"headerlink\" title=\"JVM优化总结\"></a>JVM优化总结</h2><h3 id=\"调整新生代的大小\"><a href=\"#调整新生代的大小\" class=\"headerlink\" title=\"调整新生代的大小\"></a>调整新生代的大小</h3><p>尽量让每次Young GC后的存活对象⼩于Survivor区域的50%，都留存在年轻代⾥。尽量别让对象进 ⼊⽼年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响</p>\n<h3 id=\"调整老年代碎片回收的频率\"><a href=\"#调整老年代碎片回收的频率\" class=\"headerlink\" title=\"调整老年代碎片回收的频率\"></a>调整老年代碎片回收的频率</h3><p>CMS一次Full GC会产生内存随便，调整碎片整理的触发轮数，可以有效的降低Full  GC产生的碎片从而降低Full GC的频次。</p>\n<h3 id=\"JVM参数模板\"><a href=\"#JVM参数模板\" class=\"headerlink\" title=\"JVM参数模板\"></a>JVM参数模板</h3><p>-Xms4096M -Xmx4096M -Xmn3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC - XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFaction=92 -XX:+UseCMSCompactAtFullCollection - XX:CMSFullGCsBeforeCompaction=0 -XX:+CMSParallelInitialMarkEnabled -XX:+CMSScavengeBeforeRemark - XX:+DisableExplicitGC -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError - XX:HeapDumpPath=/usr/local/app/oom</p>\n<h3 id=\"XX-SoftRefLRUPolicyMSPerMB\"><a href=\"#XX-SoftRefLRUPolicyMSPerMB\" class=\"headerlink\" title=\"-XX:SoftRefLRUPolicyMSPerMB\"></a>-XX:SoftRefLRUPolicyMSPerMB</h3><p>在有大量反射的情况下建议增大该值，保证软引用不会被马上回收</p>\n<h3 id=\"XX-DisableExplicitGC\"><a href=\"#XX-DisableExplicitGC\" class=\"headerlink\" title=\"-XX:+DisableExplicitGC\"></a>-XX:+DisableExplicitGC</h3><p>禁止显示执行GC<br>性质System.gc()</p>\n<h3 id=\"使用缓存淘汰机制\"><a href=\"#使用缓存淘汰机制\" class=\"headerlink\" title=\"使用缓存淘汰机制\"></a>使用缓存淘汰机制</h3><p>避免本地缓存无限增大，使得老年代常驻对象无法回收，从而导致的内存溢出和频繁的Full GC。</p>\n<h3 id=\"频繁Full-GC的可能原因\"><a href=\"#频繁Full-GC的可能原因\" class=\"headerlink\" title=\"频繁Full GC的可能原因\"></a>频繁Full GC的可能原因</h3><p>1.系统压力大，频繁Young GC后存活对象大于Survivor区，导致直接进入老年代。<br>2.频繁产生大对象。<br>3.对象始终不释放，导致内存泄漏。<br>4.方法区频繁有类反射加载。<br>5.错误使用System.gc()。</p>\n<p><em>XMind: ZEN - Trial Version</em></p>"},{"title":"多级缓存","date":"2019-09-04T07:35:11.000Z","_content":"### 起因\n项目平稳的已经运行快一年了，某天早上监控突然告警大量核心服务不可能，虽然运维紧急处理并重启了服务。但这种非正常的服务宕机着实让人捏了把冷汗（还好创业公司还没有生产事故惩罚机制）。\n\n随后我们Dump下了服务起的日志，发现事故期间JVM存在大量的Full GC，配合CAT的监控指标发现某几个接口的调用量剧增。。。。大概我们是被刷接口了。\n\n查看具体接口，发现前端反复查询配置信息而且没有做缓存，大量的大对象堆积不频繁Full GC才怪。。。。知道问题那我们就开始优化吧\n\n<!-- more -->\n\n### 缓存\n\n### Spring Cache\n\n\n注解|功能\n---|---\nCacheable|\nCacheEvict|\nCachePut|\nCaching|\n\n#### spring boot cache 流程\n{% asset_img springCache.png This is an example image %}\n\n#### 多级缓存流程\n{% asset_img 多级缓存.png This is an example image %}\n\n\n#### springboot 开启缓存很方便\n1. 依赖org.springframework.boot:spring-boot-starter-cache\n2. 在启动类增加注解@EnableCaching\n3. 在想要增加缓存的方法或者成员变量上增加以下注解\n\n#### 启用多级缓存\n1. 引入组件\n\n```gradle \n\n``` \n\n2. 开启缓存\n   \n###### 无参缓存\n```java\n\n``` \n\n###### 带参缓存1\n```java\n\n``` \n\n###### 带参缓存2\n```java\n\n``` \n\n###### 组合参数缓存\n```java\n\n``` ","source":"_posts/一个事故引起的缓存.md","raw":"---\ntitle: 多级缓存\ndate: 2019-09-04 15:35:11\ntags: \n    - Java\n    - Redis\n    - Cache\ncategories :\n    - Technology\n---\n### 起因\n项目平稳的已经运行快一年了，某天早上监控突然告警大量核心服务不可能，虽然运维紧急处理并重启了服务。但这种非正常的服务宕机着实让人捏了把冷汗（还好创业公司还没有生产事故惩罚机制）。\n\n随后我们Dump下了服务起的日志，发现事故期间JVM存在大量的Full GC，配合CAT的监控指标发现某几个接口的调用量剧增。。。。大概我们是被刷接口了。\n\n查看具体接口，发现前端反复查询配置信息而且没有做缓存，大量的大对象堆积不频繁Full GC才怪。。。。知道问题那我们就开始优化吧\n\n<!-- more -->\n\n### 缓存\n\n### Spring Cache\n\n\n注解|功能\n---|---\nCacheable|\nCacheEvict|\nCachePut|\nCaching|\n\n#### spring boot cache 流程\n{% asset_img springCache.png This is an example image %}\n\n#### 多级缓存流程\n{% asset_img 多级缓存.png This is an example image %}\n\n\n#### springboot 开启缓存很方便\n1. 依赖org.springframework.boot:spring-boot-starter-cache\n2. 在启动类增加注解@EnableCaching\n3. 在想要增加缓存的方法或者成员变量上增加以下注解\n\n#### 启用多级缓存\n1. 引入组件\n\n```gradle \n\n``` \n\n2. 开启缓存\n   \n###### 无参缓存\n```java\n\n``` \n\n###### 带参缓存1\n```java\n\n``` \n\n###### 带参缓存2\n```java\n\n``` \n\n###### 组合参数缓存\n```java\n\n``` ","slug":"一个事故引起的缓存","published":1,"updated":"2019-09-10T13:44:41.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jehw0002isnyer96cx6a","content":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>项目平稳的已经运行快一年了，某天早上监控突然告警大量核心服务不可能，虽然运维紧急处理并重启了服务。但这种非正常的服务宕机着实让人捏了把冷汗（还好创业公司还没有生产事故惩罚机制）。</p>\n<p>随后我们Dump下了服务起的日志，发现事故期间JVM存在大量的Full GC，配合CAT的监控指标发现某几个接口的调用量剧增。。。。大概我们是被刷接口了。</p>\n<p>查看具体接口，发现前端反复查询配置信息而且没有做缓存，大量的大对象堆积不频繁Full GC才怪。。。。知道问题那我们就开始优化吧</p>\n<a id=\"more\"></a>\n\n<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"Spring-Cache\"><a href=\"#Spring-Cache\" class=\"headerlink\" title=\"Spring Cache\"></a>Spring Cache</h3><table>\n<thead>\n<tr>\n<th>注解</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cacheable</td>\n<td></td>\n</tr>\n<tr>\n<td>CacheEvict</td>\n<td></td>\n</tr>\n<tr>\n<td>CachePut</td>\n<td></td>\n</tr>\n<tr>\n<td>Caching</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"spring-boot-cache-流程\"><a href=\"#spring-boot-cache-流程\" class=\"headerlink\" title=\"spring boot cache 流程\"></a>spring boot cache 流程</h4><img src=\"/2019/09/04/一个事故引起的缓存/springCache.png\" title=\"This is an example image\">\n\n<h4 id=\"多级缓存流程\"><a href=\"#多级缓存流程\" class=\"headerlink\" title=\"多级缓存流程\"></a>多级缓存流程</h4><img src=\"/2019/09/04/一个事故引起的缓存/多级缓存.png\" title=\"This is an example image\">\n\n\n<h4 id=\"springboot-开启缓存很方便\"><a href=\"#springboot-开启缓存很方便\" class=\"headerlink\" title=\"springboot 开启缓存很方便\"></a>springboot 开启缓存很方便</h4><ol>\n<li>依赖org.springframework.boot:spring-boot-starter-cache</li>\n<li>在启动类增加注解@EnableCaching</li>\n<li>在想要增加缓存的方法或者成员变量上增加以下注解</li>\n</ol>\n<h4 id=\"启用多级缓存\"><a href=\"#启用多级缓存\" class=\"headerlink\" title=\"启用多级缓存\"></a>启用多级缓存</h4><ol>\n<li>引入组件</li>\n</ol>\n<pre><code class=\"gradle\"></code></pre>\n<ol start=\"2\">\n<li>开启缓存</li>\n</ol>\n<h6 id=\"无参缓存\"><a href=\"#无参缓存\" class=\"headerlink\" title=\"无参缓存\"></a>无参缓存</h6><pre><code class=\"java\"></code></pre>\n<h6 id=\"带参缓存1\"><a href=\"#带参缓存1\" class=\"headerlink\" title=\"带参缓存1\"></a>带参缓存1</h6><pre><code class=\"java\"></code></pre>\n<h6 id=\"带参缓存2\"><a href=\"#带参缓存2\" class=\"headerlink\" title=\"带参缓存2\"></a>带参缓存2</h6><pre><code class=\"java\"></code></pre>\n<h6 id=\"组合参数缓存\"><a href=\"#组合参数缓存\" class=\"headerlink\" title=\"组合参数缓存\"></a>组合参数缓存</h6><pre><code class=\"java\"></code></pre>\n","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"Java","path":"tags/Java/"},{"name":"Redis","path":"tags/Redis/"},{"name":"Cache","path":"tags/Cache/"}],"excerpt":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>项目平稳的已经运行快一年了，某天早上监控突然告警大量核心服务不可能，虽然运维紧急处理并重启了服务。但这种非正常的服务宕机着实让人捏了把冷汗（还好创业公司还没有生产事故惩罚机制）。</p>\n<p>随后我们Dump下了服务起的日志，发现事故期间JVM存在大量的Full GC，配合CAT的监控指标发现某几个接口的调用量剧增。。。。大概我们是被刷接口了。</p>\n<p>查看具体接口，发现前端反复查询配置信息而且没有做缓存，大量的大对象堆积不频繁Full GC才怪。。。。知道问题那我们就开始优化吧</p>","more":"<h3 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h3 id=\"Spring-Cache\"><a href=\"#Spring-Cache\" class=\"headerlink\" title=\"Spring Cache\"></a>Spring Cache</h3><table>\n<thead>\n<tr>\n<th>注解</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cacheable</td>\n<td></td>\n</tr>\n<tr>\n<td>CacheEvict</td>\n<td></td>\n</tr>\n<tr>\n<td>CachePut</td>\n<td></td>\n</tr>\n<tr>\n<td>Caching</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"spring-boot-cache-流程\"><a href=\"#spring-boot-cache-流程\" class=\"headerlink\" title=\"spring boot cache 流程\"></a>spring boot cache 流程</h4><img src=\"/2019/09/04/一个事故引起的缓存/springCache.png\" title=\"This is an example image\">\n\n<h4 id=\"多级缓存流程\"><a href=\"#多级缓存流程\" class=\"headerlink\" title=\"多级缓存流程\"></a>多级缓存流程</h4><img src=\"/2019/09/04/一个事故引起的缓存/多级缓存.png\" title=\"This is an example image\">\n\n\n<h4 id=\"springboot-开启缓存很方便\"><a href=\"#springboot-开启缓存很方便\" class=\"headerlink\" title=\"springboot 开启缓存很方便\"></a>springboot 开启缓存很方便</h4><ol>\n<li>依赖org.springframework.boot:spring-boot-starter-cache</li>\n<li>在启动类增加注解@EnableCaching</li>\n<li>在想要增加缓存的方法或者成员变量上增加以下注解</li>\n</ol>\n<h4 id=\"启用多级缓存\"><a href=\"#启用多级缓存\" class=\"headerlink\" title=\"启用多级缓存\"></a>启用多级缓存</h4><ol>\n<li>引入组件</li>\n</ol>\n<pre><code class=\"gradle\"></code></pre>\n<ol start=\"2\">\n<li>开启缓存</li>\n</ol>\n<h6 id=\"无参缓存\"><a href=\"#无参缓存\" class=\"headerlink\" title=\"无参缓存\"></a>无参缓存</h6><pre><code class=\"java\"></code></pre>\n<h6 id=\"带参缓存1\"><a href=\"#带参缓存1\" class=\"headerlink\" title=\"带参缓存1\"></a>带参缓存1</h6><pre><code class=\"java\"></code></pre>\n<h6 id=\"带参缓存2\"><a href=\"#带参缓存2\" class=\"headerlink\" title=\"带参缓存2\"></a>带参缓存2</h6><pre><code class=\"java\"></code></pre>\n<h6 id=\"组合参数缓存\"><a href=\"#组合参数缓存\" class=\"headerlink\" title=\"组合参数缓存\"></a>组合参数缓存</h6><pre><code class=\"java\"></code></pre>"},{"title":"hexo搭建问题【 no layout: index.html】","date":"2019-09-07T08:03:18.000Z","_content":"\n由于在公司都是用MAC写博客，回到家想用Windows搭一套环境。\n\n但是启动的时候总是提示no layout: index.html 的错误。\n\n找了半天原因原来是个很傻的问题，这里mark下以免下次再犯。\n\n{% asset_img nolayout.jpg 200 200 no layout %}\n\n模板是空的！！！模板是空的！！！模板是空的！！！","source":"_posts/hexo搭建问题【-no-layout-index-html】.md","raw":"---\ntitle: 'hexo搭建问题【 no layout: index.html】'\ndate: 2019-09-07 16:03:18\ntags: \n    - Hexo\ncategories :\n    - Technology\n---\n\n由于在公司都是用MAC写博客，回到家想用Windows搭一套环境。\n\n但是启动的时候总是提示no layout: index.html 的错误。\n\n找了半天原因原来是个很傻的问题，这里mark下以免下次再犯。\n\n{% asset_img nolayout.jpg 200 200 no layout %}\n\n模板是空的！！！模板是空的！！！模板是空的！！！","slug":"hexo搭建问题【-no-layout-index-html】","published":1,"updated":"2019-09-10T13:44:41.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jei00006isnyzl1z02zq","content":"<p>由于在公司都是用MAC写博客，回到家想用Windows搭一套环境。</p>\n<p>但是启动的时候总是提示no layout: index.html 的错误。</p>\n<p>找了半天原因原来是个很傻的问题，这里mark下以免下次再犯。</p>\n<img src=\"/2019/09/07/hexo搭建问题【-no-layout-index-html】/nolayout.jpg\" width=\"200\" height=\"200\" title=\"no layout\">\n\n<p>模板是空的！！！模板是空的！！！模板是空的！！！</p>\n","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"Hexo","path":"tags/Hexo/"}],"excerpt":"","more":"<p>由于在公司都是用MAC写博客，回到家想用Windows搭一套环境。</p>\n<p>但是启动的时候总是提示no layout: index.html 的错误。</p>\n<p>找了半天原因原来是个很傻的问题，这里mark下以免下次再犯。</p>\n<img src=\"/2019/09/07/hexo搭建问题【-no-layout-index-html】/nolayout.jpg\" width=\"200\" height=\"200\" title=\"no layout\">\n\n<p>模板是空的！！！模板是空的！！！模板是空的！！！</p>\n"},{"title":"NIO","date":"2020-01-29T12:52:57.000Z","_content":"\n## Buffer\n\n负责数据的存取。缓冲区及时数组。用于存储不同数据类型的数据。（boolean除外）\n通过allocate()获取缓冲区\nput()，get()\n缓冲区中的核心属性\ncapacity:容量，表示缓冲区中最大存储数据的容量。一旦申明不能改变。\nlimit:界限，表示缓冲区中可以操作数据的大小。limit后端的数据不能进行读写。\nposition:位置，表示缓冲区中正在操作的位置。\n0<=mark<=posiotion<=limit<=capacity\nflip() 切换读取数据模式\nrewind() 可重复读\nclear()清空缓冲区，数据并没有被清空\nmark:标记，表示记录当前position的位置。可以通过reset()恢复到mark的位置。\nhasRemaining()：缓冲区中是否还有剩余的数据\n<!-- more -->\n### 实现类\n\n- ByteBuffer\n- CharBuffer\n- ShortBuffer\n- IntBuffer\n- LongBuffer\n- FloatBuffer\n- DoubleBuffer\n\n### 直接缓冲区&非直接缓冲区\n\n可以通过isDirect()判断是否为直接缓冲区&非直接缓冲区\n\n- 直接缓冲区(物理内存映射文件)\n\n  通过allocateDirec()方法分配直接缓冲区，将缓冲区建立在物理内存中。\n  可以提高执行效率。\n  \n  物理磁盘-内核地址空间-物理内存映射文件-用户地址空间-应用程序\n\n- 非直接缓冲区\n\n  通过allocatie()方法分配缓冲区，将缓冲区建立在JVM的内存中。\n  \n  磁盘-内核地址空间-用户地址空间-应用程序\n\n## Channel\n\n负责缓冲区中的数据传输。Channel本身不存储数据，因此需要配合缓冲区进行传输。 \n针对支持通道的泪提供了getChannel()方法：\n本地IO：\nFileInputStream/FileOutputStream\nRandomAccessFile\n网路IO：\nSocket\nSeverSocket\nDatagramSocket\n\n在JDK1.7中的NIO.2针对各个通道提供了静态方法open()\n咋JDK1.7中的NIO.2的Files工具类的newByteChannel()\n\n### 实现类\n\n- FileChannel\n- SocketChannel\n- ServerSocketChannel\n- DatagramChannel\n\n### 通道之间的数据传输\n\n- transferFrom()\n- transferTo()\n\n### 分散与聚集\n\n- 分散(Scatter)\n\n  分散读取(Scattering Reads)：将通道中的数据分散到多个缓冲区中\n\n- 聚集(Gather)\n\n  聚集写入(Gathering Writes)：将多个缓冲区中的数据聚集到通道中\n\n### 字符集(Charest)\n\n- 编码\n\n  字符串 -> 字节数组\n\n- 解码\n\n  字节数组 -> 字符串\n\n## Selector","source":"_posts/NIO.md","raw":"---\ntitle: NIO\ndate: 2020-01-29 20:52:57\ntags:\n    - Java\n    - IO\ncategories:\n    - Technology\n---\n\n## Buffer\n\n负责数据的存取。缓冲区及时数组。用于存储不同数据类型的数据。（boolean除外）\n通过allocate()获取缓冲区\nput()，get()\n缓冲区中的核心属性\ncapacity:容量，表示缓冲区中最大存储数据的容量。一旦申明不能改变。\nlimit:界限，表示缓冲区中可以操作数据的大小。limit后端的数据不能进行读写。\nposition:位置，表示缓冲区中正在操作的位置。\n0<=mark<=posiotion<=limit<=capacity\nflip() 切换读取数据模式\nrewind() 可重复读\nclear()清空缓冲区，数据并没有被清空\nmark:标记，表示记录当前position的位置。可以通过reset()恢复到mark的位置。\nhasRemaining()：缓冲区中是否还有剩余的数据\n<!-- more -->\n### 实现类\n\n- ByteBuffer\n- CharBuffer\n- ShortBuffer\n- IntBuffer\n- LongBuffer\n- FloatBuffer\n- DoubleBuffer\n\n### 直接缓冲区&非直接缓冲区\n\n可以通过isDirect()判断是否为直接缓冲区&非直接缓冲区\n\n- 直接缓冲区(物理内存映射文件)\n\n  通过allocateDirec()方法分配直接缓冲区，将缓冲区建立在物理内存中。\n  可以提高执行效率。\n  \n  物理磁盘-内核地址空间-物理内存映射文件-用户地址空间-应用程序\n\n- 非直接缓冲区\n\n  通过allocatie()方法分配缓冲区，将缓冲区建立在JVM的内存中。\n  \n  磁盘-内核地址空间-用户地址空间-应用程序\n\n## Channel\n\n负责缓冲区中的数据传输。Channel本身不存储数据，因此需要配合缓冲区进行传输。 \n针对支持通道的泪提供了getChannel()方法：\n本地IO：\nFileInputStream/FileOutputStream\nRandomAccessFile\n网路IO：\nSocket\nSeverSocket\nDatagramSocket\n\n在JDK1.7中的NIO.2针对各个通道提供了静态方法open()\n咋JDK1.7中的NIO.2的Files工具类的newByteChannel()\n\n### 实现类\n\n- FileChannel\n- SocketChannel\n- ServerSocketChannel\n- DatagramChannel\n\n### 通道之间的数据传输\n\n- transferFrom()\n- transferTo()\n\n### 分散与聚集\n\n- 分散(Scatter)\n\n  分散读取(Scattering Reads)：将通道中的数据分散到多个缓冲区中\n\n- 聚集(Gather)\n\n  聚集写入(Gathering Writes)：将多个缓冲区中的数据聚集到通道中\n\n### 字符集(Charest)\n\n- 编码\n\n  字符串 -> 字节数组\n\n- 解码\n\n  字节数组 -> 字符串\n\n## Selector","slug":"NIO","published":1,"updated":"2020-01-29T12:56:21.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jei30008isnyqd769a2j","content":"<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>负责数据的存取。缓冲区及时数组。用于存储不同数据类型的数据。（boolean除外）<br>通过allocate()获取缓冲区<br>put()，get()<br>缓冲区中的核心属性<br>capacity:容量，表示缓冲区中最大存储数据的容量。一旦申明不能改变。<br>limit:界限，表示缓冲区中可以操作数据的大小。limit后端的数据不能进行读写。<br>position:位置，表示缓冲区中正在操作的位置。<br>0&lt;=mark&lt;=posiotion&lt;=limit&lt;=capacity<br>flip() 切换读取数据模式<br>rewind() 可重复读<br>clear()清空缓冲区，数据并没有被清空<br>mark:标记，表示记录当前position的位置。可以通过reset()恢复到mark的位置。<br>hasRemaining()：缓冲区中是否还有剩余的数据</p>\n<a id=\"more\"></a>\n<h3 id=\"实现类\"><a href=\"#实现类\" class=\"headerlink\" title=\"实现类\"></a>实现类</h3><ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n<h3 id=\"直接缓冲区-amp-非直接缓冲区\"><a href=\"#直接缓冲区-amp-非直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区&amp;非直接缓冲区\"></a>直接缓冲区&amp;非直接缓冲区</h3><p>可以通过isDirect()判断是否为直接缓冲区&amp;非直接缓冲区</p>\n<ul>\n<li><p>直接缓冲区(物理内存映射文件)</p>\n<p>通过allocateDirec()方法分配直接缓冲区，将缓冲区建立在物理内存中。<br>可以提高执行效率。</p>\n<p>物理磁盘-内核地址空间-物理内存映射文件-用户地址空间-应用程序</p>\n</li>\n<li><p>非直接缓冲区</p>\n<p>通过allocatie()方法分配缓冲区，将缓冲区建立在JVM的内存中。</p>\n<p>磁盘-内核地址空间-用户地址空间-应用程序</p>\n</li>\n</ul>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>负责缓冲区中的数据传输。Channel本身不存储数据，因此需要配合缓冲区进行传输。<br>针对支持通道的泪提供了getChannel()方法：<br>本地IO：<br>FileInputStream/FileOutputStream<br>RandomAccessFile<br>网路IO：<br>Socket<br>SeverSocket<br>DatagramSocket</p>\n<p>在JDK1.7中的NIO.2针对各个通道提供了静态方法open()<br>咋JDK1.7中的NIO.2的Files工具类的newByteChannel()</p>\n<h3 id=\"实现类-1\"><a href=\"#实现类-1\" class=\"headerlink\" title=\"实现类\"></a>实现类</h3><ul>\n<li>FileChannel</li>\n<li>SocketChannel</li>\n<li>ServerSocketChannel</li>\n<li>DatagramChannel</li>\n</ul>\n<h3 id=\"通道之间的数据传输\"><a href=\"#通道之间的数据传输\" class=\"headerlink\" title=\"通道之间的数据传输\"></a>通道之间的数据传输</h3><ul>\n<li>transferFrom()</li>\n<li>transferTo()</li>\n</ul>\n<h3 id=\"分散与聚集\"><a href=\"#分散与聚集\" class=\"headerlink\" title=\"分散与聚集\"></a>分散与聚集</h3><ul>\n<li><p>分散(Scatter)</p>\n<p>分散读取(Scattering Reads)：将通道中的数据分散到多个缓冲区中</p>\n</li>\n<li><p>聚集(Gather)</p>\n<p>聚集写入(Gathering Writes)：将多个缓冲区中的数据聚集到通道中</p>\n</li>\n</ul>\n<h3 id=\"字符集-Charest\"><a href=\"#字符集-Charest\" class=\"headerlink\" title=\"字符集(Charest)\"></a>字符集(Charest)</h3><ul>\n<li><p>编码</p>\n<p>字符串 -&gt; 字节数组</p>\n</li>\n<li><p>解码</p>\n<p>字节数组 -&gt; 字符串</p>\n</li>\n</ul>\n<h2 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h2>","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"Java","path":"tags/Java/"},{"name":"IO","path":"tags/IO/"}],"excerpt":"<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><p>负责数据的存取。缓冲区及时数组。用于存储不同数据类型的数据。（boolean除外）<br>通过allocate()获取缓冲区<br>put()，get()<br>缓冲区中的核心属性<br>capacity:容量，表示缓冲区中最大存储数据的容量。一旦申明不能改变。<br>limit:界限，表示缓冲区中可以操作数据的大小。limit后端的数据不能进行读写。<br>position:位置，表示缓冲区中正在操作的位置。<br>0&lt;=mark&lt;=posiotion&lt;=limit&lt;=capacity<br>flip() 切换读取数据模式<br>rewind() 可重复读<br>clear()清空缓冲区，数据并没有被清空<br>mark:标记，表示记录当前position的位置。可以通过reset()恢复到mark的位置。<br>hasRemaining()：缓冲区中是否还有剩余的数据</p>","more":"<h3 id=\"实现类\"><a href=\"#实现类\" class=\"headerlink\" title=\"实现类\"></a>实现类</h3><ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n<h3 id=\"直接缓冲区-amp-非直接缓冲区\"><a href=\"#直接缓冲区-amp-非直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区&amp;非直接缓冲区\"></a>直接缓冲区&amp;非直接缓冲区</h3><p>可以通过isDirect()判断是否为直接缓冲区&amp;非直接缓冲区</p>\n<ul>\n<li><p>直接缓冲区(物理内存映射文件)</p>\n<p>通过allocateDirec()方法分配直接缓冲区，将缓冲区建立在物理内存中。<br>可以提高执行效率。</p>\n<p>物理磁盘-内核地址空间-物理内存映射文件-用户地址空间-应用程序</p>\n</li>\n<li><p>非直接缓冲区</p>\n<p>通过allocatie()方法分配缓冲区，将缓冲区建立在JVM的内存中。</p>\n<p>磁盘-内核地址空间-用户地址空间-应用程序</p>\n</li>\n</ul>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>负责缓冲区中的数据传输。Channel本身不存储数据，因此需要配合缓冲区进行传输。<br>针对支持通道的泪提供了getChannel()方法：<br>本地IO：<br>FileInputStream/FileOutputStream<br>RandomAccessFile<br>网路IO：<br>Socket<br>SeverSocket<br>DatagramSocket</p>\n<p>在JDK1.7中的NIO.2针对各个通道提供了静态方法open()<br>咋JDK1.7中的NIO.2的Files工具类的newByteChannel()</p>\n<h3 id=\"实现类-1\"><a href=\"#实现类-1\" class=\"headerlink\" title=\"实现类\"></a>实现类</h3><ul>\n<li>FileChannel</li>\n<li>SocketChannel</li>\n<li>ServerSocketChannel</li>\n<li>DatagramChannel</li>\n</ul>\n<h3 id=\"通道之间的数据传输\"><a href=\"#通道之间的数据传输\" class=\"headerlink\" title=\"通道之间的数据传输\"></a>通道之间的数据传输</h3><ul>\n<li>transferFrom()</li>\n<li>transferTo()</li>\n</ul>\n<h3 id=\"分散与聚集\"><a href=\"#分散与聚集\" class=\"headerlink\" title=\"分散与聚集\"></a>分散与聚集</h3><ul>\n<li><p>分散(Scatter)</p>\n<p>分散读取(Scattering Reads)：将通道中的数据分散到多个缓冲区中</p>\n</li>\n<li><p>聚集(Gather)</p>\n<p>聚集写入(Gathering Writes)：将多个缓冲区中的数据聚集到通道中</p>\n</li>\n</ul>\n<h3 id=\"字符集-Charest\"><a href=\"#字符集-Charest\" class=\"headerlink\" title=\"字符集(Charest)\"></a>字符集(Charest)</h3><ul>\n<li><p>编码</p>\n<p>字符串 -&gt; 字节数组</p>\n</li>\n<li><p>解码</p>\n<p>字节数组 -&gt; 字符串</p>\n</li>\n</ul>\n<h2 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h2>"},{"title":"分布式一致性算法整理","date":"2020-03-01T12:56:56.000Z","_content":"\n# 分布式算法相关知识总结（施工中）\n总结当前使用较多的一种分布式一致性算法的原理及其运用。\n\n## Raft\n<!-- more -->\n### 角色\n\n最多只有一个Leader，正常工作时期只有Leader和Follower\n\n- 成员\n\n\t- Leader\n\n\t  接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。\n\n\t- Follower\n\n\t  接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。\n\n\t- Candidate\n\n\t  Leader选举过程中的临时角色。\n\n- 角色变化\n\n\t- Leader\n\n\t  Leader在当前任期term中失去服务链接，将会变为Candidate。\n\n\t- Follower\n\n\t  1.节点初始状态为Follower。\n\t  2.Follower超时没有收到Leader的消息，会转变为Candidate，并开始选举。\n\n\t- Candidate\n\n\t  1.选举成功成为Leader。\n\t  2.选举失败成为Follower。\n\t  3.超时重新选举，还是Candidate。\n\n### Leader选举\n\n1.Follower超时没有收到Leader的心跳时会发起选举，选举时会将自己的term+1，并转化为Candidate且投票给自己，并向集群内发送RequestVote RPC。\n\n- 赢得最多选票成为Leader\n- 收到其他Leader信息，被抢先选举\n- 没有服务获得最多选票，等待重新发起选举\n\n### 日志同步\n\n1.Leader接受客户端信息。\n2.Leader向Follower发起日志复制，AppendEntries RPC。\n3.Follower未成功接受时，Leader会持续向Follower发起AppendEntries RPC。\n4.大部分Follower返回成功时，Leader向客户端返回成功结果，并允许改条日志commit。\n\n- 日志\n\n  日志包含索引，当前term号，和状态机的执行命令。\n\n- 同步\n\n  1.相同索引和term号的命令是相同的。\n  2.相同索引和term号之前的日志都是相同的。\n  \n  Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目\n\n### 安全性\n\n1.拥有最新的已提交的log entry的Follower才有资格成为Leader。\n2.Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。\n\n### 日志压缩\n\nRaft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。\n每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。\n\n- Snapshot\n\n  1.日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。\n  2.系统当前状态。\n  \n  Leader会以Snapshot的形式发给日志落后太多或新上线的Follower，使用InstalledSnapshot RPC。\n\n## Paxos\n\n*XMind: ZEN - Trial Version*","source":"_posts/分布式一致性算法整理.md","raw":"---\ntitle: 分布式一致性算法整理\ndate: 2020-03-01 20:56:56\ntags: \n    - Java\ncategories :\n    - Technology\n---\n\n# 分布式算法相关知识总结（施工中）\n总结当前使用较多的一种分布式一致性算法的原理及其运用。\n\n## Raft\n<!-- more -->\n### 角色\n\n最多只有一个Leader，正常工作时期只有Leader和Follower\n\n- 成员\n\n\t- Leader\n\n\t  接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。\n\n\t- Follower\n\n\t  接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。\n\n\t- Candidate\n\n\t  Leader选举过程中的临时角色。\n\n- 角色变化\n\n\t- Leader\n\n\t  Leader在当前任期term中失去服务链接，将会变为Candidate。\n\n\t- Follower\n\n\t  1.节点初始状态为Follower。\n\t  2.Follower超时没有收到Leader的消息，会转变为Candidate，并开始选举。\n\n\t- Candidate\n\n\t  1.选举成功成为Leader。\n\t  2.选举失败成为Follower。\n\t  3.超时重新选举，还是Candidate。\n\n### Leader选举\n\n1.Follower超时没有收到Leader的心跳时会发起选举，选举时会将自己的term+1，并转化为Candidate且投票给自己，并向集群内发送RequestVote RPC。\n\n- 赢得最多选票成为Leader\n- 收到其他Leader信息，被抢先选举\n- 没有服务获得最多选票，等待重新发起选举\n\n### 日志同步\n\n1.Leader接受客户端信息。\n2.Leader向Follower发起日志复制，AppendEntries RPC。\n3.Follower未成功接受时，Leader会持续向Follower发起AppendEntries RPC。\n4.大部分Follower返回成功时，Leader向客户端返回成功结果，并允许改条日志commit。\n\n- 日志\n\n  日志包含索引，当前term号，和状态机的执行命令。\n\n- 同步\n\n  1.相同索引和term号的命令是相同的。\n  2.相同索引和term号之前的日志都是相同的。\n  \n  Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目\n\n### 安全性\n\n1.拥有最新的已提交的log entry的Follower才有资格成为Leader。\n2.Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。\n\n### 日志压缩\n\nRaft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。\n每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。\n\n- Snapshot\n\n  1.日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。\n  2.系统当前状态。\n  \n  Leader会以Snapshot的形式发给日志落后太多或新上线的Follower，使用InstalledSnapshot RPC。\n\n## Paxos\n\n*XMind: ZEN - Trial Version*","slug":"分布式一致性算法整理","published":1,"updated":"2020-03-01T13:00:00.166Z","_id":"ck791jei40009isnyd9cbjfav","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"分布式算法相关知识总结（施工中）\"><a href=\"#分布式算法相关知识总结（施工中）\" class=\"headerlink\" title=\"分布式算法相关知识总结（施工中）\"></a>分布式算法相关知识总结（施工中）</h1><p>总结当前使用较多的一种分布式一致性算法的原理及其运用。</p>\n<h2 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h2><a id=\"more\"></a>\n<h3 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h3><p>最多只有一个Leader，正常工作时期只有Leader和Follower</p>\n<ul>\n<li><p>成员</p>\n<ul>\n<li><p>Leader</p>\n<p>接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</p>\n</li>\n<li><p>Follower</p>\n<p>接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</p>\n</li>\n<li><p>Candidate</p>\n<p>Leader选举过程中的临时角色。</p>\n</li>\n</ul>\n</li>\n<li><p>角色变化</p>\n<ul>\n<li><p>Leader</p>\n<p>Leader在当前任期term中失去服务链接，将会变为Candidate。</p>\n</li>\n<li><p>Follower</p>\n<p>1.节点初始状态为Follower。<br>2.Follower超时没有收到Leader的消息，会转变为Candidate，并开始选举。</p>\n</li>\n<li><p>Candidate</p>\n<p>1.选举成功成为Leader。<br>2.选举失败成为Follower。<br>3.超时重新选举，还是Candidate。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Leader选举\"><a href=\"#Leader选举\" class=\"headerlink\" title=\"Leader选举\"></a>Leader选举</h3><p>1.Follower超时没有收到Leader的心跳时会发起选举，选举时会将自己的term+1，并转化为Candidate且投票给自己，并向集群内发送RequestVote RPC。</p>\n<ul>\n<li>赢得最多选票成为Leader</li>\n<li>收到其他Leader信息，被抢先选举</li>\n<li>没有服务获得最多选票，等待重新发起选举</li>\n</ul>\n<h3 id=\"日志同步\"><a href=\"#日志同步\" class=\"headerlink\" title=\"日志同步\"></a>日志同步</h3><p>1.Leader接受客户端信息。<br>2.Leader向Follower发起日志复制，AppendEntries RPC。<br>3.Follower未成功接受时，Leader会持续向Follower发起AppendEntries RPC。<br>4.大部分Follower返回成功时，Leader向客户端返回成功结果，并允许改条日志commit。</p>\n<ul>\n<li><p>日志</p>\n<p>日志包含索引，当前term号，和状态机的执行命令。</p>\n</li>\n<li><p>同步</p>\n<p>1.相同索引和term号的命令是相同的。<br>2.相同索引和term号之前的日志都是相同的。</p>\n<p>Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目</p>\n</li>\n</ul>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>1.拥有最新的已提交的log entry的Follower才有资格成为Leader。<br>2.Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</p>\n<h3 id=\"日志压缩\"><a href=\"#日志压缩\" class=\"headerlink\" title=\"日志压缩\"></a>日志压缩</h3><p>Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。<br>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p>\n<ul>\n<li><p>Snapshot</p>\n<p>1.日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。<br>2.系统当前状态。</p>\n<p>Leader会以Snapshot的形式发给日志落后太多或新上线的Follower，使用InstalledSnapshot RPC。</p>\n</li>\n</ul>\n<h2 id=\"Paxos\"><a href=\"#Paxos\" class=\"headerlink\" title=\"Paxos\"></a>Paxos</h2><p><em>XMind: ZEN - Trial Version</em></p>\n","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"Java","path":"tags/Java/"}],"excerpt":"<h1 id=\"分布式算法相关知识总结（施工中）\"><a href=\"#分布式算法相关知识总结（施工中）\" class=\"headerlink\" title=\"分布式算法相关知识总结（施工中）\"></a>分布式算法相关知识总结（施工中）</h1><p>总结当前使用较多的一种分布式一致性算法的原理及其运用。</p>\n<h2 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h2>","more":"<h3 id=\"角色\"><a href=\"#角色\" class=\"headerlink\" title=\"角色\"></a>角色</h3><p>最多只有一个Leader，正常工作时期只有Leader和Follower</p>\n<ul>\n<li><p>成员</p>\n<ul>\n<li><p>Leader</p>\n<p>接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</p>\n</li>\n<li><p>Follower</p>\n<p>接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</p>\n</li>\n<li><p>Candidate</p>\n<p>Leader选举过程中的临时角色。</p>\n</li>\n</ul>\n</li>\n<li><p>角色变化</p>\n<ul>\n<li><p>Leader</p>\n<p>Leader在当前任期term中失去服务链接，将会变为Candidate。</p>\n</li>\n<li><p>Follower</p>\n<p>1.节点初始状态为Follower。<br>2.Follower超时没有收到Leader的消息，会转变为Candidate，并开始选举。</p>\n</li>\n<li><p>Candidate</p>\n<p>1.选举成功成为Leader。<br>2.选举失败成为Follower。<br>3.超时重新选举，还是Candidate。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Leader选举\"><a href=\"#Leader选举\" class=\"headerlink\" title=\"Leader选举\"></a>Leader选举</h3><p>1.Follower超时没有收到Leader的心跳时会发起选举，选举时会将自己的term+1，并转化为Candidate且投票给自己，并向集群内发送RequestVote RPC。</p>\n<ul>\n<li>赢得最多选票成为Leader</li>\n<li>收到其他Leader信息，被抢先选举</li>\n<li>没有服务获得最多选票，等待重新发起选举</li>\n</ul>\n<h3 id=\"日志同步\"><a href=\"#日志同步\" class=\"headerlink\" title=\"日志同步\"></a>日志同步</h3><p>1.Leader接受客户端信息。<br>2.Leader向Follower发起日志复制，AppendEntries RPC。<br>3.Follower未成功接受时，Leader会持续向Follower发起AppendEntries RPC。<br>4.大部分Follower返回成功时，Leader向客户端返回成功结果，并允许改条日志commit。</p>\n<ul>\n<li><p>日志</p>\n<p>日志包含索引，当前term号，和状态机的执行命令。</p>\n</li>\n<li><p>同步</p>\n<p>1.相同索引和term号的命令是相同的。<br>2.相同索引和term号之前的日志都是相同的。</p>\n<p>Leader为了使Followers的日志同自己的一致，Leader需要找到Followers同它的日志一致的地方，然后覆盖Followers在该位置之后的条目</p>\n</li>\n</ul>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>1.拥有最新的已提交的log entry的Follower才有资格成为Leader。<br>2.Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</p>\n<h3 id=\"日志压缩\"><a href=\"#日志压缩\" class=\"headerlink\" title=\"日志压缩\"></a>日志压缩</h3><p>Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。<br>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p>\n<ul>\n<li><p>Snapshot</p>\n<p>1.日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。<br>2.系统当前状态。</p>\n<p>Leader会以Snapshot的形式发给日志落后太多或新上线的Follower，使用InstalledSnapshot RPC。</p>\n</li>\n</ul>\n<h2 id=\"Paxos\"><a href=\"#Paxos\" class=\"headerlink\" title=\"Paxos\"></a>Paxos</h2><p><em>XMind: ZEN - Trial Version</em></p>"},{"title":"分布式事务整理","date":"2020-03-01T12:54:06.000Z","_content":"\n# 分布式事务的相关知识整理\n包括分布式事务的集中解决方案和运用场景。\n\n## 两阶段提交/XA\n\n常见于单系统操作多数据源。\n由于依赖数据库的事务，导致效率低，不适合高并发场景。\n<!-- more -->\n### 事务管理器\n\n### 流程\n\n- 第一阶段\n\n\t- 发起事务\n\t- 取消事务\n\n- 第二阶段\n\n\t- 通知执行每一个任务\n\n## TCC\n\n适合对分布式一致性要求要的系统，如支付、交易等\n\n### 流程\n\n- Try\n\n  对各个服务的资源进行检查，业务校验等。\n\n- Confirm\n\n  进行实际的操作\n\n- Cancel\n\n  错误发生时，对之前的操作进行回滚\n\n### 问题\n\n业务耦合比较大，需要大量的业务代码支持\n\n## 本地消息表\n\n可以保证事务的最终一致性，但不适用于高并发场景\n\n### 流程\n\n- A系统业务操作后落消息表并MQ通知B系统\n- B系统接收消息后执行业务操作，并更新A、B信息消息状态\n- B系统未成功时，A系统会一直重试到成功\n\n## 可靠消息最终一致性\n\n依赖RMQ的消息事务，和高可用，保证消息一定通知到，并最终保证事务的一致性\n\n### 流程\n\n- A系统发送prepare消息至MQ，并处理业务\n- A系统处理业务成功后发送Confirm消息至MQ\n- B系统收到Confirm消息后执行业务\n\n## 最大努力通知方案\n\n可以允许一定程度上的事务失败，一般用在对分布式事务不要个的系统，比如日志收集等\n\n### A系统发送消息至MQ\n\n### 最大努力系统接收MQ通知并调用B系统\n\n*XMind: ZEN - Trial Version*","source":"_posts/分布式事务整理.md","raw":"---\ntitle: 分布式事务整理\ndate: 2020-03-01 20:54:06\ntags: \n    - Java\ncategories :\n    - Technology\n---\n\n# 分布式事务的相关知识整理\n包括分布式事务的集中解决方案和运用场景。\n\n## 两阶段提交/XA\n\n常见于单系统操作多数据源。\n由于依赖数据库的事务，导致效率低，不适合高并发场景。\n<!-- more -->\n### 事务管理器\n\n### 流程\n\n- 第一阶段\n\n\t- 发起事务\n\t- 取消事务\n\n- 第二阶段\n\n\t- 通知执行每一个任务\n\n## TCC\n\n适合对分布式一致性要求要的系统，如支付、交易等\n\n### 流程\n\n- Try\n\n  对各个服务的资源进行检查，业务校验等。\n\n- Confirm\n\n  进行实际的操作\n\n- Cancel\n\n  错误发生时，对之前的操作进行回滚\n\n### 问题\n\n业务耦合比较大，需要大量的业务代码支持\n\n## 本地消息表\n\n可以保证事务的最终一致性，但不适用于高并发场景\n\n### 流程\n\n- A系统业务操作后落消息表并MQ通知B系统\n- B系统接收消息后执行业务操作，并更新A、B信息消息状态\n- B系统未成功时，A系统会一直重试到成功\n\n## 可靠消息最终一致性\n\n依赖RMQ的消息事务，和高可用，保证消息一定通知到，并最终保证事务的一致性\n\n### 流程\n\n- A系统发送prepare消息至MQ，并处理业务\n- A系统处理业务成功后发送Confirm消息至MQ\n- B系统收到Confirm消息后执行业务\n\n## 最大努力通知方案\n\n可以允许一定程度上的事务失败，一般用在对分布式事务不要个的系统，比如日志收集等\n\n### A系统发送消息至MQ\n\n### 最大努力系统接收MQ通知并调用B系统\n\n*XMind: ZEN - Trial Version*","slug":"分布式事务整理","published":1,"updated":"2020-03-01T12:56:18.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jei8000cisnydqswz9pj","content":"<h1 id=\"分布式事务的相关知识整理\"><a href=\"#分布式事务的相关知识整理\" class=\"headerlink\" title=\"分布式事务的相关知识整理\"></a>分布式事务的相关知识整理</h1><p>包括分布式事务的集中解决方案和运用场景。</p>\n<h2 id=\"两阶段提交-XA\"><a href=\"#两阶段提交-XA\" class=\"headerlink\" title=\"两阶段提交/XA\"></a>两阶段提交/XA</h2><p>常见于单系统操作多数据源。<br>由于依赖数据库的事务，导致效率低，不适合高并发场景。</p>\n<a id=\"more\"></a>\n<h3 id=\"事务管理器\"><a href=\"#事务管理器\" class=\"headerlink\" title=\"事务管理器\"></a>事务管理器</h3><h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li><p>第一阶段</p>\n<ul>\n<li>发起事务</li>\n<li>取消事务</li>\n</ul>\n</li>\n<li><p>第二阶段</p>\n<ul>\n<li>通知执行每一个任务</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h2><p>适合对分布式一致性要求要的系统，如支付、交易等</p>\n<h3 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li><p>Try</p>\n<p>对各个服务的资源进行检查，业务校验等。</p>\n</li>\n<li><p>Confirm</p>\n<p>进行实际的操作</p>\n</li>\n<li><p>Cancel</p>\n<p>错误发生时，对之前的操作进行回滚</p>\n</li>\n</ul>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>业务耦合比较大，需要大量的业务代码支持</p>\n<h2 id=\"本地消息表\"><a href=\"#本地消息表\" class=\"headerlink\" title=\"本地消息表\"></a>本地消息表</h2><p>可以保证事务的最终一致性，但不适用于高并发场景</p>\n<h3 id=\"流程-2\"><a href=\"#流程-2\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li>A系统业务操作后落消息表并MQ通知B系统</li>\n<li>B系统接收消息后执行业务操作，并更新A、B信息消息状态</li>\n<li>B系统未成功时，A系统会一直重试到成功</li>\n</ul>\n<h2 id=\"可靠消息最终一致性\"><a href=\"#可靠消息最终一致性\" class=\"headerlink\" title=\"可靠消息最终一致性\"></a>可靠消息最终一致性</h2><p>依赖RMQ的消息事务，和高可用，保证消息一定通知到，并最终保证事务的一致性</p>\n<h3 id=\"流程-3\"><a href=\"#流程-3\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li>A系统发送prepare消息至MQ，并处理业务</li>\n<li>A系统处理业务成功后发送Confirm消息至MQ</li>\n<li>B系统收到Confirm消息后执行业务</li>\n</ul>\n<h2 id=\"最大努力通知方案\"><a href=\"#最大努力通知方案\" class=\"headerlink\" title=\"最大努力通知方案\"></a>最大努力通知方案</h2><p>可以允许一定程度上的事务失败，一般用在对分布式事务不要个的系统，比如日志收集等</p>\n<h3 id=\"A系统发送消息至MQ\"><a href=\"#A系统发送消息至MQ\" class=\"headerlink\" title=\"A系统发送消息至MQ\"></a>A系统发送消息至MQ</h3><h3 id=\"最大努力系统接收MQ通知并调用B系统\"><a href=\"#最大努力系统接收MQ通知并调用B系统\" class=\"headerlink\" title=\"最大努力系统接收MQ通知并调用B系统\"></a>最大努力系统接收MQ通知并调用B系统</h3><p><em>XMind: ZEN - Trial Version</em></p>\n","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"Java","path":"tags/Java/"}],"excerpt":"<h1 id=\"分布式事务的相关知识整理\"><a href=\"#分布式事务的相关知识整理\" class=\"headerlink\" title=\"分布式事务的相关知识整理\"></a>分布式事务的相关知识整理</h1><p>包括分布式事务的集中解决方案和运用场景。</p>\n<h2 id=\"两阶段提交-XA\"><a href=\"#两阶段提交-XA\" class=\"headerlink\" title=\"两阶段提交/XA\"></a>两阶段提交/XA</h2><p>常见于单系统操作多数据源。<br>由于依赖数据库的事务，导致效率低，不适合高并发场景。</p>","more":"<h3 id=\"事务管理器\"><a href=\"#事务管理器\" class=\"headerlink\" title=\"事务管理器\"></a>事务管理器</h3><h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li><p>第一阶段</p>\n<ul>\n<li>发起事务</li>\n<li>取消事务</li>\n</ul>\n</li>\n<li><p>第二阶段</p>\n<ul>\n<li>通知执行每一个任务</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCC\"><a href=\"#TCC\" class=\"headerlink\" title=\"TCC\"></a>TCC</h2><p>适合对分布式一致性要求要的系统，如支付、交易等</p>\n<h3 id=\"流程-1\"><a href=\"#流程-1\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li><p>Try</p>\n<p>对各个服务的资源进行检查，业务校验等。</p>\n</li>\n<li><p>Confirm</p>\n<p>进行实际的操作</p>\n</li>\n<li><p>Cancel</p>\n<p>错误发生时，对之前的操作进行回滚</p>\n</li>\n</ul>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>业务耦合比较大，需要大量的业务代码支持</p>\n<h2 id=\"本地消息表\"><a href=\"#本地消息表\" class=\"headerlink\" title=\"本地消息表\"></a>本地消息表</h2><p>可以保证事务的最终一致性，但不适用于高并发场景</p>\n<h3 id=\"流程-2\"><a href=\"#流程-2\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li>A系统业务操作后落消息表并MQ通知B系统</li>\n<li>B系统接收消息后执行业务操作，并更新A、B信息消息状态</li>\n<li>B系统未成功时，A系统会一直重试到成功</li>\n</ul>\n<h2 id=\"可靠消息最终一致性\"><a href=\"#可靠消息最终一致性\" class=\"headerlink\" title=\"可靠消息最终一致性\"></a>可靠消息最终一致性</h2><p>依赖RMQ的消息事务，和高可用，保证消息一定通知到，并最终保证事务的一致性</p>\n<h3 id=\"流程-3\"><a href=\"#流程-3\" class=\"headerlink\" title=\"流程\"></a>流程</h3><ul>\n<li>A系统发送prepare消息至MQ，并处理业务</li>\n<li>A系统处理业务成功后发送Confirm消息至MQ</li>\n<li>B系统收到Confirm消息后执行业务</li>\n</ul>\n<h2 id=\"最大努力通知方案\"><a href=\"#最大努力通知方案\" class=\"headerlink\" title=\"最大努力通知方案\"></a>最大努力通知方案</h2><p>可以允许一定程度上的事务失败，一般用在对分布式事务不要个的系统，比如日志收集等</p>\n<h3 id=\"A系统发送消息至MQ\"><a href=\"#A系统发送消息至MQ\" class=\"headerlink\" title=\"A系统发送消息至MQ\"></a>A系统发送消息至MQ</h3><h3 id=\"最大努力系统接收MQ通知并调用B系统\"><a href=\"#最大努力系统接收MQ通知并调用B系统\" class=\"headerlink\" title=\"最大努力系统接收MQ通知并调用B系统\"></a>最大努力系统接收MQ通知并调用B系统</h3><p><em>XMind: ZEN - Trial Version</em></p>"},{"title":"搜寻流浪狗APP???","date":"2019-09-06T15:41:32.000Z","_content":"\n## 中国AI公司开发了用鼻纹搜索流浪狗的APP\n\n\n如果瞥到流浪狗的海报一定要看看。\n\n随着一个个寒冷的日子，又要到烟花大会的季节。也是家犬被鞭炮声吓跑的季节。\n<!-- more -->\n最近家里养狗的越来越多，蹭着窗门开着主人一不留神逃跑的也不在少数，我家的爱犬就是在这个季节逃跑的。\n\n爱犬走丢时一般来说就是张贴寻狗海报或者各处打听。但是中国的一家叫Megvii（旷世）的AI公司可不一样。\n\n根据Verge报道，该公司正在开发一种像人类指纹一样识别狗鼻子形状的【狗识别系统】。使用旷世的APP，通过手机摄像头多角度拍摄狗鼻子就能登录完成。并称具有95%的精度，因此通过这个APP，有1万5000条宠物犬能再和它的主人再会。\n\n但是在中国不是用在和主人的再会，而是和政府合作规范不良狗主人的行为。\n\n具体怎样监视还不清楚，可能是宠物第一次进入家庭的时候登录吧。然后如果想搜寻有问题的狗主人，需要工作人员当场扫描狗鼻子从而鉴别狗主人？\n\n就我的话还是希望能得到随地大小便的狗狗的主人信息，毕竟家门口落下的便便。。。。。。\n\n\n\n{% blockquote 中川真知子 https://www.gizmodo.jp/2019/07/ai-start-up-dog-nose.html 中国のAIスタートアップが迷い犬を鼻の指紋（？）を使って捜索するアプリを開発 %}\n本文译自\n{% endblockquote %}","source":"_posts/搜寻流浪狗APP.md","raw":"---\ntitle: 搜寻流浪狗APP???\ndate: 2019-09-06 23:41:32\ntags: \n    - AI\n    - APP\ncategories:\n    - Translation\n---\n\n## 中国AI公司开发了用鼻纹搜索流浪狗的APP\n\n\n如果瞥到流浪狗的海报一定要看看。\n\n随着一个个寒冷的日子，又要到烟花大会的季节。也是家犬被鞭炮声吓跑的季节。\n<!-- more -->\n最近家里养狗的越来越多，蹭着窗门开着主人一不留神逃跑的也不在少数，我家的爱犬就是在这个季节逃跑的。\n\n爱犬走丢时一般来说就是张贴寻狗海报或者各处打听。但是中国的一家叫Megvii（旷世）的AI公司可不一样。\n\n根据Verge报道，该公司正在开发一种像人类指纹一样识别狗鼻子形状的【狗识别系统】。使用旷世的APP，通过手机摄像头多角度拍摄狗鼻子就能登录完成。并称具有95%的精度，因此通过这个APP，有1万5000条宠物犬能再和它的主人再会。\n\n但是在中国不是用在和主人的再会，而是和政府合作规范不良狗主人的行为。\n\n具体怎样监视还不清楚，可能是宠物第一次进入家庭的时候登录吧。然后如果想搜寻有问题的狗主人，需要工作人员当场扫描狗鼻子从而鉴别狗主人？\n\n就我的话还是希望能得到随地大小便的狗狗的主人信息，毕竟家门口落下的便便。。。。。。\n\n\n\n{% blockquote 中川真知子 https://www.gizmodo.jp/2019/07/ai-start-up-dog-nose.html 中国のAIスタートアップが迷い犬を鼻の指紋（？）を使って捜索するアプリを開発 %}\n本文译自\n{% endblockquote %}","slug":"搜寻流浪狗APP","published":1,"updated":"2019-09-10T13:44:41.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jei9000disnypxbryp3k","content":"<h2 id=\"中国AI公司开发了用鼻纹搜索流浪狗的APP\"><a href=\"#中国AI公司开发了用鼻纹搜索流浪狗的APP\" class=\"headerlink\" title=\"中国AI公司开发了用鼻纹搜索流浪狗的APP\"></a>中国AI公司开发了用鼻纹搜索流浪狗的APP</h2><p>如果瞥到流浪狗的海报一定要看看。</p>\n<p>随着一个个寒冷的日子，又要到烟花大会的季节。也是家犬被鞭炮声吓跑的季节。</p>\n<a id=\"more\"></a>\n<p>最近家里养狗的越来越多，蹭着窗门开着主人一不留神逃跑的也不在少数，我家的爱犬就是在这个季节逃跑的。</p>\n<p>爱犬走丢时一般来说就是张贴寻狗海报或者各处打听。但是中国的一家叫Megvii（旷世）的AI公司可不一样。</p>\n<p>根据Verge报道，该公司正在开发一种像人类指纹一样识别狗鼻子形状的【狗识别系统】。使用旷世的APP，通过手机摄像头多角度拍摄狗鼻子就能登录完成。并称具有95%的精度，因此通过这个APP，有1万5000条宠物犬能再和它的主人再会。</p>\n<p>但是在中国不是用在和主人的再会，而是和政府合作规范不良狗主人的行为。</p>\n<p>具体怎样监视还不清楚，可能是宠物第一次进入家庭的时候登录吧。然后如果想搜寻有问题的狗主人，需要工作人员当场扫描狗鼻子从而鉴别狗主人？</p>\n<p>就我的话还是希望能得到随地大小便的狗狗的主人信息，毕竟家门口落下的便便。。。。。。</p>\n<blockquote><p>本文译自</p>\n<footer><strong>中川真知子</strong><cite><a href=\"https://www.gizmodo.jp/2019/07/ai-start-up-dog-nose.html\" target=\"_blank\" rel=\"noopener\">中国のAIスタートアップが迷い犬を鼻の指紋（？）を使って捜索するアプリを開発</a></cite></footer></blockquote>","site":{"data":{}},"_categories":[{"name":"Translation","path":"categories/Translation/"}],"_tags":[{"name":"AI","path":"tags/AI/"},{"name":"APP","path":"tags/APP/"}],"excerpt":"<h2 id=\"中国AI公司开发了用鼻纹搜索流浪狗的APP\"><a href=\"#中国AI公司开发了用鼻纹搜索流浪狗的APP\" class=\"headerlink\" title=\"中国AI公司开发了用鼻纹搜索流浪狗的APP\"></a>中国AI公司开发了用鼻纹搜索流浪狗的APP</h2><p>如果瞥到流浪狗的海报一定要看看。</p>\n<p>随着一个个寒冷的日子，又要到烟花大会的季节。也是家犬被鞭炮声吓跑的季节。</p>","more":"<p>最近家里养狗的越来越多，蹭着窗门开着主人一不留神逃跑的也不在少数，我家的爱犬就是在这个季节逃跑的。</p>\n<p>爱犬走丢时一般来说就是张贴寻狗海报或者各处打听。但是中国的一家叫Megvii（旷世）的AI公司可不一样。</p>\n<p>根据Verge报道，该公司正在开发一种像人类指纹一样识别狗鼻子形状的【狗识别系统】。使用旷世的APP，通过手机摄像头多角度拍摄狗鼻子就能登录完成。并称具有95%的精度，因此通过这个APP，有1万5000条宠物犬能再和它的主人再会。</p>\n<p>但是在中国不是用在和主人的再会，而是和政府合作规范不良狗主人的行为。</p>\n<p>具体怎样监视还不清楚，可能是宠物第一次进入家庭的时候登录吧。然后如果想搜寻有问题的狗主人，需要工作人员当场扫描狗鼻子从而鉴别狗主人？</p>\n<p>就我的话还是希望能得到随地大小便的狗狗的主人信息，毕竟家门口落下的便便。。。。。。</p>\n<blockquote><p>本文译自</p>\n<footer><strong>中川真知子</strong><cite><a href=\"https://www.gizmodo.jp/2019/07/ai-start-up-dog-nose.html\" target=\"_blank\" rel=\"noopener\">中国のAIスタートアップが迷い犬を鼻の指紋（？）を使って捜索するアプリを開発</a></cite></footer></blockquote>"},{"title":"记一次序列化失败导致的生产问题","date":"2019-09-24T06:36:13.000Z","_content":"\n文件上传下载时出现以下错误：\n{% asset_img wenti.png 400 400 错误 %}\n<!-- more -->\n\n经过调查,由于重写了WebMvcConfigurationSupport.configureMessageConverters方法\n{% codeblock lang:java %}\n@Configuration\npublic class OpenServiceConfig extends WebMvcConfigurationSupport implements ApplicationRunner {\n\n    @Autowired\n    private Environment environment;\n\n    private ApiMappingHandlerMapping apiMappingHandlerMapping = new ApiMappingHandlerMapping();\n\n    @Override\n    protected RequestMappingHandlerMapping createRequestMappingHandlerMapping() {\n        return apiMappingHandlerMapping;\n    }\n\n    @Override\n    public void run(ApplicationArguments args) {\n        ApiMetaManager apiMetaManager = new ServiceZookeeperApiMetaManager(environment);\n        RequestMappingEvent requestMappingEvent = new DefaultRequestMappingEvent(apiMetaManager, environment);\n        requestMappingEvent.onRegisterSuccess(apiMappingHandlerMapping);\n    }\n\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.clear();\n        ObjectMapper objectMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);\n        converters.add(new MappingJackson2HttpMessageConverter(objectMapper));\n    }\n\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"swagger-ui.html\")\n                .addResourceLocations(\"classpath:/META-INF/resources/\");\n\n        registry.addResourceHandler(\"/webjars/**\")\n                .addResourceLocations(\"classpath:/META-INF/resources/webjars/\");\n    }\n}\n{% endcodeblock %}\n\nspringMVC开始加载转换器的时候会先走用户定制化方法\n{% codeblock lang:java %}\n\tprotected final List<HttpMessageConverter<?>> getMessageConverters() {\n\t\tif (this.messageConverters == null) {\n\t\t\tthis.messageConverters = new ArrayList<HttpMessageConverter<?>>();\n\t\t\tconfigureMessageConverters(this.messageConverters);\n\t\t\tif (this.messageConverters.isEmpty()) {\n\t\t\t\taddDefaultHttpMessageConverters(this.messageConverters);\n\t\t\t}\n\t\t\textendMessageConverters(this.messageConverters);\n\t\t}\n\t\treturn this.messageConverters;\n\t}\n{% endcodeblock %}\n\n如果用户没有定制化，springmvc会使用自定个的7个转换器\n{% codeblock lang:java %}\n\tprotected final void addDefaultHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {\n\t\tStringHttpMessageConverter stringConverter = new StringHttpMessageConverter();\n\t\tstringConverter.setWriteAcceptCharset(false);\n\n\t\tmessageConverters.add(new ByteArrayHttpMessageConverter());\n\t\tmessageConverters.add(stringConverter);\n\t\tmessageConverters.add(new ResourceHttpMessageConverter());\n\t\tmessageConverters.add(new SourceHttpMessageConverter<Source>());\n\t\tmessageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\n\t\tif (romePresent) {\n\t\t\tmessageConverters.add(new AtomFeedHttpMessageConverter());\n\t\t\tmessageConverters.add(new RssChannelHttpMessageConverter());\n\t\t}\n\n\t\tif (jackson2XmlPresent) {\n\t\t\tmessageConverters.add(new MappingJackson2XmlHttpMessageConverter(\n\t\t\t\t\tJackson2ObjectMapperBuilder.xml().applicationContext(this.applicationContext).build()));\n\t\t}\n\t\telse if (jaxb2Present) {\n\t\t\tmessageConverters.add(new Jaxb2RootElementHttpMessageConverter());\n\t\t}\n\n\t\tif (jackson2Present) {\n\t\t\tmessageConverters.add(new MappingJackson2HttpMessageConverter(\n\t\t\t\t\tJackson2ObjectMapperBuilder.json().applicationContext(this.applicationContext).build()));\n\t\t}\n\t\telse if (gsonPresent) {\n\t\t\tmessageConverters.add(new GsonHttpMessageConverter());\n\t\t}\n\t}\n{% endcodeblock %}\n\n由于项目在自定义的时候没有考虑到文件上传下载这种字节流的解析，导致序列化失败\n增加配置解决问题\n{% codeblock lang:java %}\nobjectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n{% endcodeblock %}","source":"_posts/记一次序列化失败导致的生产问题.md","raw":"---\ntitle: 记一次序列化失败导致的生产问题\ndate: 2019-09-24 14:36:13\ntags:\n    - Java\n    - Spring Boot\ncategories:\n    - Technology\n---\n\n文件上传下载时出现以下错误：\n{% asset_img wenti.png 400 400 错误 %}\n<!-- more -->\n\n经过调查,由于重写了WebMvcConfigurationSupport.configureMessageConverters方法\n{% codeblock lang:java %}\n@Configuration\npublic class OpenServiceConfig extends WebMvcConfigurationSupport implements ApplicationRunner {\n\n    @Autowired\n    private Environment environment;\n\n    private ApiMappingHandlerMapping apiMappingHandlerMapping = new ApiMappingHandlerMapping();\n\n    @Override\n    protected RequestMappingHandlerMapping createRequestMappingHandlerMapping() {\n        return apiMappingHandlerMapping;\n    }\n\n    @Override\n    public void run(ApplicationArguments args) {\n        ApiMetaManager apiMetaManager = new ServiceZookeeperApiMetaManager(environment);\n        RequestMappingEvent requestMappingEvent = new DefaultRequestMappingEvent(apiMetaManager, environment);\n        requestMappingEvent.onRegisterSuccess(apiMappingHandlerMapping);\n    }\n\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.clear();\n        ObjectMapper objectMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);\n        converters.add(new MappingJackson2HttpMessageConverter(objectMapper));\n    }\n\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"swagger-ui.html\")\n                .addResourceLocations(\"classpath:/META-INF/resources/\");\n\n        registry.addResourceHandler(\"/webjars/**\")\n                .addResourceLocations(\"classpath:/META-INF/resources/webjars/\");\n    }\n}\n{% endcodeblock %}\n\nspringMVC开始加载转换器的时候会先走用户定制化方法\n{% codeblock lang:java %}\n\tprotected final List<HttpMessageConverter<?>> getMessageConverters() {\n\t\tif (this.messageConverters == null) {\n\t\t\tthis.messageConverters = new ArrayList<HttpMessageConverter<?>>();\n\t\t\tconfigureMessageConverters(this.messageConverters);\n\t\t\tif (this.messageConverters.isEmpty()) {\n\t\t\t\taddDefaultHttpMessageConverters(this.messageConverters);\n\t\t\t}\n\t\t\textendMessageConverters(this.messageConverters);\n\t\t}\n\t\treturn this.messageConverters;\n\t}\n{% endcodeblock %}\n\n如果用户没有定制化，springmvc会使用自定个的7个转换器\n{% codeblock lang:java %}\n\tprotected final void addDefaultHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {\n\t\tStringHttpMessageConverter stringConverter = new StringHttpMessageConverter();\n\t\tstringConverter.setWriteAcceptCharset(false);\n\n\t\tmessageConverters.add(new ByteArrayHttpMessageConverter());\n\t\tmessageConverters.add(stringConverter);\n\t\tmessageConverters.add(new ResourceHttpMessageConverter());\n\t\tmessageConverters.add(new SourceHttpMessageConverter<Source>());\n\t\tmessageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\n\t\tif (romePresent) {\n\t\t\tmessageConverters.add(new AtomFeedHttpMessageConverter());\n\t\t\tmessageConverters.add(new RssChannelHttpMessageConverter());\n\t\t}\n\n\t\tif (jackson2XmlPresent) {\n\t\t\tmessageConverters.add(new MappingJackson2XmlHttpMessageConverter(\n\t\t\t\t\tJackson2ObjectMapperBuilder.xml().applicationContext(this.applicationContext).build()));\n\t\t}\n\t\telse if (jaxb2Present) {\n\t\t\tmessageConverters.add(new Jaxb2RootElementHttpMessageConverter());\n\t\t}\n\n\t\tif (jackson2Present) {\n\t\t\tmessageConverters.add(new MappingJackson2HttpMessageConverter(\n\t\t\t\t\tJackson2ObjectMapperBuilder.json().applicationContext(this.applicationContext).build()));\n\t\t}\n\t\telse if (gsonPresent) {\n\t\t\tmessageConverters.add(new GsonHttpMessageConverter());\n\t\t}\n\t}\n{% endcodeblock %}\n\n由于项目在自定义的时候没有考虑到文件上传下载这种字节流的解析，导致序列化失败\n增加配置解决问题\n{% codeblock lang:java %}\nobjectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n{% endcodeblock %}","slug":"记一次序列化失败导致的生产问题","published":1,"updated":"2019-09-25T12:54:24.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jeib000iisny00fcmgo5","content":"<p>文件上传下载时出现以下错误：</p>\n<img src=\"/2019/09/24/记一次序列化失败导致的生产问题/wenti.png\" width=\"400\" height=\"400\" title=\"错误\">\n<a id=\"more\"></a>\n\n<p>经过调查,由于重写了WebMvcConfigurationSupport.configureMessageConverters方法</p>\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OpenServiceConfig</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WebMvcConfigurationSupport</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ApplicationRunner</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"hljs-keyword\">private</span> Environment environment;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-keyword\">private</span> ApiMappingHandlerMapping apiMappingHandlerMapping = <span class=\"hljs-keyword\">new</span> ApiMappingHandlerMapping();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-meta\">@Override</span></span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> RequestMappingHandlerMapping <span class=\"hljs-title\">createRequestMappingHandlerMapping</span><span class=\"hljs-params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"hljs-keyword\">return</span> apiMappingHandlerMapping;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-meta\">@Override</span></span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(ApplicationArguments args)</span> </span>&#123;</span><br><span class=\"line\">        ApiMetaManager apiMetaManager = <span class=\"hljs-keyword\">new</span> ServiceZookeeperApiMetaManager(environment);</span><br><span class=\"line\">        RequestMappingEvent requestMappingEvent = <span class=\"hljs-keyword\">new</span> DefaultRequestMappingEvent(apiMetaManager, environment);</span><br><span class=\"line\">        requestMappingEvent.onRegisterSuccess(apiMappingHandlerMapping);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-meta\">@Override</span></span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configureMessageConverters</span><span class=\"hljs-params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class=\"line\">        converters.clear();</span><br><span class=\"line\">        ObjectMapper objectMapper = <span class=\"hljs-keyword\">new</span> ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class=\"line\">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,<span class=\"hljs-keyword\">false</span>);</span><br><span class=\"line\">        converters.add(<span class=\"hljs-keyword\">new</span> MappingJackson2HttpMessageConverter(objectMapper));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"hljs-meta\">@Override</span></span><br><span class=\"line\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addResourceHandlers</span><span class=\"hljs-params\">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        registry.addResourceHandler(<span class=\"hljs-string\">\"swagger-ui.html\"</span>)</span><br><span class=\"line\">                .addResourceLocations(<span class=\"hljs-string\">\"classpath:/META-INF/resources/\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        registry.addResourceHandler(<span class=\"hljs-string\">\"/webjars/**\"</span>)</span><br><span class=\"line\">                .addResourceLocations(<span class=\"hljs-string\">\"classpath:/META-INF/resources/webjars/\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>springMVC开始加载转换器的时候会先走用户定制化方法</p>\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.messageConverters == <span class=\"hljs-keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">this</span>.messageConverters = <span class=\"hljs-keyword\">new</span> ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;();</span><br><span class=\"line\">\t\tconfigureMessageConverters(<span class=\"hljs-keyword\">this</span>.messageConverters);</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.messageConverters.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\taddDefaultHttpMessageConverters(<span class=\"hljs-keyword\">this</span>.messageConverters);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\textendMessageConverters(<span class=\"hljs-keyword\">this</span>.messageConverters);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.messageConverters;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用户没有定制化，springmvc会使用自定个的7个转换器</p>\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addDefaultHttpMessageConverters</span><span class=\"hljs-params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class=\"line\">\tStringHttpMessageConverter stringConverter = <span class=\"hljs-keyword\">new</span> StringHttpMessageConverter();</span><br><span class=\"line\">\tstringConverter.setWriteAcceptCharset(<span class=\"hljs-keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> ByteArrayHttpMessageConverter());</span><br><span class=\"line\">\tmessageConverters.add(stringConverter);</span><br><span class=\"line\">\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> ResourceHttpMessageConverter());</span><br><span class=\"line\">\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> SourceHttpMessageConverter&lt;Source&gt;());</span><br><span class=\"line\">\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> (romePresent) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> AtomFeedHttpMessageConverter());</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> RssChannelHttpMessageConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> (jackson2XmlPresent) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> MappingJackson2XmlHttpMessageConverter(</span><br><span class=\"line\">\t\t\t\tJackson2ObjectMapperBuilder.xml().applicationContext(<span class=\"hljs-keyword\">this</span>.applicationContext).build()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (jaxb2Present) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> Jaxb2RootElementHttpMessageConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> (jackson2Present) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> MappingJackson2HttpMessageConverter(</span><br><span class=\"line\">\t\t\t\tJackson2ObjectMapperBuilder.json().applicationContext(<span class=\"hljs-keyword\">this</span>.applicationContext).build()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (gsonPresent) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"hljs-keyword\">new</span> GsonHttpMessageConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于项目在自定义的时候没有考虑到文件上传下载这种字节流的解析，导致序列化失败<br>增加配置解决问题</p>\n<figure class=\"highlight java hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class=\"hljs-keyword\">false</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"Java","path":"tags/Java/"},{"name":"Spring Boot","path":"tags/Spring-Boot/"}],"excerpt":"<p>文件上传下载时出现以下错误：</p>\n<img src=\"/2019/09/24/记一次序列化失败导致的生产问题/wenti.png\" width=\"400\" height=\"400\" title=\"错误\">","more":"<p>经过调查,由于重写了WebMvcConfigurationSupport.configureMessageConverters方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OpenServiceConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">WebMvcConfigurationSupport</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationRunner</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Environment environment;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApiMappingHandlerMapping apiMappingHandlerMapping = <span class=\"keyword\">new</span> ApiMappingHandlerMapping();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> RequestMappingHandlerMapping <span class=\"title\">createRequestMappingHandlerMapping</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> apiMappingHandlerMapping;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(ApplicationArguments args)</span> </span>&#123;</span><br><span class=\"line\">        ApiMetaManager apiMetaManager = <span class=\"keyword\">new</span> ServiceZookeeperApiMetaManager(environment);</span><br><span class=\"line\">        RequestMappingEvent requestMappingEvent = <span class=\"keyword\">new</span> DefaultRequestMappingEvent(apiMetaManager, environment);</span><br><span class=\"line\">        requestMappingEvent.onRegisterSuccess(apiMappingHandlerMapping);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configureMessageConverters</span><span class=\"params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class=\"line\">        converters.clear();</span><br><span class=\"line\">        ObjectMapper objectMapper = <span class=\"keyword\">new</span> ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class=\"line\">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        converters.add(<span class=\"keyword\">new</span> MappingJackson2HttpMessageConverter(objectMapper));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">addResourceHandlers</span><span class=\"params\">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        registry.addResourceHandler(<span class=\"string\">\"swagger-ui.html\"</span>)</span><br><span class=\"line\">                .addResourceLocations(<span class=\"string\">\"classpath:/META-INF/resources/\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        registry.addResourceHandler(<span class=\"string\">\"/webjars/**\"</span>)</span><br><span class=\"line\">                .addResourceLocations(<span class=\"string\">\"classpath:/META-INF/resources/webjars/\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>springMVC开始加载转换器的时候会先走用户定制化方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.messageConverters == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.messageConverters = <span class=\"keyword\">new</span> ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;();</span><br><span class=\"line\">\t\tconfigureMessageConverters(<span class=\"keyword\">this</span>.messageConverters);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.messageConverters.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\taddDefaultHttpMessageConverters(<span class=\"keyword\">this</span>.messageConverters);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\textendMessageConverters(<span class=\"keyword\">this</span>.messageConverters);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.messageConverters;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用户没有定制化，springmvc会使用自定个的7个转换器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">addDefaultHttpMessageConverters</span><span class=\"params\">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class=\"line\">\tStringHttpMessageConverter stringConverter = <span class=\"keyword\">new</span> StringHttpMessageConverter();</span><br><span class=\"line\">\tstringConverter.setWriteAcceptCharset(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tmessageConverters.add(<span class=\"keyword\">new</span> ByteArrayHttpMessageConverter());</span><br><span class=\"line\">\tmessageConverters.add(stringConverter);</span><br><span class=\"line\">\tmessageConverters.add(<span class=\"keyword\">new</span> ResourceHttpMessageConverter());</span><br><span class=\"line\">\tmessageConverters.add(<span class=\"keyword\">new</span> SourceHttpMessageConverter&lt;Source&gt;());</span><br><span class=\"line\">\tmessageConverters.add(<span class=\"keyword\">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (romePresent) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"keyword\">new</span> AtomFeedHttpMessageConverter());</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"keyword\">new</span> RssChannelHttpMessageConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (jackson2XmlPresent) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"keyword\">new</span> MappingJackson2XmlHttpMessageConverter(</span><br><span class=\"line\">\t\t\t\tJackson2ObjectMapperBuilder.xml().applicationContext(<span class=\"keyword\">this</span>.applicationContext).build()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (jaxb2Present) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"keyword\">new</span> Jaxb2RootElementHttpMessageConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (jackson2Present) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"keyword\">new</span> MappingJackson2HttpMessageConverter(</span><br><span class=\"line\">\t\t\t\tJackson2ObjectMapperBuilder.json().applicationContext(<span class=\"keyword\">this</span>.applicationContext).build()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (gsonPresent) &#123;</span><br><span class=\"line\">\t\tmessageConverters.add(<span class=\"keyword\">new</span> GsonHttpMessageConverter());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于项目在自定义的时候没有考虑到文件上传下载这种字节流的解析，导致序列化失败<br>增加配置解决问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>"},{"title":"自己动手写Java虚拟机 笔记1","date":"2019-09-09T14:18:50.000Z","_content":"\n## 环境配置\n1. 安装Golang\n   \n{% blockquote %}\nhttps://golang.google.cn/\n{% endblockquote %}\n\n2. 设置Go环境变量\n\n{% asset_img gopath.png GOPATH %}\n\n同时要注意，go的工作目录为该目录，如果需要切换需要改变此路径，不然可使用GoLand等ide切换。\n<!-- more -->\n\n## 简单实现java命令\njava SDK自带很多命令，如java、javac、javap等。\njava命令是其中最终要的一个，平时我们启动一个jar，如springboot工程。还是一个基于tomcat、weblogic、jboss的war包。其根本都是利用java命令执行main方法为入口。\n\n{% codeblock %}\njava [-options] class [args]\njava [-options] -jar jarfile [args]\njavaw [-options] class [args]\njavaw [-options] -jar jarfile [args]\n{% endcodeblock %}\n\n{% blockquote %}\n官方说明：  https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html\n{% endblockquote %}\n\n## 用Go实现java命令的参数读取\n1. java命令入参结构\n\n{% codeblock lang:go %}\ntype Cmd struct {\n\thelpFlag bool //命令为help 或 ? 时：true\n\tversionFlag bool //命令是否为version时：true\n\tcpOption string //命令为cp 或 classpath时，保存值\n\tXjreOption string //命令为Xjre时，保存值\n\tclass string //保存class\n\targs []string //保存其他入参\n}\n{% endcodeblock %}\n\n2. 解析入参\n\n{% codeblock lang:go %}\nfunc parseCmd() *Cmd {\n\tcmd := &Cmd{} //实例化入参对象\n\tflag.Usage = printUsage //设置用法说明\n\tflag.BoolVar(&cmd.helpFlag,\"help\",false,\"print help message\") //参数为help时，&cmd.helpFlag = true\n\tflag.BoolVar(&cmd.helpFlag,\"?\",false,\"print help message\") //参数为?时，&cmd.helpFlag = true\n\tflag.BoolVar(&cmd.versionFlag,\"version\",false,\"print version and exit\") //参数为version时，&cmd.versionFlag = true\n\tflag.StringVar(&cmd.cpOption,\"cp\",\"\",\"classpath\") //参数为version时，&cmd.versionFlag = true\n\tflag.StringVar(&cmd.cpOption,\"classpath\",\"\",\"classpath\")\n\tflag.StringVar(&cmd.XjreOption,\"Xjre\",\"\",\"path to jres\")\n\tflag.Parse()\n\targs := flag.Args()\n\tif len(args) > 0 {\n\t\tcmd.class = args[0]\n\t\tcmd.args = args[1:]\n\t}\n\treturn cmd\n}\n\nfunc printUsage() {\n\tfmt.Printf(\"Usage: %s [-options] class [args...]\\n\",os.Args[0])\n}\n{% endcodeblock %}\n\n3. 启动方法\n\n\n{% codeblock lang:go %}\nfunc main () {\n\tcmd := parseCmd() //解析方法\n\tif cmd.versionFlag {\n\t\tfmt.Println(\"version 0.0.1\") //入参为version时打印版本号\n\t} else if cmd.helpFlag || cmd.class == \"\" {\n\t\tprintUsage() //入参为help或?或classpath、cp为空时打印说明\n\t}else {\n\t\tstartJVM(cmd) //启动JVM\n\t}\n}\n\nfunc startJVM(cmd *Cmd){\n\tfmt.Printf(\"classpath:%s class:%s args:%v\",cmd.cpOption,cmd.class,cmd.args)\n}\n{% endcodeblock %}\n\n4. 试运行\n\n{% codeblock lang:shell %}\nD:\\work\\workspace_go\\src\\jvmgo\\ch01> go install\n\nPS D:\\work\\workspace_go\\bin> .\\ch01.exe -version\nversion 0.0.1\n\nPS D:\\work\\workspace_go\\bin> .\\ch01.exe -help\nUsage: D:\\work\\workspace_go\\bin\\ch01.exe [-options] class [args...]\n\nPS D:\\work\\workspace_go\\bin> .\\ch01.exe -cp test.class a b c\nclasspath:test.class class:a args:[b c]\n{% endcodeblock %}","source":"_posts/自己动手写Java虚拟机-笔记1.md","raw":"---\ntitle: 自己动手写Java虚拟机 笔记1\ndate: 2019-09-09 22:18:50\ntags: \n    - JVM\n    - Java\n    - Go\ncategories :\n    - Technology\n---\n\n## 环境配置\n1. 安装Golang\n   \n{% blockquote %}\nhttps://golang.google.cn/\n{% endblockquote %}\n\n2. 设置Go环境变量\n\n{% asset_img gopath.png GOPATH %}\n\n同时要注意，go的工作目录为该目录，如果需要切换需要改变此路径，不然可使用GoLand等ide切换。\n<!-- more -->\n\n## 简单实现java命令\njava SDK自带很多命令，如java、javac、javap等。\njava命令是其中最终要的一个，平时我们启动一个jar，如springboot工程。还是一个基于tomcat、weblogic、jboss的war包。其根本都是利用java命令执行main方法为入口。\n\n{% codeblock %}\njava [-options] class [args]\njava [-options] -jar jarfile [args]\njavaw [-options] class [args]\njavaw [-options] -jar jarfile [args]\n{% endcodeblock %}\n\n{% blockquote %}\n官方说明：  https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html\n{% endblockquote %}\n\n## 用Go实现java命令的参数读取\n1. java命令入参结构\n\n{% codeblock lang:go %}\ntype Cmd struct {\n\thelpFlag bool //命令为help 或 ? 时：true\n\tversionFlag bool //命令是否为version时：true\n\tcpOption string //命令为cp 或 classpath时，保存值\n\tXjreOption string //命令为Xjre时，保存值\n\tclass string //保存class\n\targs []string //保存其他入参\n}\n{% endcodeblock %}\n\n2. 解析入参\n\n{% codeblock lang:go %}\nfunc parseCmd() *Cmd {\n\tcmd := &Cmd{} //实例化入参对象\n\tflag.Usage = printUsage //设置用法说明\n\tflag.BoolVar(&cmd.helpFlag,\"help\",false,\"print help message\") //参数为help时，&cmd.helpFlag = true\n\tflag.BoolVar(&cmd.helpFlag,\"?\",false,\"print help message\") //参数为?时，&cmd.helpFlag = true\n\tflag.BoolVar(&cmd.versionFlag,\"version\",false,\"print version and exit\") //参数为version时，&cmd.versionFlag = true\n\tflag.StringVar(&cmd.cpOption,\"cp\",\"\",\"classpath\") //参数为version时，&cmd.versionFlag = true\n\tflag.StringVar(&cmd.cpOption,\"classpath\",\"\",\"classpath\")\n\tflag.StringVar(&cmd.XjreOption,\"Xjre\",\"\",\"path to jres\")\n\tflag.Parse()\n\targs := flag.Args()\n\tif len(args) > 0 {\n\t\tcmd.class = args[0]\n\t\tcmd.args = args[1:]\n\t}\n\treturn cmd\n}\n\nfunc printUsage() {\n\tfmt.Printf(\"Usage: %s [-options] class [args...]\\n\",os.Args[0])\n}\n{% endcodeblock %}\n\n3. 启动方法\n\n\n{% codeblock lang:go %}\nfunc main () {\n\tcmd := parseCmd() //解析方法\n\tif cmd.versionFlag {\n\t\tfmt.Println(\"version 0.0.1\") //入参为version时打印版本号\n\t} else if cmd.helpFlag || cmd.class == \"\" {\n\t\tprintUsage() //入参为help或?或classpath、cp为空时打印说明\n\t}else {\n\t\tstartJVM(cmd) //启动JVM\n\t}\n}\n\nfunc startJVM(cmd *Cmd){\n\tfmt.Printf(\"classpath:%s class:%s args:%v\",cmd.cpOption,cmd.class,cmd.args)\n}\n{% endcodeblock %}\n\n4. 试运行\n\n{% codeblock lang:shell %}\nD:\\work\\workspace_go\\src\\jvmgo\\ch01> go install\n\nPS D:\\work\\workspace_go\\bin> .\\ch01.exe -version\nversion 0.0.1\n\nPS D:\\work\\workspace_go\\bin> .\\ch01.exe -help\nUsage: D:\\work\\workspace_go\\bin\\ch01.exe [-options] class [args...]\n\nPS D:\\work\\workspace_go\\bin> .\\ch01.exe -cp test.class a b c\nclasspath:test.class class:a args:[b c]\n{% endcodeblock %}","slug":"自己动手写Java虚拟机-笔记1","published":1,"updated":"2019-09-10T13:44:41.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jeid000lisnymg58a2dr","content":"<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><ol>\n<li>安装Golang</li>\n</ol>\n<blockquote><p><a href=\"https://golang.google.cn/\" target=\"_blank\" rel=\"noopener\">https://golang.google.cn/</a></p>\n</blockquote>\n\n<ol start=\"2\">\n<li>设置Go环境变量</li>\n</ol>\n<img src=\"/2019/09/09/自己动手写Java虚拟机-笔记1/gopath.png\" title=\"GOPATH\">\n\n<p>同时要注意，go的工作目录为该目录，如果需要切换需要改变此路径，不然可使用GoLand等ide切换。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"简单实现java命令\"><a href=\"#简单实现java命令\" class=\"headerlink\" title=\"简单实现java命令\"></a>简单实现java命令</h2><p>java SDK自带很多命令，如java、javac、javap等。<br>java命令是其中最终要的一个，平时我们启动一个jar，如springboot工程。还是一个基于tomcat、weblogic、jboss的war包。其根本都是利用java命令执行main方法为入口。</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java [-options] class [args]</span><br><span class=\"line\">java [-options] -jar jarfile [args]</span><br><span class=\"line\">javaw [-options] class [args]</span><br><span class=\"line\">javaw [-options] -jar jarfile [args]</span><br></pre></td></tr></table></figure>\n\n<blockquote><p>官方说明：  <a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>\n</blockquote>\n\n<h2 id=\"用Go实现java命令的参数读取\"><a href=\"#用Go实现java命令的参数读取\" class=\"headerlink\" title=\"用Go实现java命令的参数读取\"></a>用Go实现java命令的参数读取</h2><ol>\n<li>java命令入参结构</li>\n</ol>\n<figure class=\"highlight go hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> Cmd <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\thelpFlag <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-comment\">//命令为help 或 ? 时：true</span></span><br><span class=\"line\">\tversionFlag <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-comment\">//命令是否为version时：true</span></span><br><span class=\"line\">\tcpOption <span class=\"hljs-keyword\">string</span> <span class=\"hljs-comment\">//命令为cp 或 classpath时，保存值</span></span><br><span class=\"line\">\tXjreOption <span class=\"hljs-keyword\">string</span> <span class=\"hljs-comment\">//命令为Xjre时，保存值</span></span><br><span class=\"line\">\tclass <span class=\"hljs-keyword\">string</span> <span class=\"hljs-comment\">//保存class</span></span><br><span class=\"line\">\targs []<span class=\"hljs-keyword\">string</span> <span class=\"hljs-comment\">//保存其他入参</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>解析入参</li>\n</ol>\n<figure class=\"highlight go hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">parseCmd</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">Cmd</span></span> &#123;</span><br><span class=\"line\">\tcmd := &amp;Cmd&#123;&#125; <span class=\"hljs-comment\">//实例化入参对象</span></span><br><span class=\"line\">\tflag.Usage = printUsage <span class=\"hljs-comment\">//设置用法说明</span></span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"hljs-string\">\"help\"</span>,<span class=\"hljs-literal\">false</span>,<span class=\"hljs-string\">\"print help message\"</span>) <span class=\"hljs-comment\">//参数为help时，&amp;cmd.helpFlag = true</span></span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"hljs-string\">\"?\"</span>,<span class=\"hljs-literal\">false</span>,<span class=\"hljs-string\">\"print help message\"</span>) <span class=\"hljs-comment\">//参数为?时，&amp;cmd.helpFlag = true</span></span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.versionFlag,<span class=\"hljs-string\">\"version\"</span>,<span class=\"hljs-literal\">false</span>,<span class=\"hljs-string\">\"print version and exit\"</span>) <span class=\"hljs-comment\">//参数为version时，&amp;cmd.versionFlag = true</span></span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"hljs-string\">\"cp\"</span>,<span class=\"hljs-string\">\"\"</span>,<span class=\"hljs-string\">\"classpath\"</span>) <span class=\"hljs-comment\">//参数为version时，&amp;cmd.versionFlag = true</span></span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"hljs-string\">\"classpath\"</span>,<span class=\"hljs-string\">\"\"</span>,<span class=\"hljs-string\">\"classpath\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.XjreOption,<span class=\"hljs-string\">\"Xjre\"</span>,<span class=\"hljs-string\">\"\"</span>,<span class=\"hljs-string\">\"path to jres\"</span>)</span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\targs := flag.Args()</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(args) &gt; <span class=\"hljs-number\">0</span> &#123;</span><br><span class=\"line\">\t\tcmd.class = args[<span class=\"hljs-number\">0</span>]</span><br><span class=\"line\">\t\tcmd.args = args[<span class=\"hljs-number\">1</span>:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">printUsage</span><span class=\"hljs-params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"hljs-string\">\"Usage: %s [-options] class [args...]\\n\"</span>,os.Args[<span class=\"hljs-number\">0</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动方法</li>\n</ol>\n<figure class=\"highlight go hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span> <span class=\"hljs-params\">()</span></span> &#123;</span><br><span class=\"line\">\tcmd := parseCmd() <span class=\"hljs-comment\">//解析方法</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> cmd.versionFlag &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"hljs-string\">\"version 0.0.1\"</span>) <span class=\"hljs-comment\">//入参为version时打印版本号</span></span><br><span class=\"line\">\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> cmd.helpFlag || cmd.class == <span class=\"hljs-string\">\"\"</span> &#123;</span><br><span class=\"line\">\t\tprintUsage() <span class=\"hljs-comment\">//入参为help或?或classpath、cp为空时打印说明</span></span><br><span class=\"line\">\t&#125;<span class=\"hljs-keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tstartJVM(cmd) <span class=\"hljs-comment\">//启动JVM</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">startJVM</span><span class=\"hljs-params\">(cmd *Cmd)</span></span>&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"hljs-string\">\"classpath:%s class:%s args:%v\"</span>,cmd.cpOption,cmd.class,cmd.args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>试运行</li>\n</ol>\n<figure class=\"highlight shell hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\work\\workspace_go\\src\\jvmgo\\ch01&gt; go install</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch01.exe -version</span><br><span class=\"line\">version 0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch01.exe -help</span><br><span class=\"line\">Usage: D:\\work\\workspace_go\\bin\\ch01.exe [-options] class [args...]</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch01.exe -cp test.class a b c</span><br><span class=\"line\">classpath:test.class class:a args:[b c]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"JVM","path":"tags/JVM/"},{"name":"Java","path":"tags/Java/"},{"name":"Go","path":"tags/Go/"}],"excerpt":"<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><ol>\n<li>安装Golang</li>\n</ol>\n<blockquote><p><a href=\"https://golang.google.cn/\" target=\"_blank\" rel=\"noopener\">https://golang.google.cn/</a></p>\n</blockquote>\n\n<ol start=\"2\">\n<li>设置Go环境变量</li>\n</ol>\n<img src=\"/2019/09/09/自己动手写Java虚拟机-笔记1/gopath.png\" title=\"GOPATH\">\n\n<p>同时要注意，go的工作目录为该目录，如果需要切换需要改变此路径，不然可使用GoLand等ide切换。</p>","more":"<h2 id=\"简单实现java命令\"><a href=\"#简单实现java命令\" class=\"headerlink\" title=\"简单实现java命令\"></a>简单实现java命令</h2><p>java SDK自带很多命令，如java、javac、javap等。<br>java命令是其中最终要的一个，平时我们启动一个jar，如springboot工程。还是一个基于tomcat、weblogic、jboss的war包。其根本都是利用java命令执行main方法为入口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java [-options] class [args]</span><br><span class=\"line\">java [-options] -jar jarfile [args]</span><br><span class=\"line\">javaw [-options] class [args]</span><br><span class=\"line\">javaw [-options] -jar jarfile [args]</span><br></pre></td></tr></table></figure>\n\n<blockquote><p>官方说明：  <a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>\n</blockquote>\n\n<h2 id=\"用Go实现java命令的参数读取\"><a href=\"#用Go实现java命令的参数读取\" class=\"headerlink\" title=\"用Go实现java命令的参数读取\"></a>用Go实现java命令的参数读取</h2><ol>\n<li>java命令入参结构</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thelpFlag <span class=\"keyword\">bool</span> <span class=\"comment\">//命令为help 或 ? 时：true</span></span><br><span class=\"line\">\tversionFlag <span class=\"keyword\">bool</span> <span class=\"comment\">//命令是否为version时：true</span></span><br><span class=\"line\">\tcpOption <span class=\"keyword\">string</span> <span class=\"comment\">//命令为cp 或 classpath时，保存值</span></span><br><span class=\"line\">\tXjreOption <span class=\"keyword\">string</span> <span class=\"comment\">//命令为Xjre时，保存值</span></span><br><span class=\"line\">\tclass <span class=\"keyword\">string</span> <span class=\"comment\">//保存class</span></span><br><span class=\"line\">\targs []<span class=\"keyword\">string</span> <span class=\"comment\">//保存其他入参</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>解析入参</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parseCmd</span><span class=\"params\">()</span> *<span class=\"title\">Cmd</span></span> &#123;</span><br><span class=\"line\">\tcmd := &amp;Cmd&#123;&#125; <span class=\"comment\">//实例化入参对象</span></span><br><span class=\"line\">\tflag.Usage = printUsage <span class=\"comment\">//设置用法说明</span></span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"string\">\"help\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print help message\"</span>) <span class=\"comment\">//参数为help时，&amp;cmd.helpFlag = true</span></span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.helpFlag,<span class=\"string\">\"?\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print help message\"</span>) <span class=\"comment\">//参数为?时，&amp;cmd.helpFlag = true</span></span><br><span class=\"line\">\tflag.BoolVar(&amp;cmd.versionFlag,<span class=\"string\">\"version\"</span>,<span class=\"literal\">false</span>,<span class=\"string\">\"print version and exit\"</span>) <span class=\"comment\">//参数为version时，&amp;cmd.versionFlag = true</span></span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"cp\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>) <span class=\"comment\">//参数为version时，&amp;cmd.versionFlag = true</span></span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.cpOption,<span class=\"string\">\"classpath\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"classpath\"</span>)</span><br><span class=\"line\">\tflag.StringVar(&amp;cmd.XjreOption,<span class=\"string\">\"Xjre\"</span>,<span class=\"string\">\"\"</span>,<span class=\"string\">\"path to jres\"</span>)</span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\">\targs := flag.Args()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tcmd.class = args[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tcmd.args = args[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cmd</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printUsage</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"Usage: %s [-options] class [args...]\\n\"</span>,os.Args[<span class=\"number\">0</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动方法</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tcmd := parseCmd() <span class=\"comment\">//解析方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cmd.versionFlag &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"version 0.0.1\"</span>) <span class=\"comment\">//入参为version时打印版本号</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> cmd.helpFlag || cmd.class == <span class=\"string\">\"\"</span> &#123;</span><br><span class=\"line\">\t\tprintUsage() <span class=\"comment\">//入参为help或?或classpath、cp为空时打印说明</span></span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tstartJVM(cmd) <span class=\"comment\">//启动JVM</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startJVM</span><span class=\"params\">(cmd *Cmd)</span></span>&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"classpath:%s class:%s args:%v\"</span>,cmd.cpOption,cmd.class,cmd.args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>试运行</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\work\\workspace_go\\src\\jvmgo\\ch01&gt; go install</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch01.exe -version</span><br><span class=\"line\">version 0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch01.exe -help</span><br><span class=\"line\">Usage: D:\\work\\workspace_go\\bin\\ch01.exe [-options] class [args...]</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch01.exe -cp test.class a b c</span><br><span class=\"line\">classpath:test.class class:a args:[b c]</span><br></pre></td></tr></table></figure>"},{"title":"自己动手写Java虚拟机 笔记3","date":"2019-09-13T10:44:38.000Z","_content":"\n第三篇主要学习JVM中class文件的具体结构，和JVM是如何解析这些结构的。\n我们可以通过javac工具将一个java文件compile成一个.class文件，并通过我们自己写的jvm将该文件解析并打印出来。通过class文件的学习能让我们更加深刻的理解java是怎样实现跨平台，并且我们编写的java代码又是如何在JVM中体现的。\n<!-- more -->\n\n### JVM中class文件结构(ClassFile)\nLength|name\n---|---\nu4|magic\nu2|minor_version\nu2|major_version\nu2|constant_pool_count\ncp_info|constant_pool[constant_pool_count-1]\nu2|access_flags\nu2|this_class\nu2|super_class\nu2|interfaces_count\nu2|interfaces[interfaces_count]\nu2|fields_count\nfield_info|fields[fields_count]\nu2|methods_count\nmethod_info|methods[methods_count]\n\n### JVM中字段结构(field_info)\nLength|name\n---|---\nu2|access_flags\nu2|name_index\nu2|descriptor_index\nu2|attributes_count\nattribute_info|attributes[attributes_count]\n\n### JVM中访问控制符结构(access_flags)\n标志名|标志值|标志含义|针对的对象\n---|---|---|---\nACC_PUBLIC|0x0001|public类型|所有类型\nACC_FINAL|0x0010|final类型|类\nACC_SUPER|0x0020|使用新的invokespecial语义|类和接口\nACC_INTERFACE|0x0200|接口类型|接口\nACC_ABSTRACT|0x0400|抽象类型|类和接口\nACC_SYNTHETIC|0x1000|该类不由用户代码生成|所有类型\nACC_ANNOTATION|0x2000|注解类型|注解\nACC_ENUM|0x4000|枚举类型|枚举\n\n### 实现\n1. 定义Class文件的录取类(ClassReader)\n\n{% codeblock lang:golang %}\ntype ClassReader struct {\n\tdata []byte //class文件字节流\n}\n\n// 读取u1\nfunc (self *ClassReader) readUint8() uint8 {\n\tval := self.data[0] //读取1Byte\n\tself.data = self.data[1:]\n\treturn val\n}\n\n// u2\nfunc (self *ClassReader) readUint16() uint16 {\n\tval := binary.BigEndian.Uint16(self.data) //读取2Byte并转为uint16\n\tself.data = self.data[2:]\n\treturn val\n}\n\n// u4\nfunc (self *ClassReader) readUint32() uint32 {\n\tval := binary.BigEndian.Uint32(self.data) //读取4Byte并转为uint32\n\tself.data = self.data[4:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint64() uint64 {\n\tval := binary.BigEndian.Uint64(self.data) //读取8Byte并转为uint64\n\tself.data = self.data[8:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint16s() []uint16 {\n\tn := self.readUint16() //读取2Byte，该值为后续数组的长度\n\ts := make([]uint16, n) //生产长度为n的uint16类型数组\n\tfor i := range s {\n\t\ts[i] = self.readUint16() //读取class文件，每读取2Byte便放入数组\n\t}\n\treturn s\n}\n\nfunc (self *ClassReader) readBytes(n uint32) []byte {\n\tbytes := self.data[:n] //读取长度为n的字节\n\tself.data = self.data[n:]\n\treturn bytes\n}\n{% endcodeblock %}\n\n1. 定义Class文件的格式(ClassFile)\n\n{% codeblock lang:golang %}\ntype ClassFile struct { //按照jvm规范，定义class文件结构\n\t//magic      uint32\n\tminorVersion uint16\n\tmajorVersion uint16\n\tconstantPool ConstantPool\n\taccessFlags  uint16\n\tthisClass    uint16\n\tsuperClass   uint16\n\tinterfaces   []uint16\n\tfields       []*MemberInfo\n\tmethods      []*MemberInfo\n\tattributes   []AttributeInfo\n}\n\n//文件解析入口方法，入参class文件流，返回class文件对象\nfunc Parse(classData []byte) (cf *ClassFile, err error) {\n\tdefer func() { //捕获异常\n\t\tif r := recover(); r != nil {\n\t\t\tvar ok bool\n\t\t\terr, ok = r.(error)\n\t\t\tif !ok {\n\t\t\t\terr = fmt.Errorf(\"%v\", r)\n\t\t\t}\n\t\t}\n\t}()\n\n\tcr := &ClassReader{classData} //实例化classReader类\n\tcf = &ClassFile{} //实例化ClassFile类\n\tcf.read(cr) //读取class文件\n\treturn\n}\n\n//读取class文件的具体方法\nfunc (self *ClassFile) read(reader *ClassReader) {\n\tself.readAndCheckMagic(reader) //读取魔数\n\tself.readAndCheckVersion(reader) //读取主次版本号\n\tself.constantPool = readConstantPool(reader) //读取常量池\n\tself.accessFlags = reader.readUint16() //读取当前类（或者接口）的访问修饰符\n\tself.thisClass = reader.readUint16() //读取当前类索引\n\tself.superClass = reader.readUint16() //读取父类索引\n\tself.interfaces = reader.readUint16s() //读取所有接口索引\n\tself.fields = readMembers(reader, self.constantPool) //从常量池中读取所有成员\n\tself.methods = readMembers(reader, self.constantPool) //从常量池中读取所有方法\n\tself.attributes = readAttributes(reader, self.constantPool) //从常量池中读取所有属性\n}\n\nfunc (self *ClassFile) readAndCheckMagic(reader *ClassReader) {\n\tmagic := reader.readUint32() //读取4Byte魔数\n\tif magic != 0xCAFEBABE { //判断魔数是否为0xCAFEBABE\n\t\tpanic(\"java.lang.ClassFormatError: magic!\")\n\t}\n}\n\nfunc (self *ClassFile) readAndCheckVersion(reader *ClassReader) {\n\tself.minorVersion = reader.readUint16() //高2Byte为次版本号\n\tself.majorVersion = reader.readUint16() //低2Byte为主版本号\n\tswitch self.majorVersion { //检查版本号是否为45~52\n\tcase 45:\n\t\treturn\n\tcase 46, 47, 48, 49, 50, 51, 52:\n\t\tif self.minorVersion == 0 {\n\t\t\treturn\n\t\t}\n\t}\n\n\tpanic(\"java.lang.UnsupportedClassVersionError!\")\n}\n\n//对外暴露get方法\nfunc (self *ClassFile) MinorVersion() uint16 {\n\treturn self.minorVersion\n}\n//对外暴露get方法\nfunc (self *ClassFile) MajorVersion() uint16 {\n\treturn self.majorVersion\n}\n//对外暴露get方法\nfunc (self *ClassFile) ConstantPool() ConstantPool {\n\treturn self.constantPool\n}\n//对外暴露get方法\nfunc (self *ClassFile) AccessFlags() uint16 {\n\treturn self.accessFlags\n}\n//对外暴露get方法\nfunc (self *ClassFile) Fields() []*MemberInfo {\n\treturn self.fields\n}\n//对外暴露get方法\nfunc (self *ClassFile) Methods() []*MemberInfo {\n\treturn self.methods\n}\n//对外暴露get方法，根据thisClass索引在常量池中查找名称\nfunc (self *ClassFile) ClassName() string {\n\treturn self.constantPool.getClassName(self.thisClass)\n}\n//对外暴露get方法，根据superClass索引在常量池中查找名称\nfunc (self *ClassFile) SuperClassName() string {\n\tif self.superClass > 0 {\n\t\treturn self.constantPool.getClassName(self.superClass)\n\t}\n\treturn \"\"\n}\n//对外暴露get方法，根据interfaces索引在常量池中查找名称\nfunc (self *ClassFile) InterfaceNames() []string {\n\tinterfaceNames := make([]string, len(self.interfaces))\n\tfor i, cpIndex := range self.interfaces {\n\t\tinterfaceNames[i] = self.constantPool.getClassName(cpIndex)\n\t}\n\treturn interfaceNames\n}\n{% endcodeblock %}\n\n1. 定义字段和方法的结构(field_info、method_info)\n\n{% codeblock lang:golang %}\ntype MemberInfo struct { //field和method的结构类型，使用同一个结构\n\tcp              ConstantPool //当前常量池\n\taccessFlags     uint16 //访问标志\n\tnameIndex       uint16 //名称索引\n\tdescriptorIndex uint16 //描述索引\n\tattributes      []AttributeInfo //属性列表 \n}\n\n// read field or method table\nfunc readMembers(reader *ClassReader, cp ConstantPool) []*MemberInfo {\n\tmemberCount := reader.readUint16() //读取field或method数量\n\tmembers := make([]*MemberInfo, memberCount) //创建数组\n\tfor i := range members {\n\t\tmembers[i] = readMember(reader, cp)\n\t}\n\treturn members\n}\n\n//具体读取field和method的方法\nfunc readMember(reader *ClassReader, cp ConstantPool) *MemberInfo {\n\treturn &MemberInfo{\n\t\tcp:              cp,\n\t\taccessFlags:     reader.readUint16(), //读取2Byte的访问控制符\n\t\tnameIndex:       reader.readUint16(), //读取2Byte的名称索引\n\t\tdescriptorIndex: reader.readUint16(), //读取2Byte的描述索引\n\t\tattributes:      readAttributes(reader, cp), //读取属性列表\n\t}\n}\n\n//对外暴露get方法\nfunc (self *MemberInfo) AccessFlags() uint16 {\n\treturn self.accessFlags\n}\n//对外暴露get方法，通过名称索引访问常量池\nfunc (self *MemberInfo) Name() string {\n\treturn self.cp.getUtf8(self.nameIndex)\n}\n//对外暴露get方法，通过描述索引访问常量池\nfunc (self *MemberInfo) Descriptor() string {\n\treturn self.cp.getUtf8(self.descriptorIndex)\n}\n\n{% endcodeblock %}","source":"_posts/自己动手写Java虚拟机-笔记3.md","raw":"---\ntitle: 自己动手写Java虚拟机 笔记3\ndate: 2019-09-13 18:44:38\ntags: \n    - JVM\n    - Java\n    - Go\ncategories :\n    - Technology\n---\n\n第三篇主要学习JVM中class文件的具体结构，和JVM是如何解析这些结构的。\n我们可以通过javac工具将一个java文件compile成一个.class文件，并通过我们自己写的jvm将该文件解析并打印出来。通过class文件的学习能让我们更加深刻的理解java是怎样实现跨平台，并且我们编写的java代码又是如何在JVM中体现的。\n<!-- more -->\n\n### JVM中class文件结构(ClassFile)\nLength|name\n---|---\nu4|magic\nu2|minor_version\nu2|major_version\nu2|constant_pool_count\ncp_info|constant_pool[constant_pool_count-1]\nu2|access_flags\nu2|this_class\nu2|super_class\nu2|interfaces_count\nu2|interfaces[interfaces_count]\nu2|fields_count\nfield_info|fields[fields_count]\nu2|methods_count\nmethod_info|methods[methods_count]\n\n### JVM中字段结构(field_info)\nLength|name\n---|---\nu2|access_flags\nu2|name_index\nu2|descriptor_index\nu2|attributes_count\nattribute_info|attributes[attributes_count]\n\n### JVM中访问控制符结构(access_flags)\n标志名|标志值|标志含义|针对的对象\n---|---|---|---\nACC_PUBLIC|0x0001|public类型|所有类型\nACC_FINAL|0x0010|final类型|类\nACC_SUPER|0x0020|使用新的invokespecial语义|类和接口\nACC_INTERFACE|0x0200|接口类型|接口\nACC_ABSTRACT|0x0400|抽象类型|类和接口\nACC_SYNTHETIC|0x1000|该类不由用户代码生成|所有类型\nACC_ANNOTATION|0x2000|注解类型|注解\nACC_ENUM|0x4000|枚举类型|枚举\n\n### 实现\n1. 定义Class文件的录取类(ClassReader)\n\n{% codeblock lang:golang %}\ntype ClassReader struct {\n\tdata []byte //class文件字节流\n}\n\n// 读取u1\nfunc (self *ClassReader) readUint8() uint8 {\n\tval := self.data[0] //读取1Byte\n\tself.data = self.data[1:]\n\treturn val\n}\n\n// u2\nfunc (self *ClassReader) readUint16() uint16 {\n\tval := binary.BigEndian.Uint16(self.data) //读取2Byte并转为uint16\n\tself.data = self.data[2:]\n\treturn val\n}\n\n// u4\nfunc (self *ClassReader) readUint32() uint32 {\n\tval := binary.BigEndian.Uint32(self.data) //读取4Byte并转为uint32\n\tself.data = self.data[4:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint64() uint64 {\n\tval := binary.BigEndian.Uint64(self.data) //读取8Byte并转为uint64\n\tself.data = self.data[8:]\n\treturn val\n}\n\nfunc (self *ClassReader) readUint16s() []uint16 {\n\tn := self.readUint16() //读取2Byte，该值为后续数组的长度\n\ts := make([]uint16, n) //生产长度为n的uint16类型数组\n\tfor i := range s {\n\t\ts[i] = self.readUint16() //读取class文件，每读取2Byte便放入数组\n\t}\n\treturn s\n}\n\nfunc (self *ClassReader) readBytes(n uint32) []byte {\n\tbytes := self.data[:n] //读取长度为n的字节\n\tself.data = self.data[n:]\n\treturn bytes\n}\n{% endcodeblock %}\n\n1. 定义Class文件的格式(ClassFile)\n\n{% codeblock lang:golang %}\ntype ClassFile struct { //按照jvm规范，定义class文件结构\n\t//magic      uint32\n\tminorVersion uint16\n\tmajorVersion uint16\n\tconstantPool ConstantPool\n\taccessFlags  uint16\n\tthisClass    uint16\n\tsuperClass   uint16\n\tinterfaces   []uint16\n\tfields       []*MemberInfo\n\tmethods      []*MemberInfo\n\tattributes   []AttributeInfo\n}\n\n//文件解析入口方法，入参class文件流，返回class文件对象\nfunc Parse(classData []byte) (cf *ClassFile, err error) {\n\tdefer func() { //捕获异常\n\t\tif r := recover(); r != nil {\n\t\t\tvar ok bool\n\t\t\terr, ok = r.(error)\n\t\t\tif !ok {\n\t\t\t\terr = fmt.Errorf(\"%v\", r)\n\t\t\t}\n\t\t}\n\t}()\n\n\tcr := &ClassReader{classData} //实例化classReader类\n\tcf = &ClassFile{} //实例化ClassFile类\n\tcf.read(cr) //读取class文件\n\treturn\n}\n\n//读取class文件的具体方法\nfunc (self *ClassFile) read(reader *ClassReader) {\n\tself.readAndCheckMagic(reader) //读取魔数\n\tself.readAndCheckVersion(reader) //读取主次版本号\n\tself.constantPool = readConstantPool(reader) //读取常量池\n\tself.accessFlags = reader.readUint16() //读取当前类（或者接口）的访问修饰符\n\tself.thisClass = reader.readUint16() //读取当前类索引\n\tself.superClass = reader.readUint16() //读取父类索引\n\tself.interfaces = reader.readUint16s() //读取所有接口索引\n\tself.fields = readMembers(reader, self.constantPool) //从常量池中读取所有成员\n\tself.methods = readMembers(reader, self.constantPool) //从常量池中读取所有方法\n\tself.attributes = readAttributes(reader, self.constantPool) //从常量池中读取所有属性\n}\n\nfunc (self *ClassFile) readAndCheckMagic(reader *ClassReader) {\n\tmagic := reader.readUint32() //读取4Byte魔数\n\tif magic != 0xCAFEBABE { //判断魔数是否为0xCAFEBABE\n\t\tpanic(\"java.lang.ClassFormatError: magic!\")\n\t}\n}\n\nfunc (self *ClassFile) readAndCheckVersion(reader *ClassReader) {\n\tself.minorVersion = reader.readUint16() //高2Byte为次版本号\n\tself.majorVersion = reader.readUint16() //低2Byte为主版本号\n\tswitch self.majorVersion { //检查版本号是否为45~52\n\tcase 45:\n\t\treturn\n\tcase 46, 47, 48, 49, 50, 51, 52:\n\t\tif self.minorVersion == 0 {\n\t\t\treturn\n\t\t}\n\t}\n\n\tpanic(\"java.lang.UnsupportedClassVersionError!\")\n}\n\n//对外暴露get方法\nfunc (self *ClassFile) MinorVersion() uint16 {\n\treturn self.minorVersion\n}\n//对外暴露get方法\nfunc (self *ClassFile) MajorVersion() uint16 {\n\treturn self.majorVersion\n}\n//对外暴露get方法\nfunc (self *ClassFile) ConstantPool() ConstantPool {\n\treturn self.constantPool\n}\n//对外暴露get方法\nfunc (self *ClassFile) AccessFlags() uint16 {\n\treturn self.accessFlags\n}\n//对外暴露get方法\nfunc (self *ClassFile) Fields() []*MemberInfo {\n\treturn self.fields\n}\n//对外暴露get方法\nfunc (self *ClassFile) Methods() []*MemberInfo {\n\treturn self.methods\n}\n//对外暴露get方法，根据thisClass索引在常量池中查找名称\nfunc (self *ClassFile) ClassName() string {\n\treturn self.constantPool.getClassName(self.thisClass)\n}\n//对外暴露get方法，根据superClass索引在常量池中查找名称\nfunc (self *ClassFile) SuperClassName() string {\n\tif self.superClass > 0 {\n\t\treturn self.constantPool.getClassName(self.superClass)\n\t}\n\treturn \"\"\n}\n//对外暴露get方法，根据interfaces索引在常量池中查找名称\nfunc (self *ClassFile) InterfaceNames() []string {\n\tinterfaceNames := make([]string, len(self.interfaces))\n\tfor i, cpIndex := range self.interfaces {\n\t\tinterfaceNames[i] = self.constantPool.getClassName(cpIndex)\n\t}\n\treturn interfaceNames\n}\n{% endcodeblock %}\n\n1. 定义字段和方法的结构(field_info、method_info)\n\n{% codeblock lang:golang %}\ntype MemberInfo struct { //field和method的结构类型，使用同一个结构\n\tcp              ConstantPool //当前常量池\n\taccessFlags     uint16 //访问标志\n\tnameIndex       uint16 //名称索引\n\tdescriptorIndex uint16 //描述索引\n\tattributes      []AttributeInfo //属性列表 \n}\n\n// read field or method table\nfunc readMembers(reader *ClassReader, cp ConstantPool) []*MemberInfo {\n\tmemberCount := reader.readUint16() //读取field或method数量\n\tmembers := make([]*MemberInfo, memberCount) //创建数组\n\tfor i := range members {\n\t\tmembers[i] = readMember(reader, cp)\n\t}\n\treturn members\n}\n\n//具体读取field和method的方法\nfunc readMember(reader *ClassReader, cp ConstantPool) *MemberInfo {\n\treturn &MemberInfo{\n\t\tcp:              cp,\n\t\taccessFlags:     reader.readUint16(), //读取2Byte的访问控制符\n\t\tnameIndex:       reader.readUint16(), //读取2Byte的名称索引\n\t\tdescriptorIndex: reader.readUint16(), //读取2Byte的描述索引\n\t\tattributes:      readAttributes(reader, cp), //读取属性列表\n\t}\n}\n\n//对外暴露get方法\nfunc (self *MemberInfo) AccessFlags() uint16 {\n\treturn self.accessFlags\n}\n//对外暴露get方法，通过名称索引访问常量池\nfunc (self *MemberInfo) Name() string {\n\treturn self.cp.getUtf8(self.nameIndex)\n}\n//对外暴露get方法，通过描述索引访问常量池\nfunc (self *MemberInfo) Descriptor() string {\n\treturn self.cp.getUtf8(self.descriptorIndex)\n}\n\n{% endcodeblock %}","slug":"自己动手写Java虚拟机-笔记3","published":1,"updated":"2019-09-15T13:50:28.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jeie000qisny2cn2a0sv","content":"<p>第三篇主要学习JVM中class文件的具体结构，和JVM是如何解析这些结构的。<br>我们可以通过javac工具将一个java文件compile成一个.class文件，并通过我们自己写的jvm将该文件解析并打印出来。通过class文件的学习能让我们更加深刻的理解java是怎样实现跨平台，并且我们编写的java代码又是如何在JVM中体现的。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"JVM中class文件结构-ClassFile\"><a href=\"#JVM中class文件结构-ClassFile\" class=\"headerlink\" title=\"JVM中class文件结构(ClassFile)\"></a>JVM中class文件结构(ClassFile)</h3><table>\n<thead>\n<tr>\n<th>Length</th>\n<th>name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u4</td>\n<td>magic</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>minor_version</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>major_version</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>constant_pool_count</td>\n</tr>\n<tr>\n<td>cp_info</td>\n<td>constant_pool[constant_pool_count-1]</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>access_flags</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>this_class</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>super_class</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>interfaces_count</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>interfaces[interfaces_count]</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>fields_count</td>\n</tr>\n<tr>\n<td>field_info</td>\n<td>fields[fields_count]</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>methods_count</td>\n</tr>\n<tr>\n<td>method_info</td>\n<td>methods[methods_count]</td>\n</tr>\n</tbody></table>\n<h3 id=\"JVM中字段结构-field-info\"><a href=\"#JVM中字段结构-field-info\" class=\"headerlink\" title=\"JVM中字段结构(field_info)\"></a>JVM中字段结构(field_info)</h3><table>\n<thead>\n<tr>\n<th>Length</th>\n<th>name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u2</td>\n<td>access_flags</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>name_index</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>descriptor_index</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>attributes_count</td>\n</tr>\n<tr>\n<td>attribute_info</td>\n<td>attributes[attributes_count]</td>\n</tr>\n</tbody></table>\n<h3 id=\"JVM中访问控制符结构-access-flags\"><a href=\"#JVM中访问控制符结构-access-flags\" class=\"headerlink\" title=\"JVM中访问控制符结构(access_flags)\"></a>JVM中访问控制符结构(access_flags)</h3><table>\n<thead>\n<tr>\n<th>标志名</th>\n<th>标志值</th>\n<th>标志含义</th>\n<th>针对的对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ACC_PUBLIC</td>\n<td>0x0001</td>\n<td>public类型</td>\n<td>所有类型</td>\n</tr>\n<tr>\n<td>ACC_FINAL</td>\n<td>0x0010</td>\n<td>final类型</td>\n<td>类</td>\n</tr>\n<tr>\n<td>ACC_SUPER</td>\n<td>0x0020</td>\n<td>使用新的invokespecial语义</td>\n<td>类和接口</td>\n</tr>\n<tr>\n<td>ACC_INTERFACE</td>\n<td>0x0200</td>\n<td>接口类型</td>\n<td>接口</td>\n</tr>\n<tr>\n<td>ACC_ABSTRACT</td>\n<td>0x0400</td>\n<td>抽象类型</td>\n<td>类和接口</td>\n</tr>\n<tr>\n<td>ACC_SYNTHETIC</td>\n<td>0x1000</td>\n<td>该类不由用户代码生成</td>\n<td>所有类型</td>\n</tr>\n<tr>\n<td>ACC_ANNOTATION</td>\n<td>0x2000</td>\n<td>注解类型</td>\n<td>注解</td>\n</tr>\n<tr>\n<td>ACC_ENUM</td>\n<td>0x4000</td>\n<td>枚举类型</td>\n<td>枚举</td>\n</tr>\n</tbody></table>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li>定义Class文件的录取类(ClassReader)</li>\n</ol>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> ClassReader <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\tdata []<span class=\"hljs-keyword\">byte</span> <span class=\"hljs-comment\">//class文件字节流</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// 读取u1</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassReader)</span> <span class=\"hljs-title\">readUint8</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint8</span></span> &#123;</span><br><span class=\"line\">\tval := self.data[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">//读取1Byte</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"hljs-number\">1</span>:]</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// u2</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassReader)</span> <span class=\"hljs-title\">readUint16</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint16</span></span> &#123;</span><br><span class=\"line\">\tval := binary.BigEndian.Uint16(self.data) <span class=\"hljs-comment\">//读取2Byte并转为uint16</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"hljs-number\">2</span>:]</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// u4</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassReader)</span> <span class=\"hljs-title\">readUint32</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint32</span></span> &#123;</span><br><span class=\"line\">\tval := binary.BigEndian.Uint32(self.data) <span class=\"hljs-comment\">//读取4Byte并转为uint32</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"hljs-number\">4</span>:]</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassReader)</span> <span class=\"hljs-title\">readUint64</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint64</span></span> &#123;</span><br><span class=\"line\">\tval := binary.BigEndian.Uint64(self.data) <span class=\"hljs-comment\">//读取8Byte并转为uint64</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"hljs-number\">8</span>:]</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassReader)</span> <span class=\"hljs-title\">readUint16s</span><span class=\"hljs-params\">()</span> []<span class=\"hljs-title\">uint16</span></span> &#123;</span><br><span class=\"line\">\tn := self.readUint16() <span class=\"hljs-comment\">//读取2Byte，该值为后续数组的长度</span></span><br><span class=\"line\">\ts := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">uint16</span>, n) <span class=\"hljs-comment\">//生产长度为n的uint16类型数组</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\ts[i] = self.readUint16() <span class=\"hljs-comment\">//读取class文件，每读取2Byte便放入数组</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassReader)</span> <span class=\"hljs-title\">readBytes</span><span class=\"hljs-params\">(n <span class=\"hljs-keyword\">uint32</span>)</span> []<span class=\"hljs-title\">byte</span></span> &#123;</span><br><span class=\"line\">\tbytes := self.data[:n] <span class=\"hljs-comment\">//读取长度为n的字节</span></span><br><span class=\"line\">\tself.data = self.data[n:]</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> bytes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>定义Class文件的格式(ClassFile)</li>\n</ol>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> ClassFile <span class=\"hljs-keyword\">struct</span> &#123; <span class=\"hljs-comment\">//按照jvm规范，定义class文件结构</span></span><br><span class=\"line\">\t<span class=\"hljs-comment\">//magic      uint32</span></span><br><span class=\"line\">\tminorVersion <span class=\"hljs-keyword\">uint16</span></span><br><span class=\"line\">\tmajorVersion <span class=\"hljs-keyword\">uint16</span></span><br><span class=\"line\">\tconstantPool ConstantPool</span><br><span class=\"line\">\taccessFlags  <span class=\"hljs-keyword\">uint16</span></span><br><span class=\"line\">\tthisClass    <span class=\"hljs-keyword\">uint16</span></span><br><span class=\"line\">\tsuperClass   <span class=\"hljs-keyword\">uint16</span></span><br><span class=\"line\">\tinterfaces   []<span class=\"hljs-keyword\">uint16</span></span><br><span class=\"line\">\tfields       []*MemberInfo</span><br><span class=\"line\">\tmethods      []*MemberInfo</span><br><span class=\"line\">\tattributes   []AttributeInfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//文件解析入口方法，入参class文件流，返回class文件对象</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Parse</span><span class=\"hljs-params\">(classData []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(cf *ClassFile, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> &#123; <span class=\"hljs-comment\">//捕获异常</span></span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span> r := <span class=\"hljs-built_in\">recover</span>(); r != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">var</span> ok <span class=\"hljs-keyword\">bool</span></span><br><span class=\"line\">\t\t\terr, ok = r.(error)</span><br><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\terr = fmt.Errorf(<span class=\"hljs-string\">\"%v\"</span>, r)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcr := &amp;ClassReader&#123;classData&#125; <span class=\"hljs-comment\">//实例化classReader类</span></span><br><span class=\"line\">\tcf = &amp;ClassFile&#123;&#125; <span class=\"hljs-comment\">//实例化ClassFile类</span></span><br><span class=\"line\">\tcf.read(cr) <span class=\"hljs-comment\">//读取class文件</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//读取class文件的具体方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">read</span><span class=\"hljs-params\">(reader *ClassReader)</span></span> &#123;</span><br><span class=\"line\">\tself.readAndCheckMagic(reader) <span class=\"hljs-comment\">//读取魔数</span></span><br><span class=\"line\">\tself.readAndCheckVersion(reader) <span class=\"hljs-comment\">//读取主次版本号</span></span><br><span class=\"line\">\tself.constantPool = readConstantPool(reader) <span class=\"hljs-comment\">//读取常量池</span></span><br><span class=\"line\">\tself.accessFlags = reader.readUint16() <span class=\"hljs-comment\">//读取当前类（或者接口）的访问修饰符</span></span><br><span class=\"line\">\tself.thisClass = reader.readUint16() <span class=\"hljs-comment\">//读取当前类索引</span></span><br><span class=\"line\">\tself.superClass = reader.readUint16() <span class=\"hljs-comment\">//读取父类索引</span></span><br><span class=\"line\">\tself.interfaces = reader.readUint16s() <span class=\"hljs-comment\">//读取所有接口索引</span></span><br><span class=\"line\">\tself.fields = readMembers(reader, self.constantPool) <span class=\"hljs-comment\">//从常量池中读取所有成员</span></span><br><span class=\"line\">\tself.methods = readMembers(reader, self.constantPool) <span class=\"hljs-comment\">//从常量池中读取所有方法</span></span><br><span class=\"line\">\tself.attributes = readAttributes(reader, self.constantPool) <span class=\"hljs-comment\">//从常量池中读取所有属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">readAndCheckMagic</span><span class=\"hljs-params\">(reader *ClassReader)</span></span> &#123;</span><br><span class=\"line\">\tmagic := reader.readUint32() <span class=\"hljs-comment\">//读取4Byte魔数</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> magic != <span class=\"hljs-number\">0xCAFEBABE</span> &#123; <span class=\"hljs-comment\">//判断魔数是否为0xCAFEBABE</span></span><br><span class=\"line\">\t\t<span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-string\">\"java.lang.ClassFormatError: magic!\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">readAndCheckVersion</span><span class=\"hljs-params\">(reader *ClassReader)</span></span> &#123;</span><br><span class=\"line\">\tself.minorVersion = reader.readUint16() <span class=\"hljs-comment\">//高2Byte为次版本号</span></span><br><span class=\"line\">\tself.majorVersion = reader.readUint16() <span class=\"hljs-comment\">//低2Byte为主版本号</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">switch</span> self.majorVersion &#123; <span class=\"hljs-comment\">//检查版本号是否为45~52</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">45</span>:</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">46</span>, <span class=\"hljs-number\">47</span>, <span class=\"hljs-number\">48</span>, <span class=\"hljs-number\">49</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">51</span>, <span class=\"hljs-number\">52</span>:</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span> self.minorVersion == <span class=\"hljs-number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-string\">\"java.lang.UnsupportedClassVersionError!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">MinorVersion</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.minorVersion</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">MajorVersion</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.majorVersion</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">ConstantPool</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">ConstantPool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.constantPool</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">AccessFlags</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.accessFlags</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">Fields</span><span class=\"hljs-params\">()</span> []*<span class=\"hljs-title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.fields</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">Methods</span><span class=\"hljs-params\">()</span> []*<span class=\"hljs-title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.methods</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法，根据thisClass索引在常量池中查找名称</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">ClassName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.constantPool.getClassName(self.thisClass)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法，根据superClass索引在常量池中查找名称</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">SuperClassName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> self.superClass &gt; <span class=\"hljs-number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span> self.constantPool.getClassName(self.superClass)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法，根据interfaces索引在常量池中查找名称</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ClassFile)</span> <span class=\"hljs-title\">InterfaceNames</span><span class=\"hljs-params\">()</span> []<span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\tinterfaceNames := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-built_in\">len</span>(self.interfaces))</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">for</span> i, cpIndex := <span class=\"hljs-keyword\">range</span> self.interfaces &#123;</span><br><span class=\"line\">\t\tinterfaceNames[i] = self.constantPool.getClassName(cpIndex)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> interfaceNames</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>定义字段和方法的结构(field_info、method_info)</li>\n</ol>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> MemberInfo <span class=\"hljs-keyword\">struct</span> &#123; <span class=\"hljs-comment\">//field和method的结构类型，使用同一个结构</span></span><br><span class=\"line\">\tcp              ConstantPool <span class=\"hljs-comment\">//当前常量池</span></span><br><span class=\"line\">\taccessFlags     <span class=\"hljs-keyword\">uint16</span> <span class=\"hljs-comment\">//访问标志</span></span><br><span class=\"line\">\tnameIndex       <span class=\"hljs-keyword\">uint16</span> <span class=\"hljs-comment\">//名称索引</span></span><br><span class=\"line\">\tdescriptorIndex <span class=\"hljs-keyword\">uint16</span> <span class=\"hljs-comment\">//描述索引</span></span><br><span class=\"line\">\tattributes      []AttributeInfo <span class=\"hljs-comment\">//属性列表 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// read field or method table</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">readMembers</span><span class=\"hljs-params\">(reader *ClassReader, cp ConstantPool)</span> []*<span class=\"hljs-title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\tmemberCount := reader.readUint16() <span class=\"hljs-comment\">//读取field或method数量</span></span><br><span class=\"line\">\tmembers := <span class=\"hljs-built_in\">make</span>([]*MemberInfo, memberCount) <span class=\"hljs-comment\">//创建数组</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> members &#123;</span><br><span class=\"line\">\t\tmembers[i] = readMember(reader, cp)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> members</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//具体读取field和method的方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">readMember</span><span class=\"hljs-params\">(reader *ClassReader, cp ConstantPool)</span> *<span class=\"hljs-title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> &amp;MemberInfo&#123;</span><br><span class=\"line\">\t\tcp:              cp,</span><br><span class=\"line\">\t\taccessFlags:     reader.readUint16(), <span class=\"hljs-comment\">//读取2Byte的访问控制符</span></span><br><span class=\"line\">\t\tnameIndex:       reader.readUint16(), <span class=\"hljs-comment\">//读取2Byte的名称索引</span></span><br><span class=\"line\">\t\tdescriptorIndex: reader.readUint16(), <span class=\"hljs-comment\">//读取2Byte的描述索引</span></span><br><span class=\"line\">\t\tattributes:      readAttributes(reader, cp), <span class=\"hljs-comment\">//读取属性列表</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *MemberInfo)</span> <span class=\"hljs-title\">AccessFlags</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.accessFlags</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法，通过名称索引访问常量池</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *MemberInfo)</span> <span class=\"hljs-title\">Name</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.cp.getUtf8(self.nameIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//对外暴露get方法，通过描述索引访问常量池</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *MemberInfo)</span> <span class=\"hljs-title\">Descriptor</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.cp.getUtf8(self.descriptorIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"JVM","path":"tags/JVM/"},{"name":"Java","path":"tags/Java/"},{"name":"Go","path":"tags/Go/"}],"excerpt":"<p>第三篇主要学习JVM中class文件的具体结构，和JVM是如何解析这些结构的。<br>我们可以通过javac工具将一个java文件compile成一个.class文件，并通过我们自己写的jvm将该文件解析并打印出来。通过class文件的学习能让我们更加深刻的理解java是怎样实现跨平台，并且我们编写的java代码又是如何在JVM中体现的。</p>","more":"<h3 id=\"JVM中class文件结构-ClassFile\"><a href=\"#JVM中class文件结构-ClassFile\" class=\"headerlink\" title=\"JVM中class文件结构(ClassFile)\"></a>JVM中class文件结构(ClassFile)</h3><table>\n<thead>\n<tr>\n<th>Length</th>\n<th>name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u4</td>\n<td>magic</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>minor_version</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>major_version</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>constant_pool_count</td>\n</tr>\n<tr>\n<td>cp_info</td>\n<td>constant_pool[constant_pool_count-1]</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>access_flags</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>this_class</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>super_class</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>interfaces_count</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>interfaces[interfaces_count]</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>fields_count</td>\n</tr>\n<tr>\n<td>field_info</td>\n<td>fields[fields_count]</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>methods_count</td>\n</tr>\n<tr>\n<td>method_info</td>\n<td>methods[methods_count]</td>\n</tr>\n</tbody></table>\n<h3 id=\"JVM中字段结构-field-info\"><a href=\"#JVM中字段结构-field-info\" class=\"headerlink\" title=\"JVM中字段结构(field_info)\"></a>JVM中字段结构(field_info)</h3><table>\n<thead>\n<tr>\n<th>Length</th>\n<th>name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>u2</td>\n<td>access_flags</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>name_index</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>descriptor_index</td>\n</tr>\n<tr>\n<td>u2</td>\n<td>attributes_count</td>\n</tr>\n<tr>\n<td>attribute_info</td>\n<td>attributes[attributes_count]</td>\n</tr>\n</tbody></table>\n<h3 id=\"JVM中访问控制符结构-access-flags\"><a href=\"#JVM中访问控制符结构-access-flags\" class=\"headerlink\" title=\"JVM中访问控制符结构(access_flags)\"></a>JVM中访问控制符结构(access_flags)</h3><table>\n<thead>\n<tr>\n<th>标志名</th>\n<th>标志值</th>\n<th>标志含义</th>\n<th>针对的对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ACC_PUBLIC</td>\n<td>0x0001</td>\n<td>public类型</td>\n<td>所有类型</td>\n</tr>\n<tr>\n<td>ACC_FINAL</td>\n<td>0x0010</td>\n<td>final类型</td>\n<td>类</td>\n</tr>\n<tr>\n<td>ACC_SUPER</td>\n<td>0x0020</td>\n<td>使用新的invokespecial语义</td>\n<td>类和接口</td>\n</tr>\n<tr>\n<td>ACC_INTERFACE</td>\n<td>0x0200</td>\n<td>接口类型</td>\n<td>接口</td>\n</tr>\n<tr>\n<td>ACC_ABSTRACT</td>\n<td>0x0400</td>\n<td>抽象类型</td>\n<td>类和接口</td>\n</tr>\n<tr>\n<td>ACC_SYNTHETIC</td>\n<td>0x1000</td>\n<td>该类不由用户代码生成</td>\n<td>所有类型</td>\n</tr>\n<tr>\n<td>ACC_ANNOTATION</td>\n<td>0x2000</td>\n<td>注解类型</td>\n<td>注解</td>\n</tr>\n<tr>\n<td>ACC_ENUM</td>\n<td>0x4000</td>\n<td>枚举类型</td>\n<td>枚举</td>\n</tr>\n</tbody></table>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li>定义Class文件的录取类(ClassReader)</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ClassReader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tdata []<span class=\"keyword\">byte</span> <span class=\"comment\">//class文件字节流</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取u1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassReader)</span> <span class=\"title\">readUint8</span><span class=\"params\">()</span> <span class=\"title\">uint8</span></span> &#123;</span><br><span class=\"line\">\tval := self.data[<span class=\"number\">0</span>] <span class=\"comment\">//读取1Byte</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassReader)</span> <span class=\"title\">readUint16</span><span class=\"params\">()</span> <span class=\"title\">uint16</span></span> &#123;</span><br><span class=\"line\">\tval := binary.BigEndian.Uint16(self.data) <span class=\"comment\">//读取2Byte并转为uint16</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"number\">2</span>:]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// u4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassReader)</span> <span class=\"title\">readUint32</span><span class=\"params\">()</span> <span class=\"title\">uint32</span></span> &#123;</span><br><span class=\"line\">\tval := binary.BigEndian.Uint32(self.data) <span class=\"comment\">//读取4Byte并转为uint32</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"number\">4</span>:]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassReader)</span> <span class=\"title\">readUint64</span><span class=\"params\">()</span> <span class=\"title\">uint64</span></span> &#123;</span><br><span class=\"line\">\tval := binary.BigEndian.Uint64(self.data) <span class=\"comment\">//读取8Byte并转为uint64</span></span><br><span class=\"line\">\tself.data = self.data[<span class=\"number\">8</span>:]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassReader)</span> <span class=\"title\">readUint16s</span><span class=\"params\">()</span> []<span class=\"title\">uint16</span></span> &#123;</span><br><span class=\"line\">\tn := self.readUint16() <span class=\"comment\">//读取2Byte，该值为后续数组的长度</span></span><br><span class=\"line\">\ts := <span class=\"built_in\">make</span>([]<span class=\"keyword\">uint16</span>, n) <span class=\"comment\">//生产长度为n的uint16类型数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\ts[i] = self.readUint16() <span class=\"comment\">//读取class文件，每读取2Byte便放入数组</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassReader)</span> <span class=\"title\">readBytes</span><span class=\"params\">(n <span class=\"keyword\">uint32</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">\tbytes := self.data[:n] <span class=\"comment\">//读取长度为n的字节</span></span><br><span class=\"line\">\tself.data = self.data[n:]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bytes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>定义Class文件的格式(ClassFile)</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ClassFile <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">//按照jvm规范，定义class文件结构</span></span><br><span class=\"line\">\t<span class=\"comment\">//magic      uint32</span></span><br><span class=\"line\">\tminorVersion <span class=\"keyword\">uint16</span></span><br><span class=\"line\">\tmajorVersion <span class=\"keyword\">uint16</span></span><br><span class=\"line\">\tconstantPool ConstantPool</span><br><span class=\"line\">\taccessFlags  <span class=\"keyword\">uint16</span></span><br><span class=\"line\">\tthisClass    <span class=\"keyword\">uint16</span></span><br><span class=\"line\">\tsuperClass   <span class=\"keyword\">uint16</span></span><br><span class=\"line\">\tinterfaces   []<span class=\"keyword\">uint16</span></span><br><span class=\"line\">\tfields       []*MemberInfo</span><br><span class=\"line\">\tmethods      []*MemberInfo</span><br><span class=\"line\">\tattributes   []AttributeInfo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//文件解析入口方法，入参class文件流，返回class文件对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">(classData []<span class=\"keyword\">byte</span>)</span> <span class=\"params\">(cf *ClassFile, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//捕获异常</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> r := <span class=\"built_in\">recover</span>(); r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> ok <span class=\"keyword\">bool</span></span><br><span class=\"line\">\t\t\terr, ok = r.(error)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\terr = fmt.Errorf(<span class=\"string\">\"%v\"</span>, r)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcr := &amp;ClassReader&#123;classData&#125; <span class=\"comment\">//实例化classReader类</span></span><br><span class=\"line\">\tcf = &amp;ClassFile&#123;&#125; <span class=\"comment\">//实例化ClassFile类</span></span><br><span class=\"line\">\tcf.read(cr) <span class=\"comment\">//读取class文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取class文件的具体方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">read</span><span class=\"params\">(reader *ClassReader)</span></span> &#123;</span><br><span class=\"line\">\tself.readAndCheckMagic(reader) <span class=\"comment\">//读取魔数</span></span><br><span class=\"line\">\tself.readAndCheckVersion(reader) <span class=\"comment\">//读取主次版本号</span></span><br><span class=\"line\">\tself.constantPool = readConstantPool(reader) <span class=\"comment\">//读取常量池</span></span><br><span class=\"line\">\tself.accessFlags = reader.readUint16() <span class=\"comment\">//读取当前类（或者接口）的访问修饰符</span></span><br><span class=\"line\">\tself.thisClass = reader.readUint16() <span class=\"comment\">//读取当前类索引</span></span><br><span class=\"line\">\tself.superClass = reader.readUint16() <span class=\"comment\">//读取父类索引</span></span><br><span class=\"line\">\tself.interfaces = reader.readUint16s() <span class=\"comment\">//读取所有接口索引</span></span><br><span class=\"line\">\tself.fields = readMembers(reader, self.constantPool) <span class=\"comment\">//从常量池中读取所有成员</span></span><br><span class=\"line\">\tself.methods = readMembers(reader, self.constantPool) <span class=\"comment\">//从常量池中读取所有方法</span></span><br><span class=\"line\">\tself.attributes = readAttributes(reader, self.constantPool) <span class=\"comment\">//从常量池中读取所有属性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">readAndCheckMagic</span><span class=\"params\">(reader *ClassReader)</span></span> &#123;</span><br><span class=\"line\">\tmagic := reader.readUint32() <span class=\"comment\">//读取4Byte魔数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> magic != <span class=\"number\">0xCAFEBABE</span> &#123; <span class=\"comment\">//判断魔数是否为0xCAFEBABE</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"java.lang.ClassFormatError: magic!\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">readAndCheckVersion</span><span class=\"params\">(reader *ClassReader)</span></span> &#123;</span><br><span class=\"line\">\tself.minorVersion = reader.readUint16() <span class=\"comment\">//高2Byte为次版本号</span></span><br><span class=\"line\">\tself.majorVersion = reader.readUint16() <span class=\"comment\">//低2Byte为主版本号</span></span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> self.majorVersion &#123; <span class=\"comment\">//检查版本号是否为45~52</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">45</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">49</span>, <span class=\"number\">50</span>, <span class=\"number\">51</span>, <span class=\"number\">52</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> self.minorVersion == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"java.lang.UnsupportedClassVersionError!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">MinorVersion</span><span class=\"params\">()</span> <span class=\"title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.minorVersion</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">MajorVersion</span><span class=\"params\">()</span> <span class=\"title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.majorVersion</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">ConstantPool</span><span class=\"params\">()</span> <span class=\"title\">ConstantPool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.constantPool</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">AccessFlags</span><span class=\"params\">()</span> <span class=\"title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.accessFlags</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">Fields</span><span class=\"params\">()</span> []*<span class=\"title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.fields</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">Methods</span><span class=\"params\">()</span> []*<span class=\"title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.methods</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法，根据thisClass索引在常量池中查找名称</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">ClassName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.constantPool.getClassName(self.thisClass)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法，根据superClass索引在常量池中查找名称</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">SuperClassName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> self.superClass &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self.constantPool.getClassName(self.superClass)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法，根据interfaces索引在常量池中查找名称</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ClassFile)</span> <span class=\"title\">InterfaceNames</span><span class=\"params\">()</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tinterfaceNames := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(self.interfaces))</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, cpIndex := <span class=\"keyword\">range</span> self.interfaces &#123;</span><br><span class=\"line\">\t\tinterfaceNames[i] = self.constantPool.getClassName(cpIndex)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> interfaceNames</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>定义字段和方法的结构(field_info、method_info)</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MemberInfo <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">//field和method的结构类型，使用同一个结构</span></span><br><span class=\"line\">\tcp              ConstantPool <span class=\"comment\">//当前常量池</span></span><br><span class=\"line\">\taccessFlags     <span class=\"keyword\">uint16</span> <span class=\"comment\">//访问标志</span></span><br><span class=\"line\">\tnameIndex       <span class=\"keyword\">uint16</span> <span class=\"comment\">//名称索引</span></span><br><span class=\"line\">\tdescriptorIndex <span class=\"keyword\">uint16</span> <span class=\"comment\">//描述索引</span></span><br><span class=\"line\">\tattributes      []AttributeInfo <span class=\"comment\">//属性列表 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// read field or method table</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readMembers</span><span class=\"params\">(reader *ClassReader, cp ConstantPool)</span> []*<span class=\"title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\tmemberCount := reader.readUint16() <span class=\"comment\">//读取field或method数量</span></span><br><span class=\"line\">\tmembers := <span class=\"built_in\">make</span>([]*MemberInfo, memberCount) <span class=\"comment\">//创建数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> members &#123;</span><br><span class=\"line\">\t\tmembers[i] = readMember(reader, cp)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> members</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//具体读取field和method的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readMember</span><span class=\"params\">(reader *ClassReader, cp ConstantPool)</span> *<span class=\"title\">MemberInfo</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;MemberInfo&#123;</span><br><span class=\"line\">\t\tcp:              cp,</span><br><span class=\"line\">\t\taccessFlags:     reader.readUint16(), <span class=\"comment\">//读取2Byte的访问控制符</span></span><br><span class=\"line\">\t\tnameIndex:       reader.readUint16(), <span class=\"comment\">//读取2Byte的名称索引</span></span><br><span class=\"line\">\t\tdescriptorIndex: reader.readUint16(), <span class=\"comment\">//读取2Byte的描述索引</span></span><br><span class=\"line\">\t\tattributes:      readAttributes(reader, cp), <span class=\"comment\">//读取属性列表</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *MemberInfo)</span> <span class=\"title\">AccessFlags</span><span class=\"params\">()</span> <span class=\"title\">uint16</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.accessFlags</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法，通过名称索引访问常量池</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *MemberInfo)</span> <span class=\"title\">Name</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.cp.getUtf8(self.nameIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对外暴露get方法，通过描述索引访问常量池</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *MemberInfo)</span> <span class=\"title\">Descriptor</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.cp.getUtf8(self.descriptorIndex)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"🐇","date":"2019-09-05T05:19:02.000Z","_content":"\n大白兔。。你变了。。。\n\n{% asset_img 牌子.jpeg 400 400 牌子 %}\n<!-- more -->\n\n{% asset_img 全景.jpeg 400 400 排队 %}","source":"_posts/🐇.md","raw":"---\ntitle: \"\\U0001F407\"\ndate: 2019-09-05 13:19:02\ntags: \n    - Food\ncategories :\n    - Life\n---\n\n大白兔。。你变了。。。\n\n{% asset_img 牌子.jpeg 400 400 牌子 %}\n<!-- more -->\n\n{% asset_img 全景.jpeg 400 400 排队 %}","slug":"🐇","published":1,"updated":"2019-09-10T13:44:41.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jeig000sisnyqbw0piyh","content":"<p>大白兔。。你变了。。。</p>\n<img src=\"/2019/09/05/🐇/牌子.jpeg\" width=\"400\" height=\"400\" title=\"牌子\">\n<a id=\"more\"></a>\n\n<img src=\"/2019/09/05/🐇/全景.jpeg\" width=\"400\" height=\"400\" title=\"排队\">","site":{"data":{}},"_categories":[{"name":"Life","path":"categories/Life/"}],"_tags":[{"name":"Food","path":"tags/Food/"}],"excerpt":"<p>大白兔。。你变了。。。</p>\n<img src=\"/2019/09/05/🐇/牌子.jpeg\" width=\"400\" height=\"400\" title=\"牌子\">","more":"<img src=\"/2019/09/05/🐇/全景.jpeg\" width=\"400\" height=\"400\" title=\"排队\">"},{"title":"自己动手写Java虚拟机 笔记4","date":"2019-09-26T13:49:11.000Z","_content":"\n### 运行时数据区\nJVM将需要用到的数据存放入内存中，这个内存区就叫运行时数据区\n可分为两种：\n1. 一类是多线程共享的，该数据区需要在Java虚拟机启动时创建好，在Java虚拟机退出时销毁。\n2. 一类则是线程私有的，该数据区则在创建线程时才创建，线程退出时销毁。\n\n<!-- more -->\n\n{% asset_img 运行时数据区.png 800 800 运行时数据区 %}\n\n### 实现\n#### 定义对象结构\n\n{% codeblock lang:golang %}\ntype Object struct {\n\t// todo\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-线程\n\n{% codeblock lang:golang %}\ntype Thread struct {\n\tpc    int // the address of the instruction currently being executed\n\tstack *Stack //Java虚拟机栈指针\n\t// todo\n}\n\n//创建Thread实例\n//java命令提供了-Xss选项来设置Java虚拟机栈大小\nfunc NewThread() *Thread {\n\treturn &Thread{\n\t\tstack: newStack(1024), //最多容纳1024帧\n\t}\n}\n\nfunc (self *Thread) PC() int {\n\treturn self.pc\n}\nfunc (self *Thread) SetPC(pc int) {\n\tself.pc = pc\n}\n\n//当前帧进栈\nfunc (self *Thread) PushFrame(frame *Frame) {\n\tself.stack.push(frame)\n}\n//当前帧出栈\nfunc (self *Thread) PopFrame() *Frame {\n\treturn self.stack.pop()\n}\n//获取当前帧\nfunc (self *Thread) CurrentFrame() *Frame {\n\treturn self.stack.top()\n}\n\n\n\n\n{% endcodeblock %}\n\n\n#### 运行时数据区-Java虚拟机栈\n\n{% codeblock lang:golang %}\ntype Stack struct {\n\tmaxSize uint //最多可以容纳多少帧\n\tsize    uint //栈的当前大小\n\t_top    *Frame //保存栈顶指针\n}\n\n//实例一个栈\nfunc newStack(maxSize uint) *Stack {\n\treturn &Stack{\n\t\tmaxSize: maxSize,\n\t}\n}\n\n//当前帧进栈\nfunc (self *Stack) push(frame *Frame) {\n\tif self.size >= self.maxSize { //判断当前栈大小是否超过最大容量\n\t\tpanic(\"java.lang.StackOverflowError\") \n\t}\n\n\tif self._top != nil {  //当前栈顶不为空时\n\t\tframe.lower = self._top //将插入帧尾指向栈顶指针\n\t}\n\n\tself._top = frame //当前栈顶指向当前帧\n\tself.size++ //当前栈大小加1\n}\n\n//当前帧出栈\nfunc (self *Stack) pop() *Frame {\n\tif self._top == nil { //当前栈顶为空时报错\n\t\tpanic(\"jvm stack is empty!\")\n\t}\n\n\ttop := self._top //取出当前栈顶帧\n\tself._top = top.lower //将当前栈顶指向top的下一帧\n\ttop.lower = nil //断开top的尾指针\n\tself.size-- //当前栈大小减1\n\n\treturn top //返回top\n}\n\n//获取当前栈顶帧\nfunc (self *Stack) top() *Frame {\n\tif self._top == nil { ////当前栈顶为空时报错\n\t\tpanic(\"jvm stack is empty!\")\n\t}\n\n\treturn self._top //返回当前栈顶帧\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-帧\n\n{% codeblock lang:golang %}\ntype Frame struct {\n\tlower        *Frame //指向下一帧\n\tlocalVars    LocalVars //保存局部变量表指针\n\toperandStack *OperandStack //保存操作数栈指针\n\t// todo\n}\n\n//实例化帧\nfunc NewFrame(maxLocals, maxStack uint) *Frame {\n\treturn &Frame{\n\t\tlocalVars:    newLocalVars(maxLocals), //实例化局部变量对象\n\t\toperandStack: newOperandStack(maxStack), //实例化操作数栈对象\n\t}\n}\n\n// getters\nfunc (self *Frame) LocalVars() LocalVars {\n\treturn self.localVars\n}\nfunc (self *Frame) OperandStack() *OperandStack {\n\treturn self.operandStack\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-局部变量表\n\n{% codeblock lang:golang %}\ntype LocalVars []Slot\n\n//创建局部变量实例\nfunc newLocalVars(maxLocals uint) LocalVars {\n\tif maxLocals > 0 {\n\t\treturn make([]Slot, maxLocals) //申明大小为maxLocals的Slot数组\n\t}\n\treturn nil\n}\n\n//设置int类型\nfunc (self LocalVars) SetInt(index uint, val int32) {\n\tself[index].num = val\n}\n//取int类型\nfunc (self LocalVars) GetInt(index uint) int32 {\n\treturn self[index].num\n}\n//设置float32类型\nfunc (self LocalVars) SetFloat(index uint, val float32) {\n\tbits := math.Float32bits(val)//转为uint32\n\tself[index].num = int32(bits) //转为int32\n}\n//取float32类型\nfunc (self LocalVars) GetFloat(index uint) float32 {\n\tbits := uint32(self[index].num)//转为unit32\n\treturn math.Float32frombits(bits)//转为float\n}\n\n//设置long类型\nfunc (self LocalVars) SetLong(index uint, val int64) {\n\tself[index].num = int32(val)//取低位32位存储在index\n\tself[index+1].num = int32(val >> 32) //右移32位取高位32位存储在index+1\n}\n//取long类型\nfunc (self LocalVars) GetLong(index uint) int64 {\n\tlow := uint32(self[index].num) //取index低32位\n\thigh := uint32(self[index+1].num) //取index+1高32位\n\treturn int64(high)<<32 | int64(low) //左移高位32位，拼接高低位返回\n}\n\n//设置float64\nfunc (self LocalVars) SetDouble(index uint, val float64) {\n\tbits := math.Float64bits(val) //转为uint64\n\tself.SetLong(index, int64(bits)) //用long型设置方法设置int64\n}\n//取float64\nfunc (self LocalVars) GetDouble(index uint) float64 {\n\tbits := uint64(self.GetLong(index)) //按long型取值方法取出uint64\n\treturn math.Float64frombits(bits) //转为float64\n}\n//设置引用\nfunc (self LocalVars) SetRef(index uint, ref *Object) {\n\tself[index].ref = ref\n}\n//取引用\nfunc (self LocalVars) GetRef(index uint) *Object {\n\treturn self[index].ref\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-操作数栈\n\n{% codeblock lang:golang %}\ntype OperandStack struct {\n\tsize  uint //记录栈顶位置\n\tslots []Slot\n}\n//实例化操作数栈\nfunc newOperandStack(maxStack uint) *OperandStack {\n\tif maxStack > 0 {\n\t\treturn &OperandStack{\n\t\t\tslots: make([]Slot, maxStack),//申明maxStack大小的Slot数组\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (self *OperandStack) PushInt(val int32) {\n\tself.slots[self.size].num = val\n\tself.size++\n}\nfunc (self *OperandStack) PopInt() int32 {\n\tself.size--\n\treturn self.slots[self.size].num\n}\n\nfunc (self *OperandStack) PushFloat(val float32) {\n\tbits := math.Float32bits(val)\n\tself.slots[self.size].num = int32(bits)\n\tself.size++\n}\nfunc (self *OperandStack) PopFloat() float32 {\n\tself.size--\n\tbits := uint32(self.slots[self.size].num)\n\treturn math.Float32frombits(bits)\n}\n\n// long consumes two slots\nfunc (self *OperandStack) PushLong(val int64) {\n\tself.slots[self.size].num = int32(val)\n\tself.slots[self.size+1].num = int32(val >> 32)\n\tself.size += 2\n}\nfunc (self *OperandStack) PopLong() int64 {\n\tself.size -= 2\n\tlow := uint32(self.slots[self.size].num)\n\thigh := uint32(self.slots[self.size+1].num)\n\treturn int64(high)<<32 | int64(low)\n}\n\n// double consumes two slots\nfunc (self *OperandStack) PushDouble(val float64) {\n\tbits := math.Float64bits(val)\n\tself.PushLong(int64(bits))\n}\nfunc (self *OperandStack) PopDouble() float64 {\n\tbits := uint64(self.PopLong())\n\treturn math.Float64frombits(bits)\n}\n\nfunc (self *OperandStack) PushRef(ref *Object) {\n\tself.slots[self.size].ref = ref\n\tself.size++\n}\nfunc (self *OperandStack) PopRef() *Object {\n\tself.size--\n\tref := self.slots[self.size].ref\n\tself.slots[self.size].ref = nil\n\treturn ref\n}\n{% endcodeblock %}\n\n#### 运行时数据区-操作数栈\n\n{% codeblock lang:golang %}\n\n{% endcodeblock %}","source":"_posts/自己动手写Java虚拟机-笔记4.md","raw":"---\ntitle: 自己动手写Java虚拟机 笔记4\ndate: 2019-09-26 21:49:11\ntags: \n    - JVM\n    - Java\n    - Go\ncategories :\n    - Technology\n---\n\n### 运行时数据区\nJVM将需要用到的数据存放入内存中，这个内存区就叫运行时数据区\n可分为两种：\n1. 一类是多线程共享的，该数据区需要在Java虚拟机启动时创建好，在Java虚拟机退出时销毁。\n2. 一类则是线程私有的，该数据区则在创建线程时才创建，线程退出时销毁。\n\n<!-- more -->\n\n{% asset_img 运行时数据区.png 800 800 运行时数据区 %}\n\n### 实现\n#### 定义对象结构\n\n{% codeblock lang:golang %}\ntype Object struct {\n\t// todo\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-线程\n\n{% codeblock lang:golang %}\ntype Thread struct {\n\tpc    int // the address of the instruction currently being executed\n\tstack *Stack //Java虚拟机栈指针\n\t// todo\n}\n\n//创建Thread实例\n//java命令提供了-Xss选项来设置Java虚拟机栈大小\nfunc NewThread() *Thread {\n\treturn &Thread{\n\t\tstack: newStack(1024), //最多容纳1024帧\n\t}\n}\n\nfunc (self *Thread) PC() int {\n\treturn self.pc\n}\nfunc (self *Thread) SetPC(pc int) {\n\tself.pc = pc\n}\n\n//当前帧进栈\nfunc (self *Thread) PushFrame(frame *Frame) {\n\tself.stack.push(frame)\n}\n//当前帧出栈\nfunc (self *Thread) PopFrame() *Frame {\n\treturn self.stack.pop()\n}\n//获取当前帧\nfunc (self *Thread) CurrentFrame() *Frame {\n\treturn self.stack.top()\n}\n\n\n\n\n{% endcodeblock %}\n\n\n#### 运行时数据区-Java虚拟机栈\n\n{% codeblock lang:golang %}\ntype Stack struct {\n\tmaxSize uint //最多可以容纳多少帧\n\tsize    uint //栈的当前大小\n\t_top    *Frame //保存栈顶指针\n}\n\n//实例一个栈\nfunc newStack(maxSize uint) *Stack {\n\treturn &Stack{\n\t\tmaxSize: maxSize,\n\t}\n}\n\n//当前帧进栈\nfunc (self *Stack) push(frame *Frame) {\n\tif self.size >= self.maxSize { //判断当前栈大小是否超过最大容量\n\t\tpanic(\"java.lang.StackOverflowError\") \n\t}\n\n\tif self._top != nil {  //当前栈顶不为空时\n\t\tframe.lower = self._top //将插入帧尾指向栈顶指针\n\t}\n\n\tself._top = frame //当前栈顶指向当前帧\n\tself.size++ //当前栈大小加1\n}\n\n//当前帧出栈\nfunc (self *Stack) pop() *Frame {\n\tif self._top == nil { //当前栈顶为空时报错\n\t\tpanic(\"jvm stack is empty!\")\n\t}\n\n\ttop := self._top //取出当前栈顶帧\n\tself._top = top.lower //将当前栈顶指向top的下一帧\n\ttop.lower = nil //断开top的尾指针\n\tself.size-- //当前栈大小减1\n\n\treturn top //返回top\n}\n\n//获取当前栈顶帧\nfunc (self *Stack) top() *Frame {\n\tif self._top == nil { ////当前栈顶为空时报错\n\t\tpanic(\"jvm stack is empty!\")\n\t}\n\n\treturn self._top //返回当前栈顶帧\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-帧\n\n{% codeblock lang:golang %}\ntype Frame struct {\n\tlower        *Frame //指向下一帧\n\tlocalVars    LocalVars //保存局部变量表指针\n\toperandStack *OperandStack //保存操作数栈指针\n\t// todo\n}\n\n//实例化帧\nfunc NewFrame(maxLocals, maxStack uint) *Frame {\n\treturn &Frame{\n\t\tlocalVars:    newLocalVars(maxLocals), //实例化局部变量对象\n\t\toperandStack: newOperandStack(maxStack), //实例化操作数栈对象\n\t}\n}\n\n// getters\nfunc (self *Frame) LocalVars() LocalVars {\n\treturn self.localVars\n}\nfunc (self *Frame) OperandStack() *OperandStack {\n\treturn self.operandStack\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-局部变量表\n\n{% codeblock lang:golang %}\ntype LocalVars []Slot\n\n//创建局部变量实例\nfunc newLocalVars(maxLocals uint) LocalVars {\n\tif maxLocals > 0 {\n\t\treturn make([]Slot, maxLocals) //申明大小为maxLocals的Slot数组\n\t}\n\treturn nil\n}\n\n//设置int类型\nfunc (self LocalVars) SetInt(index uint, val int32) {\n\tself[index].num = val\n}\n//取int类型\nfunc (self LocalVars) GetInt(index uint) int32 {\n\treturn self[index].num\n}\n//设置float32类型\nfunc (self LocalVars) SetFloat(index uint, val float32) {\n\tbits := math.Float32bits(val)//转为uint32\n\tself[index].num = int32(bits) //转为int32\n}\n//取float32类型\nfunc (self LocalVars) GetFloat(index uint) float32 {\n\tbits := uint32(self[index].num)//转为unit32\n\treturn math.Float32frombits(bits)//转为float\n}\n\n//设置long类型\nfunc (self LocalVars) SetLong(index uint, val int64) {\n\tself[index].num = int32(val)//取低位32位存储在index\n\tself[index+1].num = int32(val >> 32) //右移32位取高位32位存储在index+1\n}\n//取long类型\nfunc (self LocalVars) GetLong(index uint) int64 {\n\tlow := uint32(self[index].num) //取index低32位\n\thigh := uint32(self[index+1].num) //取index+1高32位\n\treturn int64(high)<<32 | int64(low) //左移高位32位，拼接高低位返回\n}\n\n//设置float64\nfunc (self LocalVars) SetDouble(index uint, val float64) {\n\tbits := math.Float64bits(val) //转为uint64\n\tself.SetLong(index, int64(bits)) //用long型设置方法设置int64\n}\n//取float64\nfunc (self LocalVars) GetDouble(index uint) float64 {\n\tbits := uint64(self.GetLong(index)) //按long型取值方法取出uint64\n\treturn math.Float64frombits(bits) //转为float64\n}\n//设置引用\nfunc (self LocalVars) SetRef(index uint, ref *Object) {\n\tself[index].ref = ref\n}\n//取引用\nfunc (self LocalVars) GetRef(index uint) *Object {\n\treturn self[index].ref\n}\n\n{% endcodeblock %}\n\n#### 运行时数据区-操作数栈\n\n{% codeblock lang:golang %}\ntype OperandStack struct {\n\tsize  uint //记录栈顶位置\n\tslots []Slot\n}\n//实例化操作数栈\nfunc newOperandStack(maxStack uint) *OperandStack {\n\tif maxStack > 0 {\n\t\treturn &OperandStack{\n\t\t\tslots: make([]Slot, maxStack),//申明maxStack大小的Slot数组\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (self *OperandStack) PushInt(val int32) {\n\tself.slots[self.size].num = val\n\tself.size++\n}\nfunc (self *OperandStack) PopInt() int32 {\n\tself.size--\n\treturn self.slots[self.size].num\n}\n\nfunc (self *OperandStack) PushFloat(val float32) {\n\tbits := math.Float32bits(val)\n\tself.slots[self.size].num = int32(bits)\n\tself.size++\n}\nfunc (self *OperandStack) PopFloat() float32 {\n\tself.size--\n\tbits := uint32(self.slots[self.size].num)\n\treturn math.Float32frombits(bits)\n}\n\n// long consumes two slots\nfunc (self *OperandStack) PushLong(val int64) {\n\tself.slots[self.size].num = int32(val)\n\tself.slots[self.size+1].num = int32(val >> 32)\n\tself.size += 2\n}\nfunc (self *OperandStack) PopLong() int64 {\n\tself.size -= 2\n\tlow := uint32(self.slots[self.size].num)\n\thigh := uint32(self.slots[self.size+1].num)\n\treturn int64(high)<<32 | int64(low)\n}\n\n// double consumes two slots\nfunc (self *OperandStack) PushDouble(val float64) {\n\tbits := math.Float64bits(val)\n\tself.PushLong(int64(bits))\n}\nfunc (self *OperandStack) PopDouble() float64 {\n\tbits := uint64(self.PopLong())\n\treturn math.Float64frombits(bits)\n}\n\nfunc (self *OperandStack) PushRef(ref *Object) {\n\tself.slots[self.size].ref = ref\n\tself.size++\n}\nfunc (self *OperandStack) PopRef() *Object {\n\tself.size--\n\tref := self.slots[self.size].ref\n\tself.slots[self.size].ref = nil\n\treturn ref\n}\n{% endcodeblock %}\n\n#### 运行时数据区-操作数栈\n\n{% codeblock lang:golang %}\n\n{% endcodeblock %}","slug":"自己动手写Java虚拟机-笔记4","published":1,"updated":"2019-09-26T14:31:06.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jeih000visnymvxbjqg3","content":"<h3 id=\"运行时数据区\"><a href=\"#运行时数据区\" class=\"headerlink\" title=\"运行时数据区\"></a>运行时数据区</h3><p>JVM将需要用到的数据存放入内存中，这个内存区就叫运行时数据区<br>可分为两种：</p>\n<ol>\n<li>一类是多线程共享的，该数据区需要在Java虚拟机启动时创建好，在Java虚拟机退出时销毁。</li>\n<li>一类则是线程私有的，该数据区则在创建线程时才创建，线程退出时销毁。</li>\n</ol>\n<a id=\"more\"></a>\n\n<img src=\"/2019/09/26/自己动手写Java虚拟机-笔记4/运行时数据区.png\" width=\"800\" height=\"800\" title=\"运行时数据区\">\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><h4 id=\"定义对象结构\"><a href=\"#定义对象结构\" class=\"headerlink\" title=\"定义对象结构\"></a>定义对象结构</h4><figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> Object <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-comment\">// todo</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-线程\"><a href=\"#运行时数据区-线程\" class=\"headerlink\" title=\"运行时数据区-线程\"></a>运行时数据区-线程</h4><figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> Thread <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpc    <span class=\"hljs-keyword\">int</span> <span class=\"hljs-comment\">// the address of the instruction currently being executed</span></span><br><span class=\"line\">\tstack *Stack <span class=\"hljs-comment\">//Java虚拟机栈指针</span></span><br><span class=\"line\">\t<span class=\"hljs-comment\">// todo</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//创建Thread实例</span></span><br><span class=\"line\"><span class=\"hljs-comment\">//java命令提供了-Xss选项来设置Java虚拟机栈大小</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewThread</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">Thread</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> &amp;Thread&#123;</span><br><span class=\"line\">\t\tstack: newStack(<span class=\"hljs-number\">1024</span>), <span class=\"hljs-comment\">//最多容纳1024帧</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Thread)</span> <span class=\"hljs-title\">PC</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.pc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Thread)</span> <span class=\"hljs-title\">SetPC</span><span class=\"hljs-params\">(pc <span class=\"hljs-keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tself.pc = pc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//当前帧进栈</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Thread)</span> <span class=\"hljs-title\">PushFrame</span><span class=\"hljs-params\">(frame *Frame)</span></span> &#123;</span><br><span class=\"line\">\tself.stack.push(frame)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//当前帧出栈</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Thread)</span> <span class=\"hljs-title\">PopFrame</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.stack.pop()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//获取当前帧</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Thread)</span> <span class=\"hljs-title\">CurrentFrame</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.stack.top()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"运行时数据区-Java虚拟机栈\"><a href=\"#运行时数据区-Java虚拟机栈\" class=\"headerlink\" title=\"运行时数据区-Java虚拟机栈\"></a>运行时数据区-Java虚拟机栈</h4><figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> Stack <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmaxSize <span class=\"hljs-keyword\">uint</span> <span class=\"hljs-comment\">//最多可以容纳多少帧</span></span><br><span class=\"line\">\tsize    <span class=\"hljs-keyword\">uint</span> <span class=\"hljs-comment\">//栈的当前大小</span></span><br><span class=\"line\">\t_top    *Frame <span class=\"hljs-comment\">//保存栈顶指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//实例一个栈</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newStack</span><span class=\"hljs-params\">(maxSize <span class=\"hljs-keyword\">uint</span>)</span> *<span class=\"hljs-title\">Stack</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> &amp;Stack&#123;</span><br><span class=\"line\">\t\tmaxSize: maxSize,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//当前帧进栈</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Stack)</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(frame *Frame)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> self.size &gt;= self.maxSize &#123; <span class=\"hljs-comment\">//判断当前栈大小是否超过最大容量</span></span><br><span class=\"line\">\t\t<span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-string\">\"java.lang.StackOverflowError\"</span>) </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> self._top != <span class=\"hljs-literal\">nil</span> &#123;  <span class=\"hljs-comment\">//当前栈顶不为空时</span></span><br><span class=\"line\">\t\tframe.lower = self._top <span class=\"hljs-comment\">//将插入帧尾指向栈顶指针</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tself._top = frame <span class=\"hljs-comment\">//当前栈顶指向当前帧</span></span><br><span class=\"line\">\tself.size++ <span class=\"hljs-comment\">//当前栈大小加1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//当前帧出栈</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Stack)</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> self._top == <span class=\"hljs-literal\">nil</span> &#123; <span class=\"hljs-comment\">//当前栈顶为空时报错</span></span><br><span class=\"line\">\t\t<span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-string\">\"jvm stack is empty!\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttop := self._top <span class=\"hljs-comment\">//取出当前栈顶帧</span></span><br><span class=\"line\">\tself._top = top.lower <span class=\"hljs-comment\">//将当前栈顶指向top的下一帧</span></span><br><span class=\"line\">\ttop.lower = <span class=\"hljs-literal\">nil</span> <span class=\"hljs-comment\">//断开top的尾指针</span></span><br><span class=\"line\">\tself.size-- <span class=\"hljs-comment\">//当前栈大小减1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> top <span class=\"hljs-comment\">//返回top</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//获取当前栈顶帧</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Stack)</span> <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> self._top == <span class=\"hljs-literal\">nil</span> &#123; <span class=\"hljs-comment\">////当前栈顶为空时报错</span></span><br><span class=\"line\">\t\t<span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-string\">\"jvm stack is empty!\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self._top <span class=\"hljs-comment\">//返回当前栈顶帧</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-帧\"><a href=\"#运行时数据区-帧\" class=\"headerlink\" title=\"运行时数据区-帧\"></a>运行时数据区-帧</h4><figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> Frame <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlower        *Frame <span class=\"hljs-comment\">//指向下一帧</span></span><br><span class=\"line\">\tlocalVars    LocalVars <span class=\"hljs-comment\">//保存局部变量表指针</span></span><br><span class=\"line\">\toperandStack *OperandStack <span class=\"hljs-comment\">//保存操作数栈指针</span></span><br><span class=\"line\">\t<span class=\"hljs-comment\">// todo</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//实例化帧</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewFrame</span><span class=\"hljs-params\">(maxLocals, maxStack <span class=\"hljs-keyword\">uint</span>)</span> *<span class=\"hljs-title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> &amp;Frame&#123;</span><br><span class=\"line\">\t\tlocalVars:    newLocalVars(maxLocals), <span class=\"hljs-comment\">//实例化局部变量对象</span></span><br><span class=\"line\">\t\toperandStack: newOperandStack(maxStack), <span class=\"hljs-comment\">//实例化操作数栈对象</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// getters</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Frame)</span> <span class=\"hljs-title\">LocalVars</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">LocalVars</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.localVars</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Frame)</span> <span class=\"hljs-title\">OperandStack</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">OperandStack</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.operandStack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-局部变量表\"><a href=\"#运行时数据区-局部变量表\" class=\"headerlink\" title=\"运行时数据区-局部变量表\"></a>运行时数据区-局部变量表</h4><figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> LocalVars []Slot</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//创建局部变量实例</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newLocalVars</span><span class=\"hljs-params\">(maxLocals <span class=\"hljs-keyword\">uint</span>)</span> <span class=\"hljs-title\">LocalVars</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> maxLocals &gt; <span class=\"hljs-number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">make</span>([]Slot, maxLocals) <span class=\"hljs-comment\">//申明大小为maxLocals的Slot数组</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//设置int类型</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">SetInt</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>, val <span class=\"hljs-keyword\">int32</span>)</span></span> &#123;</span><br><span class=\"line\">\tself[index].num = val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//取int类型</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">GetInt</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>)</span> <span class=\"hljs-title\">int32</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self[index].num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//设置float32类型</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">SetFloat</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>, val <span class=\"hljs-keyword\">float32</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float32bits(val)<span class=\"hljs-comment\">//转为uint32</span></span><br><span class=\"line\">\tself[index].num = <span class=\"hljs-keyword\">int32</span>(bits) <span class=\"hljs-comment\">//转为int32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//取float32类型</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">GetFloat</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>)</span> <span class=\"hljs-title\">float32</span></span> &#123;</span><br><span class=\"line\">\tbits := <span class=\"hljs-keyword\">uint32</span>(self[index].num)<span class=\"hljs-comment\">//转为unit32</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> math.Float32frombits(bits)<span class=\"hljs-comment\">//转为float</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//设置long类型</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">SetLong</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>, val <span class=\"hljs-keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\tself[index].num = <span class=\"hljs-keyword\">int32</span>(val)<span class=\"hljs-comment\">//取低位32位存储在index</span></span><br><span class=\"line\">\tself[index+<span class=\"hljs-number\">1</span>].num = <span class=\"hljs-keyword\">int32</span>(val &gt;&gt; <span class=\"hljs-number\">32</span>) <span class=\"hljs-comment\">//右移32位取高位32位存储在index+1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//取long类型</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">GetLong</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>)</span> <span class=\"hljs-title\">int64</span></span> &#123;</span><br><span class=\"line\">\tlow := <span class=\"hljs-keyword\">uint32</span>(self[index].num) <span class=\"hljs-comment\">//取index低32位</span></span><br><span class=\"line\">\thigh := <span class=\"hljs-keyword\">uint32</span>(self[index+<span class=\"hljs-number\">1</span>].num) <span class=\"hljs-comment\">//取index+1高32位</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">int64</span>(high)&lt;&lt;<span class=\"hljs-number\">32</span> | <span class=\"hljs-keyword\">int64</span>(low) <span class=\"hljs-comment\">//左移高位32位，拼接高低位返回</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//设置float64</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">SetDouble</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>, val <span class=\"hljs-keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float64bits(val) <span class=\"hljs-comment\">//转为uint64</span></span><br><span class=\"line\">\tself.SetLong(index, <span class=\"hljs-keyword\">int64</span>(bits)) <span class=\"hljs-comment\">//用long型设置方法设置int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//取float64</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">GetDouble</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>)</span> <span class=\"hljs-title\">float64</span></span> &#123;</span><br><span class=\"line\">\tbits := <span class=\"hljs-keyword\">uint64</span>(self.GetLong(index)) <span class=\"hljs-comment\">//按long型取值方法取出uint64</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> math.Float64frombits(bits) <span class=\"hljs-comment\">//转为float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//设置引用</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">SetRef</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>, ref *Object)</span></span> &#123;</span><br><span class=\"line\">\tself[index].ref = ref</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//取引用</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self LocalVars)</span> <span class=\"hljs-title\">GetRef</span><span class=\"hljs-params\">(index <span class=\"hljs-keyword\">uint</span>)</span> *<span class=\"hljs-title\">Object</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self[index].ref</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-操作数栈\"><a href=\"#运行时数据区-操作数栈\" class=\"headerlink\" title=\"运行时数据区-操作数栈\"></a>运行时数据区-操作数栈</h4><figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> OperandStack <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsize  <span class=\"hljs-keyword\">uint</span> <span class=\"hljs-comment\">//记录栈顶位置</span></span><br><span class=\"line\">\tslots []Slot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-comment\">//实例化操作数栈</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newOperandStack</span><span class=\"hljs-params\">(maxStack <span class=\"hljs-keyword\">uint</span>)</span> *<span class=\"hljs-title\">OperandStack</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> maxStack &gt; <span class=\"hljs-number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span> &amp;OperandStack&#123;</span><br><span class=\"line\">\t\t\tslots: <span class=\"hljs-built_in\">make</span>([]Slot, maxStack),<span class=\"hljs-comment\">//申明maxStack大小的Slot数组</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PushInt</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">int32</span>)</span></span> &#123;</span><br><span class=\"line\">\tself.slots[self.size].num = val</span><br><span class=\"line\">\tself.size++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PopInt</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int32</span></span> &#123;</span><br><span class=\"line\">\tself.size--</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.slots[self.size].num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PushFloat</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">float32</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float32bits(val)</span><br><span class=\"line\">\tself.slots[self.size].num = <span class=\"hljs-keyword\">int32</span>(bits)</span><br><span class=\"line\">\tself.size++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PopFloat</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">float32</span></span> &#123;</span><br><span class=\"line\">\tself.size--</span><br><span class=\"line\">\tbits := <span class=\"hljs-keyword\">uint32</span>(self.slots[self.size].num)</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> math.Float32frombits(bits)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// long consumes two slots</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PushLong</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\tself.slots[self.size].num = <span class=\"hljs-keyword\">int32</span>(val)</span><br><span class=\"line\">\tself.slots[self.size+<span class=\"hljs-number\">1</span>].num = <span class=\"hljs-keyword\">int32</span>(val &gt;&gt; <span class=\"hljs-number\">32</span>)</span><br><span class=\"line\">\tself.size += <span class=\"hljs-number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PopLong</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">int64</span></span> &#123;</span><br><span class=\"line\">\tself.size -= <span class=\"hljs-number\">2</span></span><br><span class=\"line\">\tlow := <span class=\"hljs-keyword\">uint32</span>(self.slots[self.size].num)</span><br><span class=\"line\">\thigh := <span class=\"hljs-keyword\">uint32</span>(self.slots[self.size+<span class=\"hljs-number\">1</span>].num)</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">int64</span>(high)&lt;&lt;<span class=\"hljs-number\">32</span> | <span class=\"hljs-keyword\">int64</span>(low)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">// double consumes two slots</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PushDouble</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float64bits(val)</span><br><span class=\"line\">\tself.PushLong(<span class=\"hljs-keyword\">int64</span>(bits))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PopDouble</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">float64</span></span> &#123;</span><br><span class=\"line\">\tbits := <span class=\"hljs-keyword\">uint64</span>(self.PopLong())</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> math.Float64frombits(bits)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PushRef</span><span class=\"hljs-params\">(ref *Object)</span></span> &#123;</span><br><span class=\"line\">\tself.slots[self.size].ref = ref</span><br><span class=\"line\">\tself.size++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *OperandStack)</span> <span class=\"hljs-title\">PopRef</span><span class=\"hljs-params\">()</span> *<span class=\"hljs-title\">Object</span></span> &#123;</span><br><span class=\"line\">\tself.size--</span><br><span class=\"line\">\tref := self.slots[self.size].ref</span><br><span class=\"line\">\tself.slots[self.size].ref = <span class=\"hljs-literal\">nil</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> ref</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-操作数栈-1\"><a href=\"#运行时数据区-操作数栈-1\" class=\"headerlink\" title=\"运行时数据区-操作数栈\"></a>运行时数据区-操作数栈</h4><figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"JVM","path":"tags/JVM/"},{"name":"Java","path":"tags/Java/"},{"name":"Go","path":"tags/Go/"}],"excerpt":"<h3 id=\"运行时数据区\"><a href=\"#运行时数据区\" class=\"headerlink\" title=\"运行时数据区\"></a>运行时数据区</h3><p>JVM将需要用到的数据存放入内存中，这个内存区就叫运行时数据区<br>可分为两种：</p>\n<ol>\n<li>一类是多线程共享的，该数据区需要在Java虚拟机启动时创建好，在Java虚拟机退出时销毁。</li>\n<li>一类则是线程私有的，该数据区则在创建线程时才创建，线程退出时销毁。</li>\n</ol>","more":"<img src=\"/2019/09/26/自己动手写Java虚拟机-笔记4/运行时数据区.png\" width=\"800\" height=\"800\" title=\"运行时数据区\">\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><h4 id=\"定义对象结构\"><a href=\"#定义对象结构\" class=\"headerlink\" title=\"定义对象结构\"></a>定义对象结构</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Object <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// todo</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-线程\"><a href=\"#运行时数据区-线程\" class=\"headerlink\" title=\"运行时数据区-线程\"></a>运行时数据区-线程</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Thread <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpc    <span class=\"keyword\">int</span> <span class=\"comment\">// the address of the instruction currently being executed</span></span><br><span class=\"line\">\tstack *Stack <span class=\"comment\">//Java虚拟机栈指针</span></span><br><span class=\"line\">\t<span class=\"comment\">// todo</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建Thread实例</span></span><br><span class=\"line\"><span class=\"comment\">//java命令提供了-Xss选项来设置Java虚拟机栈大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewThread</span><span class=\"params\">()</span> *<span class=\"title\">Thread</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Thread&#123;</span><br><span class=\"line\">\t\tstack: newStack(<span class=\"number\">1024</span>), <span class=\"comment\">//最多容纳1024帧</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Thread)</span> <span class=\"title\">PC</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.pc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Thread)</span> <span class=\"title\">SetPC</span><span class=\"params\">(pc <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tself.pc = pc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//当前帧进栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Thread)</span> <span class=\"title\">PushFrame</span><span class=\"params\">(frame *Frame)</span></span> &#123;</span><br><span class=\"line\">\tself.stack.push(frame)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当前帧出栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Thread)</span> <span class=\"title\">PopFrame</span><span class=\"params\">()</span> *<span class=\"title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.stack.pop()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取当前帧</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Thread)</span> <span class=\"title\">CurrentFrame</span><span class=\"params\">()</span> *<span class=\"title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.stack.top()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"运行时数据区-Java虚拟机栈\"><a href=\"#运行时数据区-Java虚拟机栈\" class=\"headerlink\" title=\"运行时数据区-Java虚拟机栈\"></a>运行时数据区-Java虚拟机栈</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Stack <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmaxSize <span class=\"keyword\">uint</span> <span class=\"comment\">//最多可以容纳多少帧</span></span><br><span class=\"line\">\tsize    <span class=\"keyword\">uint</span> <span class=\"comment\">//栈的当前大小</span></span><br><span class=\"line\">\t_top    *Frame <span class=\"comment\">//保存栈顶指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例一个栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newStack</span><span class=\"params\">(maxSize <span class=\"keyword\">uint</span>)</span> *<span class=\"title\">Stack</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Stack&#123;</span><br><span class=\"line\">\t\tmaxSize: maxSize,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//当前帧进栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Stack)</span> <span class=\"title\">push</span><span class=\"params\">(frame *Frame)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> self.size &gt;= self.maxSize &#123; <span class=\"comment\">//判断当前栈大小是否超过最大容量</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"java.lang.StackOverflowError\"</span>) </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> self._top != <span class=\"literal\">nil</span> &#123;  <span class=\"comment\">//当前栈顶不为空时</span></span><br><span class=\"line\">\t\tframe.lower = self._top <span class=\"comment\">//将插入帧尾指向栈顶指针</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tself._top = frame <span class=\"comment\">//当前栈顶指向当前帧</span></span><br><span class=\"line\">\tself.size++ <span class=\"comment\">//当前栈大小加1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//当前帧出栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Stack)</span> <span class=\"title\">pop</span><span class=\"params\">()</span> *<span class=\"title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> self._top == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">//当前栈顶为空时报错</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"jvm stack is empty!\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttop := self._top <span class=\"comment\">//取出当前栈顶帧</span></span><br><span class=\"line\">\tself._top = top.lower <span class=\"comment\">//将当前栈顶指向top的下一帧</span></span><br><span class=\"line\">\ttop.lower = <span class=\"literal\">nil</span> <span class=\"comment\">//断开top的尾指针</span></span><br><span class=\"line\">\tself.size-- <span class=\"comment\">//当前栈大小减1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> top <span class=\"comment\">//返回top</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取当前栈顶帧</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Stack)</span> <span class=\"title\">top</span><span class=\"params\">()</span> *<span class=\"title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> self._top == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">////当前栈顶为空时报错</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"jvm stack is empty!\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self._top <span class=\"comment\">//返回当前栈顶帧</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-帧\"><a href=\"#运行时数据区-帧\" class=\"headerlink\" title=\"运行时数据区-帧\"></a>运行时数据区-帧</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Frame <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tlower        *Frame <span class=\"comment\">//指向下一帧</span></span><br><span class=\"line\">\tlocalVars    LocalVars <span class=\"comment\">//保存局部变量表指针</span></span><br><span class=\"line\">\toperandStack *OperandStack <span class=\"comment\">//保存操作数栈指针</span></span><br><span class=\"line\">\t<span class=\"comment\">// todo</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实例化帧</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewFrame</span><span class=\"params\">(maxLocals, maxStack <span class=\"keyword\">uint</span>)</span> *<span class=\"title\">Frame</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Frame&#123;</span><br><span class=\"line\">\t\tlocalVars:    newLocalVars(maxLocals), <span class=\"comment\">//实例化局部变量对象</span></span><br><span class=\"line\">\t\toperandStack: newOperandStack(maxStack), <span class=\"comment\">//实例化操作数栈对象</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getters</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Frame)</span> <span class=\"title\">LocalVars</span><span class=\"params\">()</span> <span class=\"title\">LocalVars</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.localVars</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Frame)</span> <span class=\"title\">OperandStack</span><span class=\"params\">()</span> *<span class=\"title\">OperandStack</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.operandStack</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-局部变量表\"><a href=\"#运行时数据区-局部变量表\" class=\"headerlink\" title=\"运行时数据区-局部变量表\"></a>运行时数据区-局部变量表</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LocalVars []Slot</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建局部变量实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newLocalVars</span><span class=\"params\">(maxLocals <span class=\"keyword\">uint</span>)</span> <span class=\"title\">LocalVars</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> maxLocals &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">make</span>([]Slot, maxLocals) <span class=\"comment\">//申明大小为maxLocals的Slot数组</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置int类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">SetInt</span><span class=\"params\">(index <span class=\"keyword\">uint</span>, val <span class=\"keyword\">int32</span>)</span></span> &#123;</span><br><span class=\"line\">\tself[index].num = val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取int类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">GetInt</span><span class=\"params\">(index <span class=\"keyword\">uint</span>)</span> <span class=\"title\">int32</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self[index].num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置float32类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">SetFloat</span><span class=\"params\">(index <span class=\"keyword\">uint</span>, val <span class=\"keyword\">float32</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float32bits(val)<span class=\"comment\">//转为uint32</span></span><br><span class=\"line\">\tself[index].num = <span class=\"keyword\">int32</span>(bits) <span class=\"comment\">//转为int32</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取float32类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">GetFloat</span><span class=\"params\">(index <span class=\"keyword\">uint</span>)</span> <span class=\"title\">float32</span></span> &#123;</span><br><span class=\"line\">\tbits := <span class=\"keyword\">uint32</span>(self[index].num)<span class=\"comment\">//转为unit32</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Float32frombits(bits)<span class=\"comment\">//转为float</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置long类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">SetLong</span><span class=\"params\">(index <span class=\"keyword\">uint</span>, val <span class=\"keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\tself[index].num = <span class=\"keyword\">int32</span>(val)<span class=\"comment\">//取低位32位存储在index</span></span><br><span class=\"line\">\tself[index+<span class=\"number\">1</span>].num = <span class=\"keyword\">int32</span>(val &gt;&gt; <span class=\"number\">32</span>) <span class=\"comment\">//右移32位取高位32位存储在index+1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取long类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">GetLong</span><span class=\"params\">(index <span class=\"keyword\">uint</span>)</span> <span class=\"title\">int64</span></span> &#123;</span><br><span class=\"line\">\tlow := <span class=\"keyword\">uint32</span>(self[index].num) <span class=\"comment\">//取index低32位</span></span><br><span class=\"line\">\thigh := <span class=\"keyword\">uint32</span>(self[index+<span class=\"number\">1</span>].num) <span class=\"comment\">//取index+1高32位</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int64</span>(high)&lt;&lt;<span class=\"number\">32</span> | <span class=\"keyword\">int64</span>(low) <span class=\"comment\">//左移高位32位，拼接高低位返回</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置float64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">SetDouble</span><span class=\"params\">(index <span class=\"keyword\">uint</span>, val <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float64bits(val) <span class=\"comment\">//转为uint64</span></span><br><span class=\"line\">\tself.SetLong(index, <span class=\"keyword\">int64</span>(bits)) <span class=\"comment\">//用long型设置方法设置int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取float64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">GetDouble</span><span class=\"params\">(index <span class=\"keyword\">uint</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">\tbits := <span class=\"keyword\">uint64</span>(self.GetLong(index)) <span class=\"comment\">//按long型取值方法取出uint64</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Float64frombits(bits) <span class=\"comment\">//转为float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">SetRef</span><span class=\"params\">(index <span class=\"keyword\">uint</span>, ref *Object)</span></span> &#123;</span><br><span class=\"line\">\tself[index].ref = ref</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self LocalVars)</span> <span class=\"title\">GetRef</span><span class=\"params\">(index <span class=\"keyword\">uint</span>)</span> *<span class=\"title\">Object</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self[index].ref</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-操作数栈\"><a href=\"#运行时数据区-操作数栈\" class=\"headerlink\" title=\"运行时数据区-操作数栈\"></a>运行时数据区-操作数栈</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> OperandStack <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tsize  <span class=\"keyword\">uint</span> <span class=\"comment\">//记录栈顶位置</span></span><br><span class=\"line\">\tslots []Slot</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实例化操作数栈</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newOperandStack</span><span class=\"params\">(maxStack <span class=\"keyword\">uint</span>)</span> *<span class=\"title\">OperandStack</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> maxStack &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &amp;OperandStack&#123;</span><br><span class=\"line\">\t\t\tslots: <span class=\"built_in\">make</span>([]Slot, maxStack),<span class=\"comment\">//申明maxStack大小的Slot数组</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PushInt</span><span class=\"params\">(val <span class=\"keyword\">int32</span>)</span></span> &#123;</span><br><span class=\"line\">\tself.slots[self.size].num = val</span><br><span class=\"line\">\tself.size++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PopInt</span><span class=\"params\">()</span> <span class=\"title\">int32</span></span> &#123;</span><br><span class=\"line\">\tself.size--</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.slots[self.size].num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PushFloat</span><span class=\"params\">(val <span class=\"keyword\">float32</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float32bits(val)</span><br><span class=\"line\">\tself.slots[self.size].num = <span class=\"keyword\">int32</span>(bits)</span><br><span class=\"line\">\tself.size++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PopFloat</span><span class=\"params\">()</span> <span class=\"title\">float32</span></span> &#123;</span><br><span class=\"line\">\tself.size--</span><br><span class=\"line\">\tbits := <span class=\"keyword\">uint32</span>(self.slots[self.size].num)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Float32frombits(bits)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// long consumes two slots</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PushLong</span><span class=\"params\">(val <span class=\"keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">\tself.slots[self.size].num = <span class=\"keyword\">int32</span>(val)</span><br><span class=\"line\">\tself.slots[self.size+<span class=\"number\">1</span>].num = <span class=\"keyword\">int32</span>(val &gt;&gt; <span class=\"number\">32</span>)</span><br><span class=\"line\">\tself.size += <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PopLong</span><span class=\"params\">()</span> <span class=\"title\">int64</span></span> &#123;</span><br><span class=\"line\">\tself.size -= <span class=\"number\">2</span></span><br><span class=\"line\">\tlow := <span class=\"keyword\">uint32</span>(self.slots[self.size].num)</span><br><span class=\"line\">\thigh := <span class=\"keyword\">uint32</span>(self.slots[self.size+<span class=\"number\">1</span>].num)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">int64</span>(high)&lt;&lt;<span class=\"number\">32</span> | <span class=\"keyword\">int64</span>(low)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// double consumes two slots</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PushDouble</span><span class=\"params\">(val <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tbits := math.Float64bits(val)</span><br><span class=\"line\">\tself.PushLong(<span class=\"keyword\">int64</span>(bits))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PopDouble</span><span class=\"params\">()</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">\tbits := <span class=\"keyword\">uint64</span>(self.PopLong())</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Float64frombits(bits)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PushRef</span><span class=\"params\">(ref *Object)</span></span> &#123;</span><br><span class=\"line\">\tself.slots[self.size].ref = ref</span><br><span class=\"line\">\tself.size++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *OperandStack)</span> <span class=\"title\">PopRef</span><span class=\"params\">()</span> *<span class=\"title\">Object</span></span> &#123;</span><br><span class=\"line\">\tself.size--</span><br><span class=\"line\">\tref := self.slots[self.size].ref</span><br><span class=\"line\">\tself.slots[self.size].ref = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ref</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行时数据区-操作数栈-1\"><a href=\"#运行时数据区-操作数栈-1\" class=\"headerlink\" title=\"运行时数据区-操作数栈\"></a>运行时数据区-操作数栈</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Spring Boot","date":"2020-01-29T12:57:11.000Z","_content":"\n## 容器\n\n### IOC\n<!-- more -->\nspring-context\n\n- @Configuration\n\n  告诉Spring这是一个配置类\n\n- @Bean\n\n  给容器中注册一个Bean，类型为返回值的类型，id默认是用方法\n  默认都是单例\n\n- AnnotationConfigApplicationContext\n- @ComponetScan、@ComponetScans\n\n  value：扫描@Service @Controller @Repositroy @Componet\n  excludeFlters：排除的规则\n  includeFilters：只需要包含的规则\n\n\t- FilterType.ANNOTATION\n\n\t  按照注解\n\n\t- FilterType.ASSIGNABLE_TYPE\n\n\t  按照给定类型\n\n\t- FilterType.ASPECTJ\n\n\t  使用ASPECTJ表达式\n\n\t- FilterType.REGEX\n\n\t  使用正则指定\n\n\t- FilterType.CUSTOM\n\n\t  自定义规则，必须实现TypeFilter类\n\n- @Scope\n\n\t- SCOPE_PROTOTPE\n\n\t  多实例\n\t  IOC容器启动不回去调用方法床架你对象，获取的时候创建对象\n\n\t- SCOPE_SINGLETON\n\n\t  单实例（默认值）\n\t  IOC容器启动会调用方法创建对象放到IOC容器中\n\n\t- SCOPE_REQUEST\n\n\t  同一次请求创建一个实例\n\n\t- SCOPE_SESSION\n\n\t  同一个Session创建一个实例\n\n- @Lazy \n\n  懒加载：容器启动不创建对象。第一次使用（获取）Bean对象时调用创建对象放入容器\n\n- @Conditional\n\n  按照一定的条件进行判断，满足条件给容器中注册Bean\n  需要实现Condition 接口：ConditionContext 判断条件能使用的上下文；AnnotatedTypeMetadate 注释信息\n\n- @Import\n\n  导入组件，id默认是组件的全类名（com.xxx.xxx.xx）\n\n\t- ImportSelector\n\n\t  自定义逻辑返回需要导入的组件。\n\t  返回值就是导入到容器中的组件全类名，方法不要返回null。\n\t  AnnotationMetadata 当前标注@Import注解的类的所有注释信息。\n\n\t- ImportBeanDefinitionRegistrar\n\n\t  BeanDefinitionRegistry：BeanDefinition注册类。\n\t  调用registerBeanDefinition手工注册Bean\n\n- FactoryBean\n\n  实现FactoryBean接口\n  1.工厂Bean获取的是调用getObject创建的对象\n  2.要获取工程Bean本身，需要给id前面加一个&\n\n### bean的生命周期\n\n- 初始化\n\n\t- @Bean(initMethod)\n\t- InitializingBean\n\n\t  通过让Bean实现该接口，实现Bean初始化逻辑\n\n\t- @PostConstruct\n\t- BeanPostProcessor\n\n\t  Bean后置处理器，在Bean初始化前后进行一些处理工作\n\n\t\t- postProcessBeforeInitialization\n\n\t\t  在初始化之前\n\n\t\t- postProcessAfterInitialization\n\n\t\t  在初始化工作之后\n\n\t\t- ApplicationContextAwareProcessor\n\n\t\t  实现该接口，Spring容器可以将当前容器传给实现类\n\n\t\t- InitDestroyAnnotationBeanPostProcessor\n\n\t\t  处理@PostConstruct，@PreDestory注解\n\n\t\t- AutowiredAnnotationBeanPostProcessor\n\n\t\t  处理@Autowired注解\n\n- 销毁\n\n\t- @Bean(destroyMethod)\n\n\t  多实例的bean，容器不会调用销毁方法\n\n\t- DisposableBean\n\n\t  通过实现该接口，实现销毁逻辑\n\n\t- @PreDestory\n\n### 属性赋值\n\n- @Value\n\n\t- 基本数值\n\t- SpEL  #{}\n\t- 配置文件 ${}\n\n\t  @PropertySource 读取外部配置文件，保存至环境变量中\n\n### 自动装配\n\n- @Autowired\n\n  1.默认按照类型在容器中找相应的组件\n  2.如果找到多个相同类型的组件，再将属性的名称作为组件的id组容易中寻找\n  3.使用@Qualifier指定需要装配的组件的id\n  4.自动装配默认一定要指定存在的属性（如果不强制指定，使用require=false）\n  5.@Primary,让Spring进行自动装配的时候，默认是用首选的bean\n\n\t- 构造器\n\n\t  构造器用到的自定义类型的值从IOC容器中获取\n\t  如果组建只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以从容器中获取\n\n\t- 方法\n\n\t  标注在方法，Spring容器创建当前对象，就会调用方法完成赋值\n\t  方法使用的参数，自定义类型的值从IOC容器中获取\n\n\t- 属性\n\n\t  值从IOC容器中获取\n\n- @Resource\n\n  可以和@Autowired一样实现自动装配，默认按照属性名称进行装配\n  没有支持@Primary功能，reqiured=false\n\n- @Inject\n\n  需要依赖javax.inject包，和Autowired一样，没有reqiured=false\n\n- 实现xxxAware接口\n\n  在创建对象的时候，会调用接口的回调方法\n  把Spring底层的组件注册到自定义的Bean中\n  xxxAware功能使用xxxProcessor处理的\n\n\t- ApplicationContextAware\n\n\t  获取ApplicationContext\n\n\t- BeanNameAware\n\t- EmbeddedValueResolverAware\n\n- Profile\n\n  加了环境表示的bean，只有这个环境被激活的时候才能注册到容器中，默认是default环境\n\n\t- 启动参数\n\n\t  -Dspring.profiles.active=xxx\n\n\t- 代码\n\n\t  1.创建一个aplicationContext\n\t  2.设置需要激活的环境.getEnvironment().setActiveProfiles()\n\t  3.注册朱配置类  .register()\n\t  4.启动刷新容器 .refresh()\n\n### AOP\n\n在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式\nspring-aspects\n容器中保存了组建的代理对象(cglib增强后的对象),这个对象里面保存了详细信息(比如增强器，目标对象)\n\n- @Before\n\n  在目标方法之前切入：切入点表达式（指定在那个方法切入）\n\n- @After\n\n  在目标方法之后切入：切入点表达式\n\n- @PointCut\n\n  切入点表达式\n\n- @AfterReturning\n\n  再放标方法正常返回之后运行\n\n- @AfterThrowing\n\n  在目标方法出现异常之后运行\n\n- @Aspect\n\n  告诉Spring当前类是一个切面类\n\n- @EnableAspectJAutoProxy\n\n  开启基于注解的AOP\n  1.给容器中导入AspectJAutoProxyRegistrar，给容器中注册一个AnnotationAwareAspectJAutoProxyCreator\n\n\t- AnnotationAwareAspectJAutoProxyCreator\n\n\t\t- AspectJAwareAdvisorAutoProxyCreator\n\n\t\t\t- AbstractAdvisorAutoProxyCreator\n\n\t\t\t\t- AbstractAutoProxyCreator\n\n\t\t\t\t\t- SmartInstantiationAwareBeanPostProcessor\n\t\t\t\t\t- BeanFactroyAware\n\n- JoinPoint\n\n  JoinPoint一定要出现在参数表的第一位\n\n- 目标方法执行\n\n  1.CglibAopProxy.intercept()。拦截目标方法的执行。\n  2.根据PoxyFactory对象获取将要执行的目标方法拦截器链\n  \ta)如果没有拦截器链，直接执行目标方法\n  \tb)如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息出入创建一个CglibMethodInvocation，并调用proceed()方法\n  \tc)拦截器链触发过程\n  \t\t1.如果没有拦截器执行目标方法，或者懒机器的索引和拦截器数组-1大小一样(指定到了最后一个拦截器)，执行目标方法。\n\n### 声明式事务\n\n1.导入相关依赖spring-jdbc\n2.配置数据源 JdbcTmplate\n3.给方法标注@Transactional\n4.@EnableTransactionManagement 开启基于注解的事物\n5.配置事物管理器管理事物\n\n- @Transactional\n- @EnableTransactionManagement\n\n\t- TransactionManagementConfigurationSelection\n\n\t  给容器中导入组件\n\n\t\t- AutoProxyRegistrar\n\n\t\t  给容器中注册InfrastructureAdvisorAutoProxyCreator组件\n\n\t\t\t- InfrastructureAdvisorAutoProxyCreator\n\n\t\t\t  利用后置处理器机制在对象创建后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行方法\n\n\t\t- ProxyTransactionManagementConfiguration\n\n\t\t  1.给容器中注册事物增强器\n\t\t  \t事物增强器要用事物注解信息\n\t\t  \t事物拦截器，保存了事物的属性信息，事物管理器，是一个MethodInterceptor，在目标方法执行时执行拦截器链\n\n## 扩展原理\n\n### BeanFactoryPostProcessor\n\nBeanFactory后置处理器\n\t在BeanFactory标准初始化之后调用，所有的bean定义以保存在遭到beanFactory，但是bean还未创建\n\n- BeanDefinitionRegistryPostProcessor\n\n  在所有bean定义信息将要被加载，bean实力还未被创建时执行\n\n### ApplicationListener\n\n监听容器中发布的事件\n\t1.写一个监听器，ApplicationListener实现类，来监听某个事件ApplicationEvent机器子类\n\t2.把监听器加入到容器\n\t3.只要容器中有相关事件的腹部，我们就能监听到这个事件：\n\t\tContextRefreshedEvent：容器舒心完成(所有bean都完全创建)会发布这个事件；\n\t\tContextClosedEvent：关闭容器会发布这个事件\n\t4.发布一个事件，applicationContext.publishEvent()\n\n### 容器的创建\n\n1.Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息\n\txml\n\t注解\n2.Spring容器会合适的时机创建这些Bean\n\t用到这个bean的时候，利用getBean创建bean，创建好以后保存在容器中\n\t统一创建剩下所有的bean的时候，finshBeanFactoryInitialization()\n3.后置处理器\n\t每个bean创建完成，都会使用各种后置处理器，来增强bean的功能\n4.事件驱动模型\n\tApplicationListener，事件监听\n事件派发，ApplicationEvenMulticator\n\n- refresh()\n\n\t- prepareRefresh()\n\n\t  刷新预处理工作:\n\t  清缓存\n\t  置状态\n\n\t\t- initPropertySources()\n\n\t\t  初始化属性设置，子类自定义个性化的属性设置方法。\n\n\t\t- getEnvironment().validateRequiredProperties()\n\n\t\t  检验属性的合法\n\n\t\t- earlyApplicationEvents\n\n\t\t  保存容器中的一起早起事件\n\n\t- obtainFreshBeanFactory()\n\n\t  获取BeanFactory\n\n\t\t- refreshBeanFactory()\n\n\t\t  刷新BeanFactory工厂，创建BeanFactory对象。\n\n\t\t- getBeanFactory()【DefaultListableBeanFactory】\n\n\t\t  获取之前创建好的BeanFactory\n\n\t\t- prepareBeanFactory()\n\n\t\t  BeanFactory的预准备工作（BeanFactory进行一些设置）\n\t\t  1.设置BeanFactory的类加载器，支持表达式解析器。。。\n\t\t  2.添加部分BeanPostProcessor【ApplicationContextAwareProcessor】\n\t\t  3.设置忽略的自动装配的接口，EnvironmentAware、EmbeddedValueResolverAware。。。\n\t\t  4.注册可以解析的自动装配，我们能直接在仍和组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext\n\t\t  5.添加BeanPostProcessor【ApplicationListenerDetector】\n\t\t  6.添加编译是的AspectJ支持\n\t\t  7.给BeanFactory中注册一些能用的组件：environment【ConfigurableEnvironment】、systemProperties【Map】\n\n\t\t- postProcessBeanFactory()\n\n\t\t  BeanFactory准备完成后的后置处理工作，子类用过重写这个发方法来在BeanFactory初始化完成后进行更进一步的工作\n\n\t\t- invokeBeanFactoryPostProcessors()\n\n\t\t  执行BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后执行\n\t\t  \n\t\t  执行BeanFactoryPostProcessor的方法：\n\t\t  1.先执行BeanDefinitonRegistryPostProcessor\n\t\t  \t获取所有的BeanDefinitonRegistryPostProcessor\n\t\t  \t先执行实现了PriorityOrdered接口的\n\t\t  \t再执行实现了Ordered接口的\n\t\t  \t最后执行剩下的\n\t\t  2.再执行BeanFactoryPostProcessor的方法\n\t\t  \t先执行实现了PriorityOrdered接口的\n\t\t  \t再执行实现了Ordered接口的\n\t\t  \t最后执行剩下的\n\n\t- registerBeanPostProcessors()\n\n\t  注册BeanPostProcessor，Bean的后置处理器。\n\t  1.获取所有的BeanPostProcessor，不同接口类型的BeanPostProcessor，在Bean船舰前后的执行实际是不一样的。\n\t  \tBeanPostProcessor\n\t  \tDestructionAwareBeanPostProcessor\n\t  \tInstantiationAwareBeanPostProcessor\n\t  \tSmartInstantiationAwareBeanPostProcessor\n\t  \tMergedBeanDefinitionPostProcessor\n\n\t- initMessageSource()\n\n\t  初始化MessageSource组件（做国际化功能，消息绑定、解析）\n\t  1.获取BeanFactory\n\t  2.看容器中是否有id为messageSource的组件\n\t  \t如果有赋值给messageSource，如果没有自己创建【DelegatingMessageSource】\n\t  3.把创建好的MessageSource注册在容器中\n\n\t- initApplicationEventMulticaster()\n\n\t  初始化事件派发器\n\t  1.从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster\n\t  2.如果没有配置，创建SimpleApplicationEventMulticaster\n\t  3.注册到容器中\n\n\t- onRefresh()\n\n\t  留给子容器的（子类）\n\t  1.子类重写这个方法，在容器刷新的时候可以自定义逻辑\n\n\t- registerLiseners()\n\n\t  给容器中将所有的项目的ApplicationListener注册进来。\n\t  1.从容器中拿到所有ApplicationListener组件\n\t  2.将每个监听器添加到事件派发器中\n\t  3.派发之前步骤产生的事件\n\n\t- finishBeanFactoryInitialization()\n\n\t  初始化剩下的所有单实例bean\n\n\t\t- beanFactory.preInstantiateSingletons()\n\n\t\t  初始化剩下的单实例bean\n\t\t  1.获取容器中所有的Bean定义\n\t\t  2.拿到Bean的定义信息\n\t\t  3.Bean不是抽象的，是单实例的，不是懒加载的\n\t\t  \t1.判断是否是FactoryBean，是否是实现FactoryBean接口的Bean\n\t\t  \t2.不是FactoryBean，用getBean创建对象\n\t\t  \t3.doGetBean()\n\t\t  \t4.先获取缓存中保存的单实例Bean。如果获取到，说明这个Bean之前被创建国（所有创建国的单实例Bean都是会被缓存起来的）\n\t\t  \t5.换种种获取不到，开始Bean的创建对象流程\n\t\t  \t6.标记当前bean已经被创建\n\t\t  \t7.获取Bean的定义信息\n\t\t  \t8.获取当前Bean依赖的其他Bean，如果有就按照getBean()把以来的Bean先创建出来。\n\t\t  \t9.启动单实例Bean的创建流程\n\t\t  \t\t1.createBean()\n\t\t  \t\t2.resolveBeforeInstantiation()让BeanPostProcessor先拦截返回代理对象【InstantiationAwareBeanPostProcessors】提前执行\n\t\t  \t\t3.如果前面的InstantiationAwareBeanPostProcessors没有返回代理对象\n\t\t  \t\t4.doCreateBean()创建Bean\n\t\t  \t\t\t1.创建Bean实例，createBeanInstance()利用工厂方法或者对象的构造器创建出Bean实例\n\t\t  \t\t\t2.applyMergedBeanDefinitionPostProcessors()，调用【MergedBeanDefinitionPostProcessors】\n\t\t  \t\t\t3.populateBean() Bean属性赋值\n\n\t- finishRefresh()\n\n\t  完成BeanFactory的初始化创建工作，IOC容器就创建完成\n\n\t\t- initLifecycleProcessor()\n\n\t\t  初始化和生命周期有关的后置处理器：LifecycleProcessor。\n\t\t  写一个LifecycleProcessor的实现类，可以在BeanFactory的onRefresh(),onClose()进行拦截\n\n\t\t- getLifecycleProcessor().onRefresh()\n\n\t\t  拿到前面定义的生命周期处理器，回调onRefresh()\n\n\t\t- publishEvent()\n\n\t\t  发布容器完成事件","source":"_posts/Spring-Boot.md","raw":"---\ntitle: Spring Boot\ndate: 2020-01-29 20:57:11\ntags:\n    - Java\n    - Springboot\ncategories:\n    - Technology\n---\n\n## 容器\n\n### IOC\n<!-- more -->\nspring-context\n\n- @Configuration\n\n  告诉Spring这是一个配置类\n\n- @Bean\n\n  给容器中注册一个Bean，类型为返回值的类型，id默认是用方法\n  默认都是单例\n\n- AnnotationConfigApplicationContext\n- @ComponetScan、@ComponetScans\n\n  value：扫描@Service @Controller @Repositroy @Componet\n  excludeFlters：排除的规则\n  includeFilters：只需要包含的规则\n\n\t- FilterType.ANNOTATION\n\n\t  按照注解\n\n\t- FilterType.ASSIGNABLE_TYPE\n\n\t  按照给定类型\n\n\t- FilterType.ASPECTJ\n\n\t  使用ASPECTJ表达式\n\n\t- FilterType.REGEX\n\n\t  使用正则指定\n\n\t- FilterType.CUSTOM\n\n\t  自定义规则，必须实现TypeFilter类\n\n- @Scope\n\n\t- SCOPE_PROTOTPE\n\n\t  多实例\n\t  IOC容器启动不回去调用方法床架你对象，获取的时候创建对象\n\n\t- SCOPE_SINGLETON\n\n\t  单实例（默认值）\n\t  IOC容器启动会调用方法创建对象放到IOC容器中\n\n\t- SCOPE_REQUEST\n\n\t  同一次请求创建一个实例\n\n\t- SCOPE_SESSION\n\n\t  同一个Session创建一个实例\n\n- @Lazy \n\n  懒加载：容器启动不创建对象。第一次使用（获取）Bean对象时调用创建对象放入容器\n\n- @Conditional\n\n  按照一定的条件进行判断，满足条件给容器中注册Bean\n  需要实现Condition 接口：ConditionContext 判断条件能使用的上下文；AnnotatedTypeMetadate 注释信息\n\n- @Import\n\n  导入组件，id默认是组件的全类名（com.xxx.xxx.xx）\n\n\t- ImportSelector\n\n\t  自定义逻辑返回需要导入的组件。\n\t  返回值就是导入到容器中的组件全类名，方法不要返回null。\n\t  AnnotationMetadata 当前标注@Import注解的类的所有注释信息。\n\n\t- ImportBeanDefinitionRegistrar\n\n\t  BeanDefinitionRegistry：BeanDefinition注册类。\n\t  调用registerBeanDefinition手工注册Bean\n\n- FactoryBean\n\n  实现FactoryBean接口\n  1.工厂Bean获取的是调用getObject创建的对象\n  2.要获取工程Bean本身，需要给id前面加一个&\n\n### bean的生命周期\n\n- 初始化\n\n\t- @Bean(initMethod)\n\t- InitializingBean\n\n\t  通过让Bean实现该接口，实现Bean初始化逻辑\n\n\t- @PostConstruct\n\t- BeanPostProcessor\n\n\t  Bean后置处理器，在Bean初始化前后进行一些处理工作\n\n\t\t- postProcessBeforeInitialization\n\n\t\t  在初始化之前\n\n\t\t- postProcessAfterInitialization\n\n\t\t  在初始化工作之后\n\n\t\t- ApplicationContextAwareProcessor\n\n\t\t  实现该接口，Spring容器可以将当前容器传给实现类\n\n\t\t- InitDestroyAnnotationBeanPostProcessor\n\n\t\t  处理@PostConstruct，@PreDestory注解\n\n\t\t- AutowiredAnnotationBeanPostProcessor\n\n\t\t  处理@Autowired注解\n\n- 销毁\n\n\t- @Bean(destroyMethod)\n\n\t  多实例的bean，容器不会调用销毁方法\n\n\t- DisposableBean\n\n\t  通过实现该接口，实现销毁逻辑\n\n\t- @PreDestory\n\n### 属性赋值\n\n- @Value\n\n\t- 基本数值\n\t- SpEL  #{}\n\t- 配置文件 ${}\n\n\t  @PropertySource 读取外部配置文件，保存至环境变量中\n\n### 自动装配\n\n- @Autowired\n\n  1.默认按照类型在容器中找相应的组件\n  2.如果找到多个相同类型的组件，再将属性的名称作为组件的id组容易中寻找\n  3.使用@Qualifier指定需要装配的组件的id\n  4.自动装配默认一定要指定存在的属性（如果不强制指定，使用require=false）\n  5.@Primary,让Spring进行自动装配的时候，默认是用首选的bean\n\n\t- 构造器\n\n\t  构造器用到的自定义类型的值从IOC容器中获取\n\t  如果组建只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以从容器中获取\n\n\t- 方法\n\n\t  标注在方法，Spring容器创建当前对象，就会调用方法完成赋值\n\t  方法使用的参数，自定义类型的值从IOC容器中获取\n\n\t- 属性\n\n\t  值从IOC容器中获取\n\n- @Resource\n\n  可以和@Autowired一样实现自动装配，默认按照属性名称进行装配\n  没有支持@Primary功能，reqiured=false\n\n- @Inject\n\n  需要依赖javax.inject包，和Autowired一样，没有reqiured=false\n\n- 实现xxxAware接口\n\n  在创建对象的时候，会调用接口的回调方法\n  把Spring底层的组件注册到自定义的Bean中\n  xxxAware功能使用xxxProcessor处理的\n\n\t- ApplicationContextAware\n\n\t  获取ApplicationContext\n\n\t- BeanNameAware\n\t- EmbeddedValueResolverAware\n\n- Profile\n\n  加了环境表示的bean，只有这个环境被激活的时候才能注册到容器中，默认是default环境\n\n\t- 启动参数\n\n\t  -Dspring.profiles.active=xxx\n\n\t- 代码\n\n\t  1.创建一个aplicationContext\n\t  2.设置需要激活的环境.getEnvironment().setActiveProfiles()\n\t  3.注册朱配置类  .register()\n\t  4.启动刷新容器 .refresh()\n\n### AOP\n\n在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式\nspring-aspects\n容器中保存了组建的代理对象(cglib增强后的对象),这个对象里面保存了详细信息(比如增强器，目标对象)\n\n- @Before\n\n  在目标方法之前切入：切入点表达式（指定在那个方法切入）\n\n- @After\n\n  在目标方法之后切入：切入点表达式\n\n- @PointCut\n\n  切入点表达式\n\n- @AfterReturning\n\n  再放标方法正常返回之后运行\n\n- @AfterThrowing\n\n  在目标方法出现异常之后运行\n\n- @Aspect\n\n  告诉Spring当前类是一个切面类\n\n- @EnableAspectJAutoProxy\n\n  开启基于注解的AOP\n  1.给容器中导入AspectJAutoProxyRegistrar，给容器中注册一个AnnotationAwareAspectJAutoProxyCreator\n\n\t- AnnotationAwareAspectJAutoProxyCreator\n\n\t\t- AspectJAwareAdvisorAutoProxyCreator\n\n\t\t\t- AbstractAdvisorAutoProxyCreator\n\n\t\t\t\t- AbstractAutoProxyCreator\n\n\t\t\t\t\t- SmartInstantiationAwareBeanPostProcessor\n\t\t\t\t\t- BeanFactroyAware\n\n- JoinPoint\n\n  JoinPoint一定要出现在参数表的第一位\n\n- 目标方法执行\n\n  1.CglibAopProxy.intercept()。拦截目标方法的执行。\n  2.根据PoxyFactory对象获取将要执行的目标方法拦截器链\n  \ta)如果没有拦截器链，直接执行目标方法\n  \tb)如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息出入创建一个CglibMethodInvocation，并调用proceed()方法\n  \tc)拦截器链触发过程\n  \t\t1.如果没有拦截器执行目标方法，或者懒机器的索引和拦截器数组-1大小一样(指定到了最后一个拦截器)，执行目标方法。\n\n### 声明式事务\n\n1.导入相关依赖spring-jdbc\n2.配置数据源 JdbcTmplate\n3.给方法标注@Transactional\n4.@EnableTransactionManagement 开启基于注解的事物\n5.配置事物管理器管理事物\n\n- @Transactional\n- @EnableTransactionManagement\n\n\t- TransactionManagementConfigurationSelection\n\n\t  给容器中导入组件\n\n\t\t- AutoProxyRegistrar\n\n\t\t  给容器中注册InfrastructureAdvisorAutoProxyCreator组件\n\n\t\t\t- InfrastructureAdvisorAutoProxyCreator\n\n\t\t\t  利用后置处理器机制在对象创建后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行方法\n\n\t\t- ProxyTransactionManagementConfiguration\n\n\t\t  1.给容器中注册事物增强器\n\t\t  \t事物增强器要用事物注解信息\n\t\t  \t事物拦截器，保存了事物的属性信息，事物管理器，是一个MethodInterceptor，在目标方法执行时执行拦截器链\n\n## 扩展原理\n\n### BeanFactoryPostProcessor\n\nBeanFactory后置处理器\n\t在BeanFactory标准初始化之后调用，所有的bean定义以保存在遭到beanFactory，但是bean还未创建\n\n- BeanDefinitionRegistryPostProcessor\n\n  在所有bean定义信息将要被加载，bean实力还未被创建时执行\n\n### ApplicationListener\n\n监听容器中发布的事件\n\t1.写一个监听器，ApplicationListener实现类，来监听某个事件ApplicationEvent机器子类\n\t2.把监听器加入到容器\n\t3.只要容器中有相关事件的腹部，我们就能监听到这个事件：\n\t\tContextRefreshedEvent：容器舒心完成(所有bean都完全创建)会发布这个事件；\n\t\tContextClosedEvent：关闭容器会发布这个事件\n\t4.发布一个事件，applicationContext.publishEvent()\n\n### 容器的创建\n\n1.Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息\n\txml\n\t注解\n2.Spring容器会合适的时机创建这些Bean\n\t用到这个bean的时候，利用getBean创建bean，创建好以后保存在容器中\n\t统一创建剩下所有的bean的时候，finshBeanFactoryInitialization()\n3.后置处理器\n\t每个bean创建完成，都会使用各种后置处理器，来增强bean的功能\n4.事件驱动模型\n\tApplicationListener，事件监听\n事件派发，ApplicationEvenMulticator\n\n- refresh()\n\n\t- prepareRefresh()\n\n\t  刷新预处理工作:\n\t  清缓存\n\t  置状态\n\n\t\t- initPropertySources()\n\n\t\t  初始化属性设置，子类自定义个性化的属性设置方法。\n\n\t\t- getEnvironment().validateRequiredProperties()\n\n\t\t  检验属性的合法\n\n\t\t- earlyApplicationEvents\n\n\t\t  保存容器中的一起早起事件\n\n\t- obtainFreshBeanFactory()\n\n\t  获取BeanFactory\n\n\t\t- refreshBeanFactory()\n\n\t\t  刷新BeanFactory工厂，创建BeanFactory对象。\n\n\t\t- getBeanFactory()【DefaultListableBeanFactory】\n\n\t\t  获取之前创建好的BeanFactory\n\n\t\t- prepareBeanFactory()\n\n\t\t  BeanFactory的预准备工作（BeanFactory进行一些设置）\n\t\t  1.设置BeanFactory的类加载器，支持表达式解析器。。。\n\t\t  2.添加部分BeanPostProcessor【ApplicationContextAwareProcessor】\n\t\t  3.设置忽略的自动装配的接口，EnvironmentAware、EmbeddedValueResolverAware。。。\n\t\t  4.注册可以解析的自动装配，我们能直接在仍和组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext\n\t\t  5.添加BeanPostProcessor【ApplicationListenerDetector】\n\t\t  6.添加编译是的AspectJ支持\n\t\t  7.给BeanFactory中注册一些能用的组件：environment【ConfigurableEnvironment】、systemProperties【Map】\n\n\t\t- postProcessBeanFactory()\n\n\t\t  BeanFactory准备完成后的后置处理工作，子类用过重写这个发方法来在BeanFactory初始化完成后进行更进一步的工作\n\n\t\t- invokeBeanFactoryPostProcessors()\n\n\t\t  执行BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后执行\n\t\t  \n\t\t  执行BeanFactoryPostProcessor的方法：\n\t\t  1.先执行BeanDefinitonRegistryPostProcessor\n\t\t  \t获取所有的BeanDefinitonRegistryPostProcessor\n\t\t  \t先执行实现了PriorityOrdered接口的\n\t\t  \t再执行实现了Ordered接口的\n\t\t  \t最后执行剩下的\n\t\t  2.再执行BeanFactoryPostProcessor的方法\n\t\t  \t先执行实现了PriorityOrdered接口的\n\t\t  \t再执行实现了Ordered接口的\n\t\t  \t最后执行剩下的\n\n\t- registerBeanPostProcessors()\n\n\t  注册BeanPostProcessor，Bean的后置处理器。\n\t  1.获取所有的BeanPostProcessor，不同接口类型的BeanPostProcessor，在Bean船舰前后的执行实际是不一样的。\n\t  \tBeanPostProcessor\n\t  \tDestructionAwareBeanPostProcessor\n\t  \tInstantiationAwareBeanPostProcessor\n\t  \tSmartInstantiationAwareBeanPostProcessor\n\t  \tMergedBeanDefinitionPostProcessor\n\n\t- initMessageSource()\n\n\t  初始化MessageSource组件（做国际化功能，消息绑定、解析）\n\t  1.获取BeanFactory\n\t  2.看容器中是否有id为messageSource的组件\n\t  \t如果有赋值给messageSource，如果没有自己创建【DelegatingMessageSource】\n\t  3.把创建好的MessageSource注册在容器中\n\n\t- initApplicationEventMulticaster()\n\n\t  初始化事件派发器\n\t  1.从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster\n\t  2.如果没有配置，创建SimpleApplicationEventMulticaster\n\t  3.注册到容器中\n\n\t- onRefresh()\n\n\t  留给子容器的（子类）\n\t  1.子类重写这个方法，在容器刷新的时候可以自定义逻辑\n\n\t- registerLiseners()\n\n\t  给容器中将所有的项目的ApplicationListener注册进来。\n\t  1.从容器中拿到所有ApplicationListener组件\n\t  2.将每个监听器添加到事件派发器中\n\t  3.派发之前步骤产生的事件\n\n\t- finishBeanFactoryInitialization()\n\n\t  初始化剩下的所有单实例bean\n\n\t\t- beanFactory.preInstantiateSingletons()\n\n\t\t  初始化剩下的单实例bean\n\t\t  1.获取容器中所有的Bean定义\n\t\t  2.拿到Bean的定义信息\n\t\t  3.Bean不是抽象的，是单实例的，不是懒加载的\n\t\t  \t1.判断是否是FactoryBean，是否是实现FactoryBean接口的Bean\n\t\t  \t2.不是FactoryBean，用getBean创建对象\n\t\t  \t3.doGetBean()\n\t\t  \t4.先获取缓存中保存的单实例Bean。如果获取到，说明这个Bean之前被创建国（所有创建国的单实例Bean都是会被缓存起来的）\n\t\t  \t5.换种种获取不到，开始Bean的创建对象流程\n\t\t  \t6.标记当前bean已经被创建\n\t\t  \t7.获取Bean的定义信息\n\t\t  \t8.获取当前Bean依赖的其他Bean，如果有就按照getBean()把以来的Bean先创建出来。\n\t\t  \t9.启动单实例Bean的创建流程\n\t\t  \t\t1.createBean()\n\t\t  \t\t2.resolveBeforeInstantiation()让BeanPostProcessor先拦截返回代理对象【InstantiationAwareBeanPostProcessors】提前执行\n\t\t  \t\t3.如果前面的InstantiationAwareBeanPostProcessors没有返回代理对象\n\t\t  \t\t4.doCreateBean()创建Bean\n\t\t  \t\t\t1.创建Bean实例，createBeanInstance()利用工厂方法或者对象的构造器创建出Bean实例\n\t\t  \t\t\t2.applyMergedBeanDefinitionPostProcessors()，调用【MergedBeanDefinitionPostProcessors】\n\t\t  \t\t\t3.populateBean() Bean属性赋值\n\n\t- finishRefresh()\n\n\t  完成BeanFactory的初始化创建工作，IOC容器就创建完成\n\n\t\t- initLifecycleProcessor()\n\n\t\t  初始化和生命周期有关的后置处理器：LifecycleProcessor。\n\t\t  写一个LifecycleProcessor的实现类，可以在BeanFactory的onRefresh(),onClose()进行拦截\n\n\t\t- getLifecycleProcessor().onRefresh()\n\n\t\t  拿到前面定义的生命周期处理器，回调onRefresh()\n\n\t\t- publishEvent()\n\n\t\t  发布容器完成事件","slug":"Spring-Boot","published":1,"updated":"2020-01-31T07:06:25.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jeiu0020isnysiaoimzc","content":"<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h3 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h3><a id=\"more\"></a>\n<p>spring-context</p>\n<ul>\n<li><p>@Configuration</p>\n<p>告诉Spring这是一个配置类</p>\n</li>\n<li><p>@Bean</p>\n<p>给容器中注册一个Bean，类型为返回值的类型，id默认是用方法<br>默认都是单例</p>\n</li>\n<li><p>AnnotationConfigApplicationContext</p>\n</li>\n<li><p>@ComponetScan、@ComponetScans</p>\n<p>value：扫描@Service @Controller @Repositroy @Componet<br>excludeFlters：排除的规则<br>includeFilters：只需要包含的规则</p>\n<ul>\n<li><p>FilterType.ANNOTATION</p>\n<p>按照注解</p>\n</li>\n<li><p>FilterType.ASSIGNABLE_TYPE</p>\n<p>按照给定类型</p>\n</li>\n<li><p>FilterType.ASPECTJ</p>\n<p>使用ASPECTJ表达式</p>\n</li>\n<li><p>FilterType.REGEX</p>\n<p>使用正则指定</p>\n</li>\n<li><p>FilterType.CUSTOM</p>\n<p>自定义规则，必须实现TypeFilter类</p>\n</li>\n</ul>\n</li>\n<li><p>@Scope</p>\n<ul>\n<li><p>SCOPE_PROTOTPE</p>\n<p>多实例<br>IOC容器启动不回去调用方法床架你对象，获取的时候创建对象</p>\n</li>\n<li><p>SCOPE_SINGLETON</p>\n<p>单实例（默认值）<br>IOC容器启动会调用方法创建对象放到IOC容器中</p>\n</li>\n<li><p>SCOPE_REQUEST</p>\n<p>同一次请求创建一个实例</p>\n</li>\n<li><p>SCOPE_SESSION</p>\n<p>同一个Session创建一个实例</p>\n</li>\n</ul>\n</li>\n<li><p>@Lazy </p>\n<p>懒加载：容器启动不创建对象。第一次使用（获取）Bean对象时调用创建对象放入容器</p>\n</li>\n<li><p>@Conditional</p>\n<p>按照一定的条件进行判断，满足条件给容器中注册Bean<br>需要实现Condition 接口：ConditionContext 判断条件能使用的上下文；AnnotatedTypeMetadate 注释信息</p>\n</li>\n<li><p>@Import</p>\n<p>导入组件，id默认是组件的全类名（com.xxx.xxx.xx）</p>\n<ul>\n<li><p>ImportSelector</p>\n<p>自定义逻辑返回需要导入的组件。<br>返回值就是导入到容器中的组件全类名，方法不要返回null。<br>AnnotationMetadata 当前标注@Import注解的类的所有注释信息。</p>\n</li>\n<li><p>ImportBeanDefinitionRegistrar</p>\n<p>BeanDefinitionRegistry：BeanDefinition注册类。<br>调用registerBeanDefinition手工注册Bean</p>\n</li>\n</ul>\n</li>\n<li><p>FactoryBean</p>\n<p>实现FactoryBean接口<br>1.工厂Bean获取的是调用getObject创建的对象<br>2.要获取工程Bean本身，需要给id前面加一个&amp;</p>\n</li>\n</ul>\n<h3 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h3><ul>\n<li><p>初始化</p>\n<ul>\n<li><p>@Bean(initMethod)</p>\n</li>\n<li><p>InitializingBean</p>\n<p>通过让Bean实现该接口，实现Bean初始化逻辑</p>\n</li>\n<li><p>@PostConstruct</p>\n</li>\n<li><p>BeanPostProcessor</p>\n<p>Bean后置处理器，在Bean初始化前后进行一些处理工作</p>\n<ul>\n<li><p>postProcessBeforeInitialization</p>\n<p>在初始化之前</p>\n</li>\n<li><p>postProcessAfterInitialization</p>\n<p>在初始化工作之后</p>\n</li>\n<li><p>ApplicationContextAwareProcessor</p>\n<p>实现该接口，Spring容器可以将当前容器传给实现类</p>\n</li>\n<li><p>InitDestroyAnnotationBeanPostProcessor</p>\n<p>处理@PostConstruct，@PreDestory注解</p>\n</li>\n<li><p>AutowiredAnnotationBeanPostProcessor</p>\n<p>处理@Autowired注解</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>销毁</p>\n<ul>\n<li><p>@Bean(destroyMethod)</p>\n<p>多实例的bean，容器不会调用销毁方法</p>\n</li>\n<li><p>DisposableBean</p>\n<p>通过实现该接口，实现销毁逻辑</p>\n</li>\n<li><p>@PreDestory</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"属性赋值\"><a href=\"#属性赋值\" class=\"headerlink\" title=\"属性赋值\"></a>属性赋值</h3><ul>\n<li><p>@Value</p>\n<ul>\n<li><p>基本数值</p>\n</li>\n<li><p>SpEL  #{}</p>\n</li>\n<li><p>配置文件 ${}</p>\n<p>@PropertySource 读取外部配置文件，保存至环境变量中</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h3><ul>\n<li><p>@Autowired</p>\n<p>1.默认按照类型在容器中找相应的组件<br>2.如果找到多个相同类型的组件，再将属性的名称作为组件的id组容易中寻找<br>3.使用@Qualifier指定需要装配的组件的id<br>4.自动装配默认一定要指定存在的属性（如果不强制指定，使用require=false）<br>5.@Primary,让Spring进行自动装配的时候，默认是用首选的bean</p>\n<ul>\n<li><p>构造器</p>\n<p>构造器用到的自定义类型的值从IOC容器中获取<br>如果组建只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以从容器中获取</p>\n</li>\n<li><p>方法</p>\n<p>标注在方法，Spring容器创建当前对象，就会调用方法完成赋值<br>方法使用的参数，自定义类型的值从IOC容器中获取</p>\n</li>\n<li><p>属性</p>\n<p>值从IOC容器中获取</p>\n</li>\n</ul>\n</li>\n<li><p>@Resource</p>\n<p>可以和@Autowired一样实现自动装配，默认按照属性名称进行装配<br>没有支持@Primary功能，reqiured=false</p>\n</li>\n<li><p>@Inject</p>\n<p>需要依赖javax.inject包，和Autowired一样，没有reqiured=false</p>\n</li>\n<li><p>实现xxxAware接口</p>\n<p>在创建对象的时候，会调用接口的回调方法<br>把Spring底层的组件注册到自定义的Bean中<br>xxxAware功能使用xxxProcessor处理的</p>\n<ul>\n<li><p>ApplicationContextAware</p>\n<p>获取ApplicationContext</p>\n</li>\n<li><p>BeanNameAware</p>\n</li>\n<li><p>EmbeddedValueResolverAware</p>\n</li>\n</ul>\n</li>\n<li><p>Profile</p>\n<p>加了环境表示的bean，只有这个环境被激活的时候才能注册到容器中，默认是default环境</p>\n<ul>\n<li><p>启动参数</p>\n<p>-Dspring.profiles.active=xxx</p>\n</li>\n<li><p>代码</p>\n<p>1.创建一个aplicationContext<br>2.设置需要激活的环境.getEnvironment().setActiveProfiles()<br>3.注册朱配置类  .register()<br>4.启动刷新容器 .refresh()</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h3><p>在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式<br>spring-aspects<br>容器中保存了组建的代理对象(cglib增强后的对象),这个对象里面保存了详细信息(比如增强器，目标对象)</p>\n<ul>\n<li><p>@Before</p>\n<p>在目标方法之前切入：切入点表达式（指定在那个方法切入）</p>\n</li>\n<li><p>@After</p>\n<p>在目标方法之后切入：切入点表达式</p>\n</li>\n<li><p>@PointCut</p>\n<p>切入点表达式</p>\n</li>\n<li><p>@AfterReturning</p>\n<p>再放标方法正常返回之后运行</p>\n</li>\n<li><p>@AfterThrowing</p>\n<p>在目标方法出现异常之后运行</p>\n</li>\n<li><p>@Aspect</p>\n<p>告诉Spring当前类是一个切面类</p>\n</li>\n<li><p>@EnableAspectJAutoProxy</p>\n<p>开启基于注解的AOP<br>1.给容器中导入AspectJAutoProxyRegistrar，给容器中注册一个AnnotationAwareAspectJAutoProxyCreator</p>\n<ul>\n<li><p>AnnotationAwareAspectJAutoProxyCreator</p>\n<ul>\n<li><p>AspectJAwareAdvisorAutoProxyCreator</p>\n<ul>\n<li><p>AbstractAdvisorAutoProxyCreator</p>\n<ul>\n<li><p>AbstractAutoProxyCreator</p>\n<ul>\n<li>SmartInstantiationAwareBeanPostProcessor</li>\n<li>BeanFactroyAware</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JoinPoint</p>\n<p>JoinPoint一定要出现在参数表的第一位</p>\n</li>\n<li><p>目标方法执行</p>\n<p>1.CglibAopProxy.intercept()。拦截目标方法的执行。<br>2.根据PoxyFactory对象获取将要执行的目标方法拦截器链</p>\n<pre><code>a)如果没有拦截器链，直接执行目标方法\nb)如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息出入创建一个CglibMethodInvocation，并调用proceed()方法\nc)拦截器链触发过程\n    1.如果没有拦截器执行目标方法，或者懒机器的索引和拦截器数组-1大小一样(指定到了最后一个拦截器)，执行目标方法。</code></pre></li>\n</ul>\n<h3 id=\"声明式事务\"><a href=\"#声明式事务\" class=\"headerlink\" title=\"声明式事务\"></a>声明式事务</h3><p>1.导入相关依赖spring-jdbc<br>2.配置数据源 JdbcTmplate<br>3.给方法标注@Transactional<br>4.@EnableTransactionManagement 开启基于注解的事物<br>5.配置事物管理器管理事物</p>\n<ul>\n<li><p>@Transactional</p>\n</li>\n<li><p>@EnableTransactionManagement</p>\n<ul>\n<li><p>TransactionManagementConfigurationSelection</p>\n<p>给容器中导入组件</p>\n<ul>\n<li><p>AutoProxyRegistrar</p>\n<p>给容器中注册InfrastructureAdvisorAutoProxyCreator组件</p>\n<ul>\n<li><p>InfrastructureAdvisorAutoProxyCreator</p>\n<p>利用后置处理器机制在对象创建后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行方法</p>\n</li>\n</ul>\n</li>\n<li><p>ProxyTransactionManagementConfiguration</p>\n<p>1.给容器中注册事物增强器</p>\n<pre><code>事物增强器要用事物注解信息\n事物拦截器，保存了事物的属性信息，事物管理器，是一个MethodInterceptor，在目标方法执行时执行拦截器链</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"扩展原理\"><a href=\"#扩展原理\" class=\"headerlink\" title=\"扩展原理\"></a>扩展原理</h2><h3 id=\"BeanFactoryPostProcessor\"><a href=\"#BeanFactoryPostProcessor\" class=\"headerlink\" title=\"BeanFactoryPostProcessor\"></a>BeanFactoryPostProcessor</h3><p>BeanFactory后置处理器<br>    在BeanFactory标准初始化之后调用，所有的bean定义以保存在遭到beanFactory，但是bean还未创建</p>\n<ul>\n<li><p>BeanDefinitionRegistryPostProcessor</p>\n<p>在所有bean定义信息将要被加载，bean实力还未被创建时执行</p>\n</li>\n</ul>\n<h3 id=\"ApplicationListener\"><a href=\"#ApplicationListener\" class=\"headerlink\" title=\"ApplicationListener\"></a>ApplicationListener</h3><p>监听容器中发布的事件<br>    1.写一个监听器，ApplicationListener实现类，来监听某个事件ApplicationEvent机器子类<br>    2.把监听器加入到容器<br>    3.只要容器中有相关事件的腹部，我们就能监听到这个事件：<br>        ContextRefreshedEvent：容器舒心完成(所有bean都完全创建)会发布这个事件；<br>        ContextClosedEvent：关闭容器会发布这个事件<br>    4.发布一个事件，applicationContext.publishEvent()</p>\n<h3 id=\"容器的创建\"><a href=\"#容器的创建\" class=\"headerlink\" title=\"容器的创建\"></a>容器的创建</h3><p>1.Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息<br>    xml<br>    注解<br>2.Spring容器会合适的时机创建这些Bean<br>    用到这个bean的时候，利用getBean创建bean，创建好以后保存在容器中<br>    统一创建剩下所有的bean的时候，finshBeanFactoryInitialization()<br>3.后置处理器<br>    每个bean创建完成，都会使用各种后置处理器，来增强bean的功能<br>4.事件驱动模型<br>    ApplicationListener，事件监听<br>事件派发，ApplicationEvenMulticator</p>\n<ul>\n<li><p>refresh()</p>\n<ul>\n<li><p>prepareRefresh()</p>\n<p>刷新预处理工作:<br>清缓存<br>置状态</p>\n<ul>\n<li><p>initPropertySources()</p>\n<p>初始化属性设置，子类自定义个性化的属性设置方法。</p>\n</li>\n<li><p>getEnvironment().validateRequiredProperties()</p>\n<p>检验属性的合法</p>\n</li>\n<li><p>earlyApplicationEvents</p>\n<p>保存容器中的一起早起事件</p>\n</li>\n</ul>\n</li>\n<li><p>obtainFreshBeanFactory()</p>\n<p>获取BeanFactory</p>\n<ul>\n<li><p>refreshBeanFactory()</p>\n<p>刷新BeanFactory工厂，创建BeanFactory对象。</p>\n</li>\n<li><p>getBeanFactory()【DefaultListableBeanFactory】</p>\n<p>获取之前创建好的BeanFactory</p>\n</li>\n<li><p>prepareBeanFactory()</p>\n<p>BeanFactory的预准备工作（BeanFactory进行一些设置）<br>1.设置BeanFactory的类加载器，支持表达式解析器。。。<br>2.添加部分BeanPostProcessor【ApplicationContextAwareProcessor】<br>3.设置忽略的自动装配的接口，EnvironmentAware、EmbeddedValueResolverAware。。。<br>4.注册可以解析的自动装配，我们能直接在仍和组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext<br>5.添加BeanPostProcessor【ApplicationListenerDetector】<br>6.添加编译是的AspectJ支持<br>7.给BeanFactory中注册一些能用的组件：environment【ConfigurableEnvironment】、systemProperties【Map】</p>\n</li>\n<li><p>postProcessBeanFactory()</p>\n<p>BeanFactory准备完成后的后置处理工作，子类用过重写这个发方法来在BeanFactory初始化完成后进行更进一步的工作</p>\n</li>\n<li><p>invokeBeanFactoryPostProcessors()</p>\n<p>执行BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后执行</p>\n<p>执行BeanFactoryPostProcessor的方法：<br>1.先执行BeanDefinitonRegistryPostProcessor</p>\n<pre><code>获取所有的BeanDefinitonRegistryPostProcessor\n先执行实现了PriorityOrdered接口的\n再执行实现了Ordered接口的\n最后执行剩下的</code></pre><p>2.再执行BeanFactoryPostProcessor的方法</p>\n<pre><code>先执行实现了PriorityOrdered接口的\n再执行实现了Ordered接口的\n最后执行剩下的</code></pre></li>\n</ul>\n</li>\n<li><p>registerBeanPostProcessors()</p>\n<p>注册BeanPostProcessor，Bean的后置处理器。<br>1.获取所有的BeanPostProcessor，不同接口类型的BeanPostProcessor，在Bean船舰前后的执行实际是不一样的。</p>\n<pre><code>BeanPostProcessor\nDestructionAwareBeanPostProcessor\nInstantiationAwareBeanPostProcessor\nSmartInstantiationAwareBeanPostProcessor\nMergedBeanDefinitionPostProcessor</code></pre></li>\n<li><p>initMessageSource()</p>\n<p>初始化MessageSource组件（做国际化功能，消息绑定、解析）<br>1.获取BeanFactory<br>2.看容器中是否有id为messageSource的组件</p>\n<pre><code>如果有赋值给messageSource，如果没有自己创建【DelegatingMessageSource】</code></pre><p>3.把创建好的MessageSource注册在容器中</p>\n</li>\n<li><p>initApplicationEventMulticaster()</p>\n<p>初始化事件派发器<br>1.从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster<br>2.如果没有配置，创建SimpleApplicationEventMulticaster<br>3.注册到容器中</p>\n</li>\n<li><p>onRefresh()</p>\n<p>留给子容器的（子类）<br>1.子类重写这个方法，在容器刷新的时候可以自定义逻辑</p>\n</li>\n<li><p>registerLiseners()</p>\n<p>给容器中将所有的项目的ApplicationListener注册进来。<br>1.从容器中拿到所有ApplicationListener组件<br>2.将每个监听器添加到事件派发器中<br>3.派发之前步骤产生的事件</p>\n</li>\n<li><p>finishBeanFactoryInitialization()</p>\n<p>初始化剩下的所有单实例bean</p>\n<ul>\n<li><p>beanFactory.preInstantiateSingletons()</p>\n<p>初始化剩下的单实例bean<br>1.获取容器中所有的Bean定义<br>2.拿到Bean的定义信息<br>3.Bean不是抽象的，是单实例的，不是懒加载的</p>\n<pre><code>1.判断是否是FactoryBean，是否是实现FactoryBean接口的Bean\n2.不是FactoryBean，用getBean创建对象\n3.doGetBean()\n4.先获取缓存中保存的单实例Bean。如果获取到，说明这个Bean之前被创建国（所有创建国的单实例Bean都是会被缓存起来的）\n5.换种种获取不到，开始Bean的创建对象流程\n6.标记当前bean已经被创建\n7.获取Bean的定义信息\n8.获取当前Bean依赖的其他Bean，如果有就按照getBean()把以来的Bean先创建出来。\n9.启动单实例Bean的创建流程\n    1.createBean()\n    2.resolveBeforeInstantiation()让BeanPostProcessor先拦截返回代理对象【InstantiationAwareBeanPostProcessors】提前执行\n    3.如果前面的InstantiationAwareBeanPostProcessors没有返回代理对象\n    4.doCreateBean()创建Bean\n        1.创建Bean实例，createBeanInstance()利用工厂方法或者对象的构造器创建出Bean实例\n        2.applyMergedBeanDefinitionPostProcessors()，调用【MergedBeanDefinitionPostProcessors】\n        3.populateBean() Bean属性赋值</code></pre></li>\n</ul>\n</li>\n<li><p>finishRefresh()</p>\n<p>完成BeanFactory的初始化创建工作，IOC容器就创建完成</p>\n<ul>\n<li><p>initLifecycleProcessor()</p>\n<p>初始化和生命周期有关的后置处理器：LifecycleProcessor。<br>写一个LifecycleProcessor的实现类，可以在BeanFactory的onRefresh(),onClose()进行拦截</p>\n</li>\n<li><p>getLifecycleProcessor().onRefresh()</p>\n<p>拿到前面定义的生命周期处理器，回调onRefresh()</p>\n</li>\n<li><p>publishEvent()</p>\n<p>发布容器完成事件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"Java","path":"tags/Java/"},{"name":"Springboot","path":"tags/Springboot/"}],"excerpt":"<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h3 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h3>","more":"<p>spring-context</p>\n<ul>\n<li><p>@Configuration</p>\n<p>告诉Spring这是一个配置类</p>\n</li>\n<li><p>@Bean</p>\n<p>给容器中注册一个Bean，类型为返回值的类型，id默认是用方法<br>默认都是单例</p>\n</li>\n<li><p>AnnotationConfigApplicationContext</p>\n</li>\n<li><p>@ComponetScan、@ComponetScans</p>\n<p>value：扫描@Service @Controller @Repositroy @Componet<br>excludeFlters：排除的规则<br>includeFilters：只需要包含的规则</p>\n<ul>\n<li><p>FilterType.ANNOTATION</p>\n<p>按照注解</p>\n</li>\n<li><p>FilterType.ASSIGNABLE_TYPE</p>\n<p>按照给定类型</p>\n</li>\n<li><p>FilterType.ASPECTJ</p>\n<p>使用ASPECTJ表达式</p>\n</li>\n<li><p>FilterType.REGEX</p>\n<p>使用正则指定</p>\n</li>\n<li><p>FilterType.CUSTOM</p>\n<p>自定义规则，必须实现TypeFilter类</p>\n</li>\n</ul>\n</li>\n<li><p>@Scope</p>\n<ul>\n<li><p>SCOPE_PROTOTPE</p>\n<p>多实例<br>IOC容器启动不回去调用方法床架你对象，获取的时候创建对象</p>\n</li>\n<li><p>SCOPE_SINGLETON</p>\n<p>单实例（默认值）<br>IOC容器启动会调用方法创建对象放到IOC容器中</p>\n</li>\n<li><p>SCOPE_REQUEST</p>\n<p>同一次请求创建一个实例</p>\n</li>\n<li><p>SCOPE_SESSION</p>\n<p>同一个Session创建一个实例</p>\n</li>\n</ul>\n</li>\n<li><p>@Lazy </p>\n<p>懒加载：容器启动不创建对象。第一次使用（获取）Bean对象时调用创建对象放入容器</p>\n</li>\n<li><p>@Conditional</p>\n<p>按照一定的条件进行判断，满足条件给容器中注册Bean<br>需要实现Condition 接口：ConditionContext 判断条件能使用的上下文；AnnotatedTypeMetadate 注释信息</p>\n</li>\n<li><p>@Import</p>\n<p>导入组件，id默认是组件的全类名（com.xxx.xxx.xx）</p>\n<ul>\n<li><p>ImportSelector</p>\n<p>自定义逻辑返回需要导入的组件。<br>返回值就是导入到容器中的组件全类名，方法不要返回null。<br>AnnotationMetadata 当前标注@Import注解的类的所有注释信息。</p>\n</li>\n<li><p>ImportBeanDefinitionRegistrar</p>\n<p>BeanDefinitionRegistry：BeanDefinition注册类。<br>调用registerBeanDefinition手工注册Bean</p>\n</li>\n</ul>\n</li>\n<li><p>FactoryBean</p>\n<p>实现FactoryBean接口<br>1.工厂Bean获取的是调用getObject创建的对象<br>2.要获取工程Bean本身，需要给id前面加一个&amp;</p>\n</li>\n</ul>\n<h3 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h3><ul>\n<li><p>初始化</p>\n<ul>\n<li><p>@Bean(initMethod)</p>\n</li>\n<li><p>InitializingBean</p>\n<p>通过让Bean实现该接口，实现Bean初始化逻辑</p>\n</li>\n<li><p>@PostConstruct</p>\n</li>\n<li><p>BeanPostProcessor</p>\n<p>Bean后置处理器，在Bean初始化前后进行一些处理工作</p>\n<ul>\n<li><p>postProcessBeforeInitialization</p>\n<p>在初始化之前</p>\n</li>\n<li><p>postProcessAfterInitialization</p>\n<p>在初始化工作之后</p>\n</li>\n<li><p>ApplicationContextAwareProcessor</p>\n<p>实现该接口，Spring容器可以将当前容器传给实现类</p>\n</li>\n<li><p>InitDestroyAnnotationBeanPostProcessor</p>\n<p>处理@PostConstruct，@PreDestory注解</p>\n</li>\n<li><p>AutowiredAnnotationBeanPostProcessor</p>\n<p>处理@Autowired注解</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>销毁</p>\n<ul>\n<li><p>@Bean(destroyMethod)</p>\n<p>多实例的bean，容器不会调用销毁方法</p>\n</li>\n<li><p>DisposableBean</p>\n<p>通过实现该接口，实现销毁逻辑</p>\n</li>\n<li><p>@PreDestory</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"属性赋值\"><a href=\"#属性赋值\" class=\"headerlink\" title=\"属性赋值\"></a>属性赋值</h3><ul>\n<li><p>@Value</p>\n<ul>\n<li><p>基本数值</p>\n</li>\n<li><p>SpEL  #{}</p>\n</li>\n<li><p>配置文件 ${}</p>\n<p>@PropertySource 读取外部配置文件，保存至环境变量中</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"自动装配\"><a href=\"#自动装配\" class=\"headerlink\" title=\"自动装配\"></a>自动装配</h3><ul>\n<li><p>@Autowired</p>\n<p>1.默认按照类型在容器中找相应的组件<br>2.如果找到多个相同类型的组件，再将属性的名称作为组件的id组容易中寻找<br>3.使用@Qualifier指定需要装配的组件的id<br>4.自动装配默认一定要指定存在的属性（如果不强制指定，使用require=false）<br>5.@Primary,让Spring进行自动装配的时候，默认是用首选的bean</p>\n<ul>\n<li><p>构造器</p>\n<p>构造器用到的自定义类型的值从IOC容器中获取<br>如果组建只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以从容器中获取</p>\n</li>\n<li><p>方法</p>\n<p>标注在方法，Spring容器创建当前对象，就会调用方法完成赋值<br>方法使用的参数，自定义类型的值从IOC容器中获取</p>\n</li>\n<li><p>属性</p>\n<p>值从IOC容器中获取</p>\n</li>\n</ul>\n</li>\n<li><p>@Resource</p>\n<p>可以和@Autowired一样实现自动装配，默认按照属性名称进行装配<br>没有支持@Primary功能，reqiured=false</p>\n</li>\n<li><p>@Inject</p>\n<p>需要依赖javax.inject包，和Autowired一样，没有reqiured=false</p>\n</li>\n<li><p>实现xxxAware接口</p>\n<p>在创建对象的时候，会调用接口的回调方法<br>把Spring底层的组件注册到自定义的Bean中<br>xxxAware功能使用xxxProcessor处理的</p>\n<ul>\n<li><p>ApplicationContextAware</p>\n<p>获取ApplicationContext</p>\n</li>\n<li><p>BeanNameAware</p>\n</li>\n<li><p>EmbeddedValueResolverAware</p>\n</li>\n</ul>\n</li>\n<li><p>Profile</p>\n<p>加了环境表示的bean，只有这个环境被激活的时候才能注册到容器中，默认是default环境</p>\n<ul>\n<li><p>启动参数</p>\n<p>-Dspring.profiles.active=xxx</p>\n</li>\n<li><p>代码</p>\n<p>1.创建一个aplicationContext<br>2.设置需要激活的环境.getEnvironment().setActiveProfiles()<br>3.注册朱配置类  .register()<br>4.启动刷新容器 .refresh()</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h3><p>在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式<br>spring-aspects<br>容器中保存了组建的代理对象(cglib增强后的对象),这个对象里面保存了详细信息(比如增强器，目标对象)</p>\n<ul>\n<li><p>@Before</p>\n<p>在目标方法之前切入：切入点表达式（指定在那个方法切入）</p>\n</li>\n<li><p>@After</p>\n<p>在目标方法之后切入：切入点表达式</p>\n</li>\n<li><p>@PointCut</p>\n<p>切入点表达式</p>\n</li>\n<li><p>@AfterReturning</p>\n<p>再放标方法正常返回之后运行</p>\n</li>\n<li><p>@AfterThrowing</p>\n<p>在目标方法出现异常之后运行</p>\n</li>\n<li><p>@Aspect</p>\n<p>告诉Spring当前类是一个切面类</p>\n</li>\n<li><p>@EnableAspectJAutoProxy</p>\n<p>开启基于注解的AOP<br>1.给容器中导入AspectJAutoProxyRegistrar，给容器中注册一个AnnotationAwareAspectJAutoProxyCreator</p>\n<ul>\n<li><p>AnnotationAwareAspectJAutoProxyCreator</p>\n<ul>\n<li><p>AspectJAwareAdvisorAutoProxyCreator</p>\n<ul>\n<li><p>AbstractAdvisorAutoProxyCreator</p>\n<ul>\n<li><p>AbstractAutoProxyCreator</p>\n<ul>\n<li>SmartInstantiationAwareBeanPostProcessor</li>\n<li>BeanFactroyAware</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JoinPoint</p>\n<p>JoinPoint一定要出现在参数表的第一位</p>\n</li>\n<li><p>目标方法执行</p>\n<p>1.CglibAopProxy.intercept()。拦截目标方法的执行。<br>2.根据PoxyFactory对象获取将要执行的目标方法拦截器链</p>\n<pre><code>a)如果没有拦截器链，直接执行目标方法\nb)如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息出入创建一个CglibMethodInvocation，并调用proceed()方法\nc)拦截器链触发过程\n    1.如果没有拦截器执行目标方法，或者懒机器的索引和拦截器数组-1大小一样(指定到了最后一个拦截器)，执行目标方法。</code></pre></li>\n</ul>\n<h3 id=\"声明式事务\"><a href=\"#声明式事务\" class=\"headerlink\" title=\"声明式事务\"></a>声明式事务</h3><p>1.导入相关依赖spring-jdbc<br>2.配置数据源 JdbcTmplate<br>3.给方法标注@Transactional<br>4.@EnableTransactionManagement 开启基于注解的事物<br>5.配置事物管理器管理事物</p>\n<ul>\n<li><p>@Transactional</p>\n</li>\n<li><p>@EnableTransactionManagement</p>\n<ul>\n<li><p>TransactionManagementConfigurationSelection</p>\n<p>给容器中导入组件</p>\n<ul>\n<li><p>AutoProxyRegistrar</p>\n<p>给容器中注册InfrastructureAdvisorAutoProxyCreator组件</p>\n<ul>\n<li><p>InfrastructureAdvisorAutoProxyCreator</p>\n<p>利用后置处理器机制在对象创建后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链执行方法</p>\n</li>\n</ul>\n</li>\n<li><p>ProxyTransactionManagementConfiguration</p>\n<p>1.给容器中注册事物增强器</p>\n<pre><code>事物增强器要用事物注解信息\n事物拦截器，保存了事物的属性信息，事物管理器，是一个MethodInterceptor，在目标方法执行时执行拦截器链</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"扩展原理\"><a href=\"#扩展原理\" class=\"headerlink\" title=\"扩展原理\"></a>扩展原理</h2><h3 id=\"BeanFactoryPostProcessor\"><a href=\"#BeanFactoryPostProcessor\" class=\"headerlink\" title=\"BeanFactoryPostProcessor\"></a>BeanFactoryPostProcessor</h3><p>BeanFactory后置处理器<br>    在BeanFactory标准初始化之后调用，所有的bean定义以保存在遭到beanFactory，但是bean还未创建</p>\n<ul>\n<li><p>BeanDefinitionRegistryPostProcessor</p>\n<p>在所有bean定义信息将要被加载，bean实力还未被创建时执行</p>\n</li>\n</ul>\n<h3 id=\"ApplicationListener\"><a href=\"#ApplicationListener\" class=\"headerlink\" title=\"ApplicationListener\"></a>ApplicationListener</h3><p>监听容器中发布的事件<br>    1.写一个监听器，ApplicationListener实现类，来监听某个事件ApplicationEvent机器子类<br>    2.把监听器加入到容器<br>    3.只要容器中有相关事件的腹部，我们就能监听到这个事件：<br>        ContextRefreshedEvent：容器舒心完成(所有bean都完全创建)会发布这个事件；<br>        ContextClosedEvent：关闭容器会发布这个事件<br>    4.发布一个事件，applicationContext.publishEvent()</p>\n<h3 id=\"容器的创建\"><a href=\"#容器的创建\" class=\"headerlink\" title=\"容器的创建\"></a>容器的创建</h3><p>1.Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息<br>    xml<br>    注解<br>2.Spring容器会合适的时机创建这些Bean<br>    用到这个bean的时候，利用getBean创建bean，创建好以后保存在容器中<br>    统一创建剩下所有的bean的时候，finshBeanFactoryInitialization()<br>3.后置处理器<br>    每个bean创建完成，都会使用各种后置处理器，来增强bean的功能<br>4.事件驱动模型<br>    ApplicationListener，事件监听<br>事件派发，ApplicationEvenMulticator</p>\n<ul>\n<li><p>refresh()</p>\n<ul>\n<li><p>prepareRefresh()</p>\n<p>刷新预处理工作:<br>清缓存<br>置状态</p>\n<ul>\n<li><p>initPropertySources()</p>\n<p>初始化属性设置，子类自定义个性化的属性设置方法。</p>\n</li>\n<li><p>getEnvironment().validateRequiredProperties()</p>\n<p>检验属性的合法</p>\n</li>\n<li><p>earlyApplicationEvents</p>\n<p>保存容器中的一起早起事件</p>\n</li>\n</ul>\n</li>\n<li><p>obtainFreshBeanFactory()</p>\n<p>获取BeanFactory</p>\n<ul>\n<li><p>refreshBeanFactory()</p>\n<p>刷新BeanFactory工厂，创建BeanFactory对象。</p>\n</li>\n<li><p>getBeanFactory()【DefaultListableBeanFactory】</p>\n<p>获取之前创建好的BeanFactory</p>\n</li>\n<li><p>prepareBeanFactory()</p>\n<p>BeanFactory的预准备工作（BeanFactory进行一些设置）<br>1.设置BeanFactory的类加载器，支持表达式解析器。。。<br>2.添加部分BeanPostProcessor【ApplicationContextAwareProcessor】<br>3.设置忽略的自动装配的接口，EnvironmentAware、EmbeddedValueResolverAware。。。<br>4.注册可以解析的自动装配，我们能直接在仍和组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext<br>5.添加BeanPostProcessor【ApplicationListenerDetector】<br>6.添加编译是的AspectJ支持<br>7.给BeanFactory中注册一些能用的组件：environment【ConfigurableEnvironment】、systemProperties【Map】</p>\n</li>\n<li><p>postProcessBeanFactory()</p>\n<p>BeanFactory准备完成后的后置处理工作，子类用过重写这个发方法来在BeanFactory初始化完成后进行更进一步的工作</p>\n</li>\n<li><p>invokeBeanFactoryPostProcessors()</p>\n<p>执行BeanFactoryPostProcessor：BeanFactory的后置处理器，在BeanFactory标准初始化之后执行</p>\n<p>执行BeanFactoryPostProcessor的方法：<br>1.先执行BeanDefinitonRegistryPostProcessor</p>\n<pre><code>获取所有的BeanDefinitonRegistryPostProcessor\n先执行实现了PriorityOrdered接口的\n再执行实现了Ordered接口的\n最后执行剩下的</code></pre><p>2.再执行BeanFactoryPostProcessor的方法</p>\n<pre><code>先执行实现了PriorityOrdered接口的\n再执行实现了Ordered接口的\n最后执行剩下的</code></pre></li>\n</ul>\n</li>\n<li><p>registerBeanPostProcessors()</p>\n<p>注册BeanPostProcessor，Bean的后置处理器。<br>1.获取所有的BeanPostProcessor，不同接口类型的BeanPostProcessor，在Bean船舰前后的执行实际是不一样的。</p>\n<pre><code>BeanPostProcessor\nDestructionAwareBeanPostProcessor\nInstantiationAwareBeanPostProcessor\nSmartInstantiationAwareBeanPostProcessor\nMergedBeanDefinitionPostProcessor</code></pre></li>\n<li><p>initMessageSource()</p>\n<p>初始化MessageSource组件（做国际化功能，消息绑定、解析）<br>1.获取BeanFactory<br>2.看容器中是否有id为messageSource的组件</p>\n<pre><code>如果有赋值给messageSource，如果没有自己创建【DelegatingMessageSource】</code></pre><p>3.把创建好的MessageSource注册在容器中</p>\n</li>\n<li><p>initApplicationEventMulticaster()</p>\n<p>初始化事件派发器<br>1.从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster<br>2.如果没有配置，创建SimpleApplicationEventMulticaster<br>3.注册到容器中</p>\n</li>\n<li><p>onRefresh()</p>\n<p>留给子容器的（子类）<br>1.子类重写这个方法，在容器刷新的时候可以自定义逻辑</p>\n</li>\n<li><p>registerLiseners()</p>\n<p>给容器中将所有的项目的ApplicationListener注册进来。<br>1.从容器中拿到所有ApplicationListener组件<br>2.将每个监听器添加到事件派发器中<br>3.派发之前步骤产生的事件</p>\n</li>\n<li><p>finishBeanFactoryInitialization()</p>\n<p>初始化剩下的所有单实例bean</p>\n<ul>\n<li><p>beanFactory.preInstantiateSingletons()</p>\n<p>初始化剩下的单实例bean<br>1.获取容器中所有的Bean定义<br>2.拿到Bean的定义信息<br>3.Bean不是抽象的，是单实例的，不是懒加载的</p>\n<pre><code>1.判断是否是FactoryBean，是否是实现FactoryBean接口的Bean\n2.不是FactoryBean，用getBean创建对象\n3.doGetBean()\n4.先获取缓存中保存的单实例Bean。如果获取到，说明这个Bean之前被创建国（所有创建国的单实例Bean都是会被缓存起来的）\n5.换种种获取不到，开始Bean的创建对象流程\n6.标记当前bean已经被创建\n7.获取Bean的定义信息\n8.获取当前Bean依赖的其他Bean，如果有就按照getBean()把以来的Bean先创建出来。\n9.启动单实例Bean的创建流程\n    1.createBean()\n    2.resolveBeforeInstantiation()让BeanPostProcessor先拦截返回代理对象【InstantiationAwareBeanPostProcessors】提前执行\n    3.如果前面的InstantiationAwareBeanPostProcessors没有返回代理对象\n    4.doCreateBean()创建Bean\n        1.创建Bean实例，createBeanInstance()利用工厂方法或者对象的构造器创建出Bean实例\n        2.applyMergedBeanDefinitionPostProcessors()，调用【MergedBeanDefinitionPostProcessors】\n        3.populateBean() Bean属性赋值</code></pre></li>\n</ul>\n</li>\n<li><p>finishRefresh()</p>\n<p>完成BeanFactory的初始化创建工作，IOC容器就创建完成</p>\n<ul>\n<li><p>initLifecycleProcessor()</p>\n<p>初始化和生命周期有关的后置处理器：LifecycleProcessor。<br>写一个LifecycleProcessor的实现类，可以在BeanFactory的onRefresh(),onClose()进行拦截</p>\n</li>\n<li><p>getLifecycleProcessor().onRefresh()</p>\n<p>拿到前面定义的生命周期处理器，回调onRefresh()</p>\n</li>\n<li><p>publishEvent()</p>\n<p>发布容器完成事件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"自己动手写Java虚拟机 笔记2","date":"2019-09-10T13:47:52.000Z","_content":"\n## 实现cp/classpath 参数搜索class文件\n\n### java class path 搜索顺序：\n1. 启动类路径（bootstrap classpath）:jre\\lib （可通过-Xbootclasspath参数修改该路径）\n2. 扩展类路径（extension classpath）:jre\\lib\\ext\n3. 用户类路径（user classpath）:用户自己指定\n\n<!-- more -->\n\n### 实现\n1. Entry接口用来定义启动类的基本功能\n\n{% codeblock lang:go %}\nconst pathListSeparator = string(os.PathListSeparator) //获取当前操作系统分隔符\n\ntype Entry interface {\n\treadClass(classNme string) ([]byte,Entry,error) //定义按class名读取class文件的方\n\tString() string \n}\n\n//根据classpath生成对应的启动类\nfunc newEntry(path string) Entry {\n\tif strings.Contains(path,pathListSeparator){ //classpath路径包含系统分割符时，new组合启动类\n\t\treturn newCompositeEntry(path)\n\t}\n\n\tif strings.HasSuffix(path,\"*\") {\n\t\treturn newWildcardEntry(path) //classpath路径包含*时，new通配符启动类\n\t}\n\n\tif strings.HasSuffix(path, \".jar\") || strings.HasSuffix(path, \".JAR\") ||\n      strings.HasSuffix(path, \".zip\") || strings.HasSuffix(path, \".ZIP\") {\n      return newZipEntry(path) //classpath路径包含jar、JAR、zip、ZIP时，new文件夹启动类\n   }\n\treturn newDirEntry(path)\n\n}\n{% endcodeblock %}\n\n2. Entry接口的具体实现\n * DirEntry，按照文件路径读取文件二进制流 \n{% codeblock lang:golang %}\ntype DirEntry struct {\n\tabsDir string //存储文件夹路径\n}\n\nfunc newDirEntry(path string) *DirEntry {\n\tabsDir,err := filepath.Abs(path) //如果文件路径存在，获取文件夹路径\n\tif err != nil {\n\t\tpanic(err) //文件路径不存在时提示错误\n\t}\n\n\treturn &DirEntry{absDir} //返回DirEntry实例\n}\n\nfunc (self *DirEntry) readClass(className string) ([]byte,Entry,error){\n\tfileName := filepath.Join(self.absDir,className) //拼接文件夹路径和classname\n\tdata,err := ioutil.ReadFile(fileName) //读取文件\n\treturn data,self,err //返回文件内容\n}\n\nfunc(self *DirEntry) String() string {\n\treturn self.absDir //返回文件夹路径\n}\n{% endcodeblock %}\n\n * ZipEntry,读取压缩文件夹内的文件\n{% codeblock lang:golang %}\ntype ZipEnty struct {\n\tabsPath string //文件夹路径\n}\n\nfunc newZipEntry(path string) *ZipEnty {\n\tabsPath, err := filepath.Abs(path) //如果文件路径存在，获取文件夹路径\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &ZipEnty{absPath}\n}\n\nfunc (self *ZipEnty) readClass(className string) ([]byte,Entry,error){\n\tr, err := zip.OpenReader(self.absPath) //以压缩文件格式解压\n\tif err != nil {\n\t   return nil, nil, err\n\t}\n\tdefer r.Close() //最后关闭文件流\n\tfor _, f := range r.File { //循环解压出来的文件\n\t   if f.Name == className { //如果当前文件为指定文件\n\t\t  rc, err := f.Open() //打开该文件\n\t\t  if err != nil {\n\t\t\t return nil, nil, err\n\t\t  }\n\t\t  defer rc.Close() //最后关闭文件\n\t\t  data, err := ioutil.ReadAll(rc) //读取文件流\n\t\t  if err != nil {\n\t\t\t return nil, nil, err\n\t\t  }\n\t\t  return data, self, nil //返回文件流\n\t   }\n\t}\n\treturn nil, nil, errors.New(\"class not found: \" + className)\n}\n\nfunc (self *ZipEnty) String() string {\n\treturn self.absPath\n}\n{% endcodeblock %}\n\n * CompositeEntry,读取符合文件类型\n{% codeblock lang:golang %}\ntype CompositeEntry []Entry //CompositeEntry为多种Entry的数组（Dir、Zip）\n\nfunc newCompositeEntry(pathList string) CompositeEntry {\n\tcompositeEntry := []Entry{} //实例Entry接口数组\n\n\tfor _,path := range strings.Split(pathList,pathListSeparator){ //按照系统分割符截取path列表，并循环\n\t\tentry := newEntry(path) //按照每种path实例化不同的Entry(Dir、Zip、Wildcard)\n\t\tcompositeEntry = append(compositeEntry,entry) //将实例化的不同Entry放入CompositeEntry数组中\n\t}\n\treturn compositeEntry\n}\n\nfunc (self CompositeEntry) readClass(className string)([]byte,Entry,error){\n\tfor _, entry := range self { //循环compositeEntry数组\n\t\tdata, from, err := entry.readClass(className) //根据不同Entry(Dir、Zip、Wildcard)，按指定classname读取文件\n\t\tif err == nil {\n\t\t   return data, from, nil //返回读取结果\n\t\t}\n\t }\n\t return nil, nil, errors.New(\"class not found: \" + className) //无结果是返回错误信息\n}\n\nfunc (self CompositeEntry) String() string {\n\tstrs := make([]string, len(self)) //按照CompositeEntry的长度申明该长度的Sring数组\n\tfor i, entry := range self { //循环CompositeEntry\n\t   strs[i] = entry.String() //调用每个Entry(Dir、Zip、Wildcard)实现类的String()方法,并放入String数组中\n\t}\n\treturn strings.Join(strs, pathListSeparator) //将String数组中的结果以系统分隔符拼接并返回\n}\n{% endcodeblock %}\n\n * WildcardEntry，按照通配符解析文件\n{% codeblock lang:golang %}\nfunc newWildcardEntry(path string) CompositeEntry {\n\tbaseDir := path[:len(path)-1] // remove *\n\tcompositeEntry := []Entry{} //申明compositeEntry对象(Entry的数组)\n\twalkFn := func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t   return err\n\t\t}\n\t\tif info.IsDir() && path != baseDir { //如果当前目录是文件夹，并且是根目录\n\t\t   return filepath.SkipDir //返回SkipDir的错误\n\t\t}\n\t\tif strings.HasSuffix(path, \".jar\") || strings.HasSuffix(path, \".JAR\") { //如果当前路径是以.jar或.JAR结尾的\n\t\t\tjarEntry := newZipEntry(path) //实例化ZipEntry\n\t\t\tcompositeEntry = append(compositeEntry, jarEntry) //将实例化的ZipEntry对象放入compositeEntry数组中\n\t\t }\n\t\t return nil\n\t  }\n\tfilepath.Walk(baseDir, walkFn) //将walkFn方法传递给filepath.Walk\n\treturn compositeEntry //返回结果\n }\n{% endcodeblock %}\n\n* Classpath，-cp|classpath参数解析实现的入口方法\n{% codeblock lang:golang %}\ntype Classpath struct { //Classpath包含java的三种基础启动路径\n\tbootClasspath Entry \n\textClasspath Entry\n\tuserClasspath Entry\n}\n\nfunc Parse(jreOption, cpOption string) * Classpath  {\n\tcp := &Classpath{} //实例化Classpath对象\n\tcp.parseBootAndExtClasspath(jreOption) //按照-Xjre参数解析Boot和Ext启动路径\n\tcp.parseUserClasspath(cpOption) //按照-cp|classpath参数解析User启动路径\n\treturn cp //返回设置好启动路径的Classpath对象\n}\n\nfunc (self *Classpath) ReadClass(className string) ([]byte,Entry,error){\n\tclassName = className + \".class\" //初始化className文件名\n\tif data, entry, err := self.bootClasspath.readClass(className); err == nil { //先扫描Boot启动路径下是否存在该className.class文件\n\t   return data, entry, err //存在则返回\n\t}\n\tif data, entry, err := self.extClasspath.readClass(className); err == nil { //再扫描Ext启动路径下是否存在该className.class文件\n\t   return data, entry, err //存在则返回\n\t}\n\treturn self.userClasspath.readClass(className) //以上两个路径下都不存在，则扫描User启动路径\n}\n\nfunc (self *Classpath) String() string  {\n\treturn self.userClasspath.String()\n}\n\nfunc (self *Classpath) parseBootAndExtClasspath(jreOption string) { //按照-Xjre参数解析Boot和Ext启动路径\n\tjreDir := getJreDir(jreOption) //获取jre路径\n   // jre/lib/*\n   jreLibPath := filepath.Join(jreDir, \"lib\", \"*\")\n   self.bootClasspath = newWildcardEntry(jreLibPath)\n   // jre/lib/ext/*\n   jreExtPath := filepath.Join(jreDir, \"lib\", \"ext\", \"*\")\n   self.extClasspath = newWildcardEntry(jreExtPath)\n}\n\nfunc getJreDir(jreOption string) string {\n\tif jreOption != \"\" && exists(jreOption) { //jreOption不为空且存在时返回该路径\n\t   return jreOption\n\t}\n\tif exists(\"./jre\") { //./jre路径存在时，返回.jre\n\t   return \"./jre\"\n\t}\n\tif jh := os.Getenv(\"JAVA_HOME\"); jh != \"\" { //环境变量JAVA_HOME存在并且不为空时\n\t   return filepath.Join(jh, \"jre\") //返回JAVA_HOME + \"jre\"\n\t}\n\tpanic(\"Can not find jre folder!\")\n }\n\n func exists(path string) bool {\n\tif _, err := os.Stat(path); err != nil {\n\t   if os.IsNotExist(err) {\n\t\t  return false\n\t   }\n\t}\n\treturn true\n }\n\n func (self *Classpath) parseUserClasspath(cpOption string) { //按照-cp|classpath参数解析User启动参数\n\tif cpOption == \"\" { //cpOption为空时\n\t   cpOption = \".\" //返回相对路劲\n\t}\n\tself.userClasspath = newEntry(cpOption) //根据-cp|classpath参数实例化对应的Entry\n }\n{% endcodeblock %}\n\n * main，修改启动类\n{% codeblock lang:golang %}\nfunc startJVM(cmd *Cmd){\n\tcp := classpath.Parse(cmd.XjreOption, cmd.cpOption) //根据-Xjre和-cp|classpath参数实例化classpath对象实例\n\tfmt.Printf(\"classpath:%v class:%v args:%v\\n\",\n\t   cp, cmd.class, cmd.args)\n\tclassName := strings.Replace(cmd.class, \".\", \"/\", -1)\n\tclassData, _, err := cp.ReadClass(className) //按照3个启动路径查找并读取className文件\n\tif err != nil {\n\t   fmt.Printf(\"Could not find or load main class %s\\n\", cmd.class)\n\t   return\n\t}\n\tfmt.Printf(\"class data:%v\\n\", classData)\n}\n{% endcodeblock %}\n\n3. 试运行\n{% codeblock lang:shell %}\nPS D:\\work\\workspace_go\\src\\jvmgo\\ch02> go install\n\nPS D:\\work\\workspace_go\\bin> .\\ch02.exe -Xjre \"C:\\Program Files\\Java\\jre1.8.0_202\" java.lang.Object\nclasspath:D:\\work\\workspace_go\\bin class:java.lang.Object args:[]\nclass data:[202 254 186 190 0 0 0 52 0 75 3 0 15 66 63 8 0 16 8 0 36 8 0 40 1 0 3 40 41 73 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 3 40 41 86 1 0 21 40 73 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 4 40 74 41 86 1 0 5 40 74 73 41 86 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 41 90 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 86 1 0 8 60 99 108 105 110 105 116 62 1 0 6 60 105 110 105 116 62 1 0 1 64 1 0 4 67 111 100\n101 1 0 10 69 120 99 101 112 116 105 111 110 115 1 0 9 83 105 103 110 97 116 117 114 101 1 0 13 83 116 97 99 107 77 97 112 84 97 98 108 101 1 0 6 97 112 112 101 110 100 1 0 5 99 108 111 110 101 1 0 6 101 113\n117 97 108 115 1 0 8 102 105 110 97 108 105 122 101 1 0 8 103 101 116 67 108 97 115 115 1 0 7 103 101 116 78 97 109 101 1 0 8 104 97 115 104 67 111 100 101 1 0 15 106 97 118 97 47 108 97 110 103 47 67 108 97\n115 115 1 0 36 106 97 118 97 47 108 97 110 103 47 67 108 111 110 101 78 111 116 83 117 112 112 111 114 116 101 100 69 120 99 101 112 116 105 111 110 1 0 34 106 97 118 97 47 108 97 110 103 47 73 108 108 101 103 97 108 65 114 103 117 109 101 110 116 69 120 99 101 112 116 105 111 110 1 0 17 106 97 118 97 47 108 97 110 103 47 73 110 116 101 103 101 114 1 0 30 106 97 118 97 47 108 97 110 103 47 73 110 116 101 114 114\n117 112 116 101 100 69 120 99 101 112 116 105 111 110 1 0 16 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 1 0 23 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 1 0 19 106 97 118 97 47 108 97 110 103 47 84 104 114 111 119 97 98 108 101 1 0 37 110 97 110 111 115 101 99 111 110 100 32 116 105 109 101 111 117 116 32 118 97 108 117 101 32 111 117 116 32 111 102 32 114 97 110 103 101 1 0 6 110 111 116 105 102 121 1 0 9 110 111 116 105 102 121 65 108 108 1 0 15 114 101 103 105 115 116 101 114 78 97 116 105 118 101 115 1 0 25 116 105 109 101 111 117 116 32 118 97 108 117 101 32 105 115 32 110 101 103 97 116 105 118 101 1 0 11 116 111 72 101 120 83 116 114 105 110 103 1 0 8 116 111 83 116 114 105 110 103 1 0 4 119 97 105 116 7 0 28 7 0 29 7 0 30 7 0 31 7 0 32 7 0 33 7 0 34 7 0 35 1 0 19 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 59 1 0 22 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 60 42 62 59 1 0 45 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 59 12 0 27 0 5 12 0 15 0 8 12 0 39 0 8 12 0 43 0 10 12 0 25 0 52 12 0 26 0 7 12 0 42 0 7 12 0 41 0\n9 12 0 15 0 13 12 0 21 0 54 10 0 44 0 60 10 0 46 0 63 10 0 47 0 62 10 0 49 0 55 10 0 49 0 57 10 0 49 0 58 10 0 49 0 59 10 0 50 0 56 10 0 50 0 61 10 0 50 0 64 0 33 0 49 0 0 0 0 0 0 0 14 0 1 0 15 0 8 0 1 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 1 10 0 39 0 8 0 0 1 17 0 25 0 52 0 1 0 19 0 0 0 2 0 53 1 1 0 27 0 5 0 0 0 1 0 23 0 12 0 1 0 17 0 0 0 34 0 2 0 2 0 0 0 11 42 43 166 0 7 4 167 0 4 3 172 0 0 0 1 0 20 0 0 0 5\n0 2 9 64 1 1 4 0 22 0 6 0 1 0 18 0 0 0 4 0 1 0 45 0 1 0 42 0 7 0 1 0 17 0 0 0 48 0 2 0 1 0 0 0 36 187 0 50 89 183 0 72 42 182 0 71 182 0 65 182 0 74 18 2 182 0 74 42 182 0 68 184 0 67 182 0 74 182 0 73 176 0\n0 0 0 1 17 0 37 0 8 0 0 1 17 0 38 0 8 0 0 1 17 0 43 0 10 0 1 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 11 0 2 0 17 0 0 0 74 0 4 0 4 0 0 0 50 31 9 148 156 0 13 187 0 46 89 18 4 183 0 66 191 29 155 0 9 29 18 1 164 0 13 187 0 46 89 18 3 183 0 66 191 29 158 0 7 31 10 97 64 42 31 182 0 70 177 0 0 0 1 0 20 0 0 0 6 0 4 16 9 9 7 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 8 0 2 0 17 0 0 0 18 0 3 0 1 0 0 0 6 42 9 182 0 70 177 0 0 0 0 0 18\n0 0 0 4 0 1 0 48 0 4 0 24 0 8 0 2 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 0 18 0 0 0 4 0 1 0 51 0 8 0 14 0 8 0 1 0 17 0 0 0 16 0 0 0 0 0 0 0 4 184 0 69 177 0 0 0 0 0 0]\n{% endcodeblock %}\n","source":"_posts/自己动手写Java虚拟机-笔记2.md","raw":"---\ntitle: 自己动手写Java虚拟机 笔记2\ndate: 2019-09-10 21:47:52\ntags: \n    - JVM\n    - Java\n    - Go\ncategories :\n    - Technology\n---\n\n## 实现cp/classpath 参数搜索class文件\n\n### java class path 搜索顺序：\n1. 启动类路径（bootstrap classpath）:jre\\lib （可通过-Xbootclasspath参数修改该路径）\n2. 扩展类路径（extension classpath）:jre\\lib\\ext\n3. 用户类路径（user classpath）:用户自己指定\n\n<!-- more -->\n\n### 实现\n1. Entry接口用来定义启动类的基本功能\n\n{% codeblock lang:go %}\nconst pathListSeparator = string(os.PathListSeparator) //获取当前操作系统分隔符\n\ntype Entry interface {\n\treadClass(classNme string) ([]byte,Entry,error) //定义按class名读取class文件的方\n\tString() string \n}\n\n//根据classpath生成对应的启动类\nfunc newEntry(path string) Entry {\n\tif strings.Contains(path,pathListSeparator){ //classpath路径包含系统分割符时，new组合启动类\n\t\treturn newCompositeEntry(path)\n\t}\n\n\tif strings.HasSuffix(path,\"*\") {\n\t\treturn newWildcardEntry(path) //classpath路径包含*时，new通配符启动类\n\t}\n\n\tif strings.HasSuffix(path, \".jar\") || strings.HasSuffix(path, \".JAR\") ||\n      strings.HasSuffix(path, \".zip\") || strings.HasSuffix(path, \".ZIP\") {\n      return newZipEntry(path) //classpath路径包含jar、JAR、zip、ZIP时，new文件夹启动类\n   }\n\treturn newDirEntry(path)\n\n}\n{% endcodeblock %}\n\n2. Entry接口的具体实现\n * DirEntry，按照文件路径读取文件二进制流 \n{% codeblock lang:golang %}\ntype DirEntry struct {\n\tabsDir string //存储文件夹路径\n}\n\nfunc newDirEntry(path string) *DirEntry {\n\tabsDir,err := filepath.Abs(path) //如果文件路径存在，获取文件夹路径\n\tif err != nil {\n\t\tpanic(err) //文件路径不存在时提示错误\n\t}\n\n\treturn &DirEntry{absDir} //返回DirEntry实例\n}\n\nfunc (self *DirEntry) readClass(className string) ([]byte,Entry,error){\n\tfileName := filepath.Join(self.absDir,className) //拼接文件夹路径和classname\n\tdata,err := ioutil.ReadFile(fileName) //读取文件\n\treturn data,self,err //返回文件内容\n}\n\nfunc(self *DirEntry) String() string {\n\treturn self.absDir //返回文件夹路径\n}\n{% endcodeblock %}\n\n * ZipEntry,读取压缩文件夹内的文件\n{% codeblock lang:golang %}\ntype ZipEnty struct {\n\tabsPath string //文件夹路径\n}\n\nfunc newZipEntry(path string) *ZipEnty {\n\tabsPath, err := filepath.Abs(path) //如果文件路径存在，获取文件夹路径\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &ZipEnty{absPath}\n}\n\nfunc (self *ZipEnty) readClass(className string) ([]byte,Entry,error){\n\tr, err := zip.OpenReader(self.absPath) //以压缩文件格式解压\n\tif err != nil {\n\t   return nil, nil, err\n\t}\n\tdefer r.Close() //最后关闭文件流\n\tfor _, f := range r.File { //循环解压出来的文件\n\t   if f.Name == className { //如果当前文件为指定文件\n\t\t  rc, err := f.Open() //打开该文件\n\t\t  if err != nil {\n\t\t\t return nil, nil, err\n\t\t  }\n\t\t  defer rc.Close() //最后关闭文件\n\t\t  data, err := ioutil.ReadAll(rc) //读取文件流\n\t\t  if err != nil {\n\t\t\t return nil, nil, err\n\t\t  }\n\t\t  return data, self, nil //返回文件流\n\t   }\n\t}\n\treturn nil, nil, errors.New(\"class not found: \" + className)\n}\n\nfunc (self *ZipEnty) String() string {\n\treturn self.absPath\n}\n{% endcodeblock %}\n\n * CompositeEntry,读取符合文件类型\n{% codeblock lang:golang %}\ntype CompositeEntry []Entry //CompositeEntry为多种Entry的数组（Dir、Zip）\n\nfunc newCompositeEntry(pathList string) CompositeEntry {\n\tcompositeEntry := []Entry{} //实例Entry接口数组\n\n\tfor _,path := range strings.Split(pathList,pathListSeparator){ //按照系统分割符截取path列表，并循环\n\t\tentry := newEntry(path) //按照每种path实例化不同的Entry(Dir、Zip、Wildcard)\n\t\tcompositeEntry = append(compositeEntry,entry) //将实例化的不同Entry放入CompositeEntry数组中\n\t}\n\treturn compositeEntry\n}\n\nfunc (self CompositeEntry) readClass(className string)([]byte,Entry,error){\n\tfor _, entry := range self { //循环compositeEntry数组\n\t\tdata, from, err := entry.readClass(className) //根据不同Entry(Dir、Zip、Wildcard)，按指定classname读取文件\n\t\tif err == nil {\n\t\t   return data, from, nil //返回读取结果\n\t\t}\n\t }\n\t return nil, nil, errors.New(\"class not found: \" + className) //无结果是返回错误信息\n}\n\nfunc (self CompositeEntry) String() string {\n\tstrs := make([]string, len(self)) //按照CompositeEntry的长度申明该长度的Sring数组\n\tfor i, entry := range self { //循环CompositeEntry\n\t   strs[i] = entry.String() //调用每个Entry(Dir、Zip、Wildcard)实现类的String()方法,并放入String数组中\n\t}\n\treturn strings.Join(strs, pathListSeparator) //将String数组中的结果以系统分隔符拼接并返回\n}\n{% endcodeblock %}\n\n * WildcardEntry，按照通配符解析文件\n{% codeblock lang:golang %}\nfunc newWildcardEntry(path string) CompositeEntry {\n\tbaseDir := path[:len(path)-1] // remove *\n\tcompositeEntry := []Entry{} //申明compositeEntry对象(Entry的数组)\n\twalkFn := func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t   return err\n\t\t}\n\t\tif info.IsDir() && path != baseDir { //如果当前目录是文件夹，并且是根目录\n\t\t   return filepath.SkipDir //返回SkipDir的错误\n\t\t}\n\t\tif strings.HasSuffix(path, \".jar\") || strings.HasSuffix(path, \".JAR\") { //如果当前路径是以.jar或.JAR结尾的\n\t\t\tjarEntry := newZipEntry(path) //实例化ZipEntry\n\t\t\tcompositeEntry = append(compositeEntry, jarEntry) //将实例化的ZipEntry对象放入compositeEntry数组中\n\t\t }\n\t\t return nil\n\t  }\n\tfilepath.Walk(baseDir, walkFn) //将walkFn方法传递给filepath.Walk\n\treturn compositeEntry //返回结果\n }\n{% endcodeblock %}\n\n* Classpath，-cp|classpath参数解析实现的入口方法\n{% codeblock lang:golang %}\ntype Classpath struct { //Classpath包含java的三种基础启动路径\n\tbootClasspath Entry \n\textClasspath Entry\n\tuserClasspath Entry\n}\n\nfunc Parse(jreOption, cpOption string) * Classpath  {\n\tcp := &Classpath{} //实例化Classpath对象\n\tcp.parseBootAndExtClasspath(jreOption) //按照-Xjre参数解析Boot和Ext启动路径\n\tcp.parseUserClasspath(cpOption) //按照-cp|classpath参数解析User启动路径\n\treturn cp //返回设置好启动路径的Classpath对象\n}\n\nfunc (self *Classpath) ReadClass(className string) ([]byte,Entry,error){\n\tclassName = className + \".class\" //初始化className文件名\n\tif data, entry, err := self.bootClasspath.readClass(className); err == nil { //先扫描Boot启动路径下是否存在该className.class文件\n\t   return data, entry, err //存在则返回\n\t}\n\tif data, entry, err := self.extClasspath.readClass(className); err == nil { //再扫描Ext启动路径下是否存在该className.class文件\n\t   return data, entry, err //存在则返回\n\t}\n\treturn self.userClasspath.readClass(className) //以上两个路径下都不存在，则扫描User启动路径\n}\n\nfunc (self *Classpath) String() string  {\n\treturn self.userClasspath.String()\n}\n\nfunc (self *Classpath) parseBootAndExtClasspath(jreOption string) { //按照-Xjre参数解析Boot和Ext启动路径\n\tjreDir := getJreDir(jreOption) //获取jre路径\n   // jre/lib/*\n   jreLibPath := filepath.Join(jreDir, \"lib\", \"*\")\n   self.bootClasspath = newWildcardEntry(jreLibPath)\n   // jre/lib/ext/*\n   jreExtPath := filepath.Join(jreDir, \"lib\", \"ext\", \"*\")\n   self.extClasspath = newWildcardEntry(jreExtPath)\n}\n\nfunc getJreDir(jreOption string) string {\n\tif jreOption != \"\" && exists(jreOption) { //jreOption不为空且存在时返回该路径\n\t   return jreOption\n\t}\n\tif exists(\"./jre\") { //./jre路径存在时，返回.jre\n\t   return \"./jre\"\n\t}\n\tif jh := os.Getenv(\"JAVA_HOME\"); jh != \"\" { //环境变量JAVA_HOME存在并且不为空时\n\t   return filepath.Join(jh, \"jre\") //返回JAVA_HOME + \"jre\"\n\t}\n\tpanic(\"Can not find jre folder!\")\n }\n\n func exists(path string) bool {\n\tif _, err := os.Stat(path); err != nil {\n\t   if os.IsNotExist(err) {\n\t\t  return false\n\t   }\n\t}\n\treturn true\n }\n\n func (self *Classpath) parseUserClasspath(cpOption string) { //按照-cp|classpath参数解析User启动参数\n\tif cpOption == \"\" { //cpOption为空时\n\t   cpOption = \".\" //返回相对路劲\n\t}\n\tself.userClasspath = newEntry(cpOption) //根据-cp|classpath参数实例化对应的Entry\n }\n{% endcodeblock %}\n\n * main，修改启动类\n{% codeblock lang:golang %}\nfunc startJVM(cmd *Cmd){\n\tcp := classpath.Parse(cmd.XjreOption, cmd.cpOption) //根据-Xjre和-cp|classpath参数实例化classpath对象实例\n\tfmt.Printf(\"classpath:%v class:%v args:%v\\n\",\n\t   cp, cmd.class, cmd.args)\n\tclassName := strings.Replace(cmd.class, \".\", \"/\", -1)\n\tclassData, _, err := cp.ReadClass(className) //按照3个启动路径查找并读取className文件\n\tif err != nil {\n\t   fmt.Printf(\"Could not find or load main class %s\\n\", cmd.class)\n\t   return\n\t}\n\tfmt.Printf(\"class data:%v\\n\", classData)\n}\n{% endcodeblock %}\n\n3. 试运行\n{% codeblock lang:shell %}\nPS D:\\work\\workspace_go\\src\\jvmgo\\ch02> go install\n\nPS D:\\work\\workspace_go\\bin> .\\ch02.exe -Xjre \"C:\\Program Files\\Java\\jre1.8.0_202\" java.lang.Object\nclasspath:D:\\work\\workspace_go\\bin class:java.lang.Object args:[]\nclass data:[202 254 186 190 0 0 0 52 0 75 3 0 15 66 63 8 0 16 8 0 36 8 0 40 1 0 3 40 41 73 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 3 40 41 86 1 0 21 40 73 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 4 40 74 41 86 1 0 5 40 74 73 41 86 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 41 90 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 86 1 0 8 60 99 108 105 110 105 116 62 1 0 6 60 105 110 105 116 62 1 0 1 64 1 0 4 67 111 100\n101 1 0 10 69 120 99 101 112 116 105 111 110 115 1 0 9 83 105 103 110 97 116 117 114 101 1 0 13 83 116 97 99 107 77 97 112 84 97 98 108 101 1 0 6 97 112 112 101 110 100 1 0 5 99 108 111 110 101 1 0 6 101 113\n117 97 108 115 1 0 8 102 105 110 97 108 105 122 101 1 0 8 103 101 116 67 108 97 115 115 1 0 7 103 101 116 78 97 109 101 1 0 8 104 97 115 104 67 111 100 101 1 0 15 106 97 118 97 47 108 97 110 103 47 67 108 97\n115 115 1 0 36 106 97 118 97 47 108 97 110 103 47 67 108 111 110 101 78 111 116 83 117 112 112 111 114 116 101 100 69 120 99 101 112 116 105 111 110 1 0 34 106 97 118 97 47 108 97 110 103 47 73 108 108 101 103 97 108 65 114 103 117 109 101 110 116 69 120 99 101 112 116 105 111 110 1 0 17 106 97 118 97 47 108 97 110 103 47 73 110 116 101 103 101 114 1 0 30 106 97 118 97 47 108 97 110 103 47 73 110 116 101 114 114\n117 112 116 101 100 69 120 99 101 112 116 105 111 110 1 0 16 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 1 0 23 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 1 0 19 106 97 118 97 47 108 97 110 103 47 84 104 114 111 119 97 98 108 101 1 0 37 110 97 110 111 115 101 99 111 110 100 32 116 105 109 101 111 117 116 32 118 97 108 117 101 32 111 117 116 32 111 102 32 114 97 110 103 101 1 0 6 110 111 116 105 102 121 1 0 9 110 111 116 105 102 121 65 108 108 1 0 15 114 101 103 105 115 116 101 114 78 97 116 105 118 101 115 1 0 25 116 105 109 101 111 117 116 32 118 97 108 117 101 32 105 115 32 110 101 103 97 116 105 118 101 1 0 11 116 111 72 101 120 83 116 114 105 110 103 1 0 8 116 111 83 116 114 105 110 103 1 0 4 119 97 105 116 7 0 28 7 0 29 7 0 30 7 0 31 7 0 32 7 0 33 7 0 34 7 0 35 1 0 19 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 59 1 0 22 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 60 42 62 59 1 0 45 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 59 12 0 27 0 5 12 0 15 0 8 12 0 39 0 8 12 0 43 0 10 12 0 25 0 52 12 0 26 0 7 12 0 42 0 7 12 0 41 0\n9 12 0 15 0 13 12 0 21 0 54 10 0 44 0 60 10 0 46 0 63 10 0 47 0 62 10 0 49 0 55 10 0 49 0 57 10 0 49 0 58 10 0 49 0 59 10 0 50 0 56 10 0 50 0 61 10 0 50 0 64 0 33 0 49 0 0 0 0 0 0 0 14 0 1 0 15 0 8 0 1 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 1 10 0 39 0 8 0 0 1 17 0 25 0 52 0 1 0 19 0 0 0 2 0 53 1 1 0 27 0 5 0 0 0 1 0 23 0 12 0 1 0 17 0 0 0 34 0 2 0 2 0 0 0 11 42 43 166 0 7 4 167 0 4 3 172 0 0 0 1 0 20 0 0 0 5\n0 2 9 64 1 1 4 0 22 0 6 0 1 0 18 0 0 0 4 0 1 0 45 0 1 0 42 0 7 0 1 0 17 0 0 0 48 0 2 0 1 0 0 0 36 187 0 50 89 183 0 72 42 182 0 71 182 0 65 182 0 74 18 2 182 0 74 42 182 0 68 184 0 67 182 0 74 182 0 73 176 0\n0 0 0 1 17 0 37 0 8 0 0 1 17 0 38 0 8 0 0 1 17 0 43 0 10 0 1 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 11 0 2 0 17 0 0 0 74 0 4 0 4 0 0 0 50 31 9 148 156 0 13 187 0 46 89 18 4 183 0 66 191 29 155 0 9 29 18 1 164 0 13 187 0 46 89 18 3 183 0 66 191 29 158 0 7 31 10 97 64 42 31 182 0 70 177 0 0 0 1 0 20 0 0 0 6 0 4 16 9 9 7 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 8 0 2 0 17 0 0 0 18 0 3 0 1 0 0 0 6 42 9 182 0 70 177 0 0 0 0 0 18\n0 0 0 4 0 1 0 48 0 4 0 24 0 8 0 2 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 0 18 0 0 0 4 0 1 0 51 0 8 0 14 0 8 0 1 0 17 0 0 0 16 0 0 0 0 0 0 0 4 184 0 69 177 0 0 0 0 0 0]\n{% endcodeblock %}\n","slug":"自己动手写Java虚拟机-笔记2","published":1,"updated":"2019-09-13T08:46:55.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck791jeiu0021isnyood8385o","content":"<h2 id=\"实现cp-classpath-参数搜索class文件\"><a href=\"#实现cp-classpath-参数搜索class文件\" class=\"headerlink\" title=\"实现cp/classpath 参数搜索class文件\"></a>实现cp/classpath 参数搜索class文件</h2><h3 id=\"java-class-path-搜索顺序：\"><a href=\"#java-class-path-搜索顺序：\" class=\"headerlink\" title=\"java class path 搜索顺序：\"></a>java class path 搜索顺序：</h3><ol>\n<li>启动类路径（bootstrap classpath）:jre\\lib （可通过-Xbootclasspath参数修改该路径）</li>\n<li>扩展类路径（extension classpath）:jre\\lib\\ext</li>\n<li>用户类路径（user classpath）:用户自己指定</li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li>Entry接口用来定义启动类的基本功能</li>\n</ol>\n<figure class=\"highlight go hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">const</span> pathListSeparator = <span class=\"hljs-keyword\">string</span>(os.PathListSeparator) <span class=\"hljs-comment\">//获取当前操作系统分隔符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-keyword\">type</span> Entry <span class=\"hljs-keyword\">interface</span> &#123;</span><br><span class=\"line\">\treadClass(classNme <span class=\"hljs-keyword\">string</span>) ([]<span class=\"hljs-keyword\">byte</span>,Entry,error) <span class=\"hljs-comment\">//定义按class名读取class文件的方</span></span><br><span class=\"line\">\tString() <span class=\"hljs-keyword\">string</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-comment\">//根据classpath生成对应的启动类</span></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newEntry</span><span class=\"hljs-params\">(path <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">Entry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> strings.Contains(path,pathListSeparator)&#123; <span class=\"hljs-comment\">//classpath路径包含系统分割符时，new组合启动类</span></span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span> newCompositeEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> strings.HasSuffix(path,<span class=\"hljs-string\">\"*\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">return</span> newWildcardEntry(path) <span class=\"hljs-comment\">//classpath路径包含*时，new通配符启动类</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> strings.HasSuffix(path, <span class=\"hljs-string\">\".jar\"</span>) || strings.HasSuffix(path, <span class=\"hljs-string\">\".JAR\"</span>) ||</span><br><span class=\"line\">      strings.HasSuffix(path, <span class=\"hljs-string\">\".zip\"</span>) || strings.HasSuffix(path, <span class=\"hljs-string\">\".ZIP\"</span>) &#123;</span><br><span class=\"line\">      <span class=\"hljs-keyword\">return</span> newZipEntry(path) <span class=\"hljs-comment\">//classpath路径包含jar、JAR、zip、ZIP时，new文件夹启动类</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> newDirEntry(path)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>Entry接口的具体实现</p>\n<ul>\n<li><p>DirEntry，按照文件路径读取文件二进制流 </p>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> DirEntry <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\tabsDir <span class=\"hljs-keyword\">string</span> <span class=\"hljs-comment\">//存储文件夹路径</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newDirEntry</span><span class=\"hljs-params\">(path <span class=\"hljs-keyword\">string</span>)</span> *<span class=\"hljs-title\">DirEntry</span></span> &#123;</span><br><span class=\"line\">\tabsDir,err := filepath.Abs(path) <span class=\"hljs-comment\">//如果文件路径存在，获取文件夹路径</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-built_in\">panic</span>(err) <span class=\"hljs-comment\">//文件路径不存在时提示错误</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> &amp;DirEntry&#123;absDir&#125; <span class=\"hljs-comment\">//返回DirEntry实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *DirEntry)</span> <span class=\"hljs-title\">readClass</span><span class=\"hljs-params\">(className <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\tfileName := filepath.Join(self.absDir,className) <span class=\"hljs-comment\">//拼接文件夹路径和classname</span></span><br><span class=\"line\">\tdata,err := ioutil.ReadFile(fileName) <span class=\"hljs-comment\">//读取文件</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> data,self,err <span class=\"hljs-comment\">//返回文件内容</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(self *DirEntry)</span> <span class=\"hljs-title\">String</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.absDir <span class=\"hljs-comment\">//返回文件夹路径</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ZipEntry,读取压缩文件夹内的文件</p>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> ZipEnty <span class=\"hljs-keyword\">struct</span> &#123;</span><br><span class=\"line\">\tabsPath <span class=\"hljs-keyword\">string</span> <span class=\"hljs-comment\">//文件夹路径</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newZipEntry</span><span class=\"hljs-params\">(path <span class=\"hljs-keyword\">string</span>)</span> *<span class=\"hljs-title\">ZipEnty</span></span> &#123;</span><br><span class=\"line\">\tabsPath, err := filepath.Abs(path) <span class=\"hljs-comment\">//如果文件路径存在，获取文件夹路径</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> &amp;ZipEnty&#123;absPath&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ZipEnty)</span> <span class=\"hljs-title\">readClass</span><span class=\"hljs-params\">(className <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\tr, err := zip.OpenReader(self.absPath) <span class=\"hljs-comment\">//以压缩文件格式解压</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">defer</span> r.Close() <span class=\"hljs-comment\">//最后关闭文件流</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">for</span> _, f := <span class=\"hljs-keyword\">range</span> r.File &#123; <span class=\"hljs-comment\">//循环解压出来的文件</span></span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">if</span> f.Name == className &#123; <span class=\"hljs-comment\">//如果当前文件为指定文件</span></span><br><span class=\"line\">\t\t  rc, err := f.Open() <span class=\"hljs-comment\">//打开该文件</span></span><br><span class=\"line\">\t\t  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">nil</span>, err</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  <span class=\"hljs-keyword\">defer</span> rc.Close() <span class=\"hljs-comment\">//最后关闭文件</span></span><br><span class=\"line\">\t\t  data, err := ioutil.ReadAll(rc) <span class=\"hljs-comment\">//读取文件流</span></span><br><span class=\"line\">\t\t  <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">nil</span>, err</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  <span class=\"hljs-keyword\">return</span> data, self, <span class=\"hljs-literal\">nil</span> <span class=\"hljs-comment\">//返回文件流</span></span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">nil</span>, errors.New(<span class=\"hljs-string\">\"class not found: \"</span> + className)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *ZipEnty)</span> <span class=\"hljs-title\">String</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.absPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CompositeEntry,读取符合文件类型</p>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> CompositeEntry []Entry <span class=\"hljs-comment\">//CompositeEntry为多种Entry的数组（Dir、Zip）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newCompositeEntry</span><span class=\"hljs-params\">(pathList <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\tcompositeEntry := []Entry&#123;&#125; <span class=\"hljs-comment\">//实例Entry接口数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">for</span> _,path := <span class=\"hljs-keyword\">range</span> strings.Split(pathList,pathListSeparator)&#123; <span class=\"hljs-comment\">//按照系统分割符截取path列表，并循环</span></span><br><span class=\"line\">\t\tentry := newEntry(path) <span class=\"hljs-comment\">//按照每种path实例化不同的Entry(Dir、Zip、Wildcard)</span></span><br><span class=\"line\">\t\tcompositeEntry = <span class=\"hljs-built_in\">append</span>(compositeEntry,entry) <span class=\"hljs-comment\">//将实例化的不同Entry放入CompositeEntry数组中</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> compositeEntry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self CompositeEntry)</span> <span class=\"hljs-title\">readClass</span><span class=\"hljs-params\">(className <span class=\"hljs-keyword\">string</span>)</span><span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">for</span> _, entry := <span class=\"hljs-keyword\">range</span> self &#123; <span class=\"hljs-comment\">//循环compositeEntry数组</span></span><br><span class=\"line\">\t\tdata, from, err := entry.readClass(className) <span class=\"hljs-comment\">//根据不同Entry(Dir、Zip、Wildcard)，按指定classname读取文件</span></span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t   <span class=\"hljs-keyword\">return</span> data, from, <span class=\"hljs-literal\">nil</span> <span class=\"hljs-comment\">//返回读取结果</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-literal\">nil</span>, errors.New(<span class=\"hljs-string\">\"class not found: \"</span> + className) <span class=\"hljs-comment\">//无结果是返回错误信息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self CompositeEntry)</span> <span class=\"hljs-title\">String</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\tstrs := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-built_in\">len</span>(self)) <span class=\"hljs-comment\">//按照CompositeEntry的长度申明该长度的Sring数组</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">for</span> i, entry := <span class=\"hljs-keyword\">range</span> self &#123; <span class=\"hljs-comment\">//循环CompositeEntry</span></span><br><span class=\"line\">\t   strs[i] = entry.String() <span class=\"hljs-comment\">//调用每个Entry(Dir、Zip、Wildcard)实现类的String()方法,并放入String数组中</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> strings.Join(strs, pathListSeparator) <span class=\"hljs-comment\">//将String数组中的结果以系统分隔符拼接并返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>WildcardEntry，按照通配符解析文件</p>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">newWildcardEntry</span><span class=\"hljs-params\">(path <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\tbaseDir := path[:<span class=\"hljs-built_in\">len</span>(path)<span class=\"hljs-number\">-1</span>] <span class=\"hljs-comment\">// remove *</span></span><br><span class=\"line\">\tcompositeEntry := []Entry&#123;&#125; <span class=\"hljs-comment\">//申明compositeEntry对象(Entry的数组)</span></span><br><span class=\"line\">\twalkFn := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(path <span class=\"hljs-keyword\">string</span>, info os.FileInfo, err error)</span> <span class=\"hljs-title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t   <span class=\"hljs-keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span> info.IsDir() &amp;&amp; path != baseDir &#123; <span class=\"hljs-comment\">//如果当前目录是文件夹，并且是根目录</span></span><br><span class=\"line\">\t\t   <span class=\"hljs-keyword\">return</span> filepath.SkipDir <span class=\"hljs-comment\">//返回SkipDir的错误</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"hljs-keyword\">if</span> strings.HasSuffix(path, <span class=\"hljs-string\">\".jar\"</span>) || strings.HasSuffix(path, <span class=\"hljs-string\">\".JAR\"</span>) &#123; <span class=\"hljs-comment\">//如果当前路径是以.jar或.JAR结尾的</span></span><br><span class=\"line\">\t\t\tjarEntry := newZipEntry(path) <span class=\"hljs-comment\">//实例化ZipEntry</span></span><br><span class=\"line\">\t\t\tcompositeEntry = <span class=\"hljs-built_in\">append</span>(compositeEntry, jarEntry) <span class=\"hljs-comment\">//将实例化的ZipEntry对象放入compositeEntry数组中</span></span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span></span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\tfilepath.Walk(baseDir, walkFn) <span class=\"hljs-comment\">//将walkFn方法传递给filepath.Walk</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> compositeEntry <span class=\"hljs-comment\">//返回结果</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>Classpath，-cp|classpath参数解析实现的入口方法</p>\n<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-keyword\">type</span> Classpath <span class=\"hljs-keyword\">struct</span> &#123; <span class=\"hljs-comment\">//Classpath包含java的三种基础启动路径</span></span><br><span class=\"line\">\tbootClasspath Entry </span><br><span class=\"line\">\textClasspath Entry</span><br><span class=\"line\">\tuserClasspath Entry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">Parse</span><span class=\"hljs-params\">(jreOption, cpOption <span class=\"hljs-keyword\">string</span>)</span> * <span class=\"hljs-title\">Classpath</span></span>  &#123;</span><br><span class=\"line\">\tcp := &amp;Classpath&#123;&#125; <span class=\"hljs-comment\">//实例化Classpath对象</span></span><br><span class=\"line\">\tcp.parseBootAndExtClasspath(jreOption) <span class=\"hljs-comment\">//按照-Xjre参数解析Boot和Ext启动路径</span></span><br><span class=\"line\">\tcp.parseUserClasspath(cpOption) <span class=\"hljs-comment\">//按照-cp|classpath参数解析User启动路径</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> cp <span class=\"hljs-comment\">//返回设置好启动路径的Classpath对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Classpath)</span> <span class=\"hljs-title\">ReadClass</span><span class=\"hljs-params\">(className <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\tclassName = className + <span class=\"hljs-string\">\".class\"</span> <span class=\"hljs-comment\">//初始化className文件名</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> data, entry, err := self.bootClasspath.readClass(className); err == <span class=\"hljs-literal\">nil</span> &#123; <span class=\"hljs-comment\">//先扫描Boot启动路径下是否存在该className.class文件</span></span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">return</span> data, entry, err <span class=\"hljs-comment\">//存在则返回</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> data, entry, err := self.extClasspath.readClass(className); err == <span class=\"hljs-literal\">nil</span> &#123; <span class=\"hljs-comment\">//再扫描Ext启动路径下是否存在该className.class文件</span></span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">return</span> data, entry, err <span class=\"hljs-comment\">//存在则返回</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.userClasspath.readClass(className) <span class=\"hljs-comment\">//以上两个路径下都不存在，则扫描User启动路径</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Classpath)</span> <span class=\"hljs-title\">String</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> self.userClasspath.String()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Classpath)</span> <span class=\"hljs-title\">parseBootAndExtClasspath</span><span class=\"hljs-params\">(jreOption <span class=\"hljs-keyword\">string</span>)</span></span> &#123; <span class=\"hljs-comment\">//按照-Xjre参数解析Boot和Ext启动路径</span></span><br><span class=\"line\">\tjreDir := getJreDir(jreOption) <span class=\"hljs-comment\">//获取jre路径</span></span><br><span class=\"line\">   <span class=\"hljs-comment\">// jre/lib/*</span></span><br><span class=\"line\">   jreLibPath := filepath.Join(jreDir, <span class=\"hljs-string\">\"lib\"</span>, <span class=\"hljs-string\">\"*\"</span>)</span><br><span class=\"line\">   self.bootClasspath = newWildcardEntry(jreLibPath)</span><br><span class=\"line\">   <span class=\"hljs-comment\">// jre/lib/ext/*</span></span><br><span class=\"line\">   jreExtPath := filepath.Join(jreDir, <span class=\"hljs-string\">\"lib\"</span>, <span class=\"hljs-string\">\"ext\"</span>, <span class=\"hljs-string\">\"*\"</span>)</span><br><span class=\"line\">   self.extClasspath = newWildcardEntry(jreExtPath)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">getJreDir</span><span class=\"hljs-params\">(jreOption <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> jreOption != <span class=\"hljs-string\">\"\"</span> &amp;&amp; exists(jreOption) &#123; <span class=\"hljs-comment\">//jreOption不为空且存在时返回该路径</span></span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">return</span> jreOption</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> exists(<span class=\"hljs-string\">\"./jre\"</span>) &#123; <span class=\"hljs-comment\">//./jre路径存在时，返回.jre</span></span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"./jre\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> jh := os.Getenv(<span class=\"hljs-string\">\"JAVA_HOME\"</span>); jh != <span class=\"hljs-string\">\"\"</span> &#123; <span class=\"hljs-comment\">//环境变量JAVA_HOME存在并且不为空时</span></span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">return</span> filepath.Join(jh, <span class=\"hljs-string\">\"jre\"</span>) <span class=\"hljs-comment\">//返回JAVA_HOME + \"jre\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-built_in\">panic</span>(<span class=\"hljs-string\">\"Can not find jre folder!\"</span>)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">exists</span><span class=\"hljs-params\">(path <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> _, err := os.Stat(path); err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">if</span> os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\t  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span></span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(self *Classpath)</span> <span class=\"hljs-title\">parseUserClasspath</span><span class=\"hljs-params\">(cpOption <span class=\"hljs-keyword\">string</span>)</span></span> &#123; <span class=\"hljs-comment\">//按照-cp|classpath参数解析User启动参数</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> cpOption == <span class=\"hljs-string\">\"\"</span> &#123; <span class=\"hljs-comment\">//cpOption为空时</span></span><br><span class=\"line\">\t   cpOption = <span class=\"hljs-string\">\".\"</span> <span class=\"hljs-comment\">//返回相对路劲</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tself.userClasspath = newEntry(cpOption) <span class=\"hljs-comment\">//根据-cp|classpath参数实例化对应的Entry</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>main，修改启动类<figure class=\"highlight golang hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">startJVM</span><span class=\"hljs-params\">(cmd *Cmd)</span></span>&#123;</span><br><span class=\"line\">\tcp := classpath.Parse(cmd.XjreOption, cmd.cpOption) <span class=\"hljs-comment\">//根据-Xjre和-cp|classpath参数实例化classpath对象实例</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"hljs-string\">\"classpath:%v class:%v args:%v\\n\"</span>,</span><br><span class=\"line\">\t   cp, cmd.class, cmd.args)</span><br><span class=\"line\">\tclassName := strings.Replace(cmd.class, <span class=\"hljs-string\">\".\"</span>, <span class=\"hljs-string\">\"/\"</span>, <span class=\"hljs-number\">-1</span>)</span><br><span class=\"line\">\tclassData, _, err := cp.ReadClass(className) <span class=\"hljs-comment\">//按照3个启动路径查找并读取className文件</span></span><br><span class=\"line\">\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> &#123;</span><br><span class=\"line\">\t   fmt.Printf(<span class=\"hljs-string\">\"Could not find or load main class %s\\n\"</span>, cmd.class)</span><br><span class=\"line\">\t   <span class=\"hljs-keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"hljs-string\">\"class data:%v\\n\"</span>, classData)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>试运行<figure class=\"highlight shell hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS D:\\work\\workspace_go\\src\\jvmgo\\ch02&gt; go install</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch02.exe -Xjre \"C:\\Program Files\\Java\\jre1.8.0_202\" java.lang.Object</span><br><span class=\"line\">classpath:D:\\work\\workspace_go\\bin class:java.lang.Object args:[]</span><br><span class=\"line\">class data:[202 254 186 190 0 0 0 52 0 75 3 0 15 66 63 8 0 16 8 0 36 8 0 40 1 0 3 40 41 73 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 3 40 41 86 1 0 21 40 73 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 4 40 74 41 86 1 0 5 40 74 73 41 86 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 41 90 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 86 1 0 8 60 99 108 105 110 105 116 62 1 0 6 60 105 110 105 116 62 1 0 1 64 1 0 4 67 111 100</span><br><span class=\"line\">101 1 0 10 69 120 99 101 112 116 105 111 110 115 1 0 9 83 105 103 110 97 116 117 114 101 1 0 13 83 116 97 99 107 77 97 112 84 97 98 108 101 1 0 6 97 112 112 101 110 100 1 0 5 99 108 111 110 101 1 0 6 101 113</span><br><span class=\"line\">117 97 108 115 1 0 8 102 105 110 97 108 105 122 101 1 0 8 103 101 116 67 108 97 115 115 1 0 7 103 101 116 78 97 109 101 1 0 8 104 97 115 104 67 111 100 101 1 0 15 106 97 118 97 47 108 97 110 103 47 67 108 97</span><br><span class=\"line\">115 115 1 0 36 106 97 118 97 47 108 97 110 103 47 67 108 111 110 101 78 111 116 83 117 112 112 111 114 116 101 100 69 120 99 101 112 116 105 111 110 1 0 34 106 97 118 97 47 108 97 110 103 47 73 108 108 101 103 97 108 65 114 103 117 109 101 110 116 69 120 99 101 112 116 105 111 110 1 0 17 106 97 118 97 47 108 97 110 103 47 73 110 116 101 103 101 114 1 0 30 106 97 118 97 47 108 97 110 103 47 73 110 116 101 114 114</span><br><span class=\"line\">117 112 116 101 100 69 120 99 101 112 116 105 111 110 1 0 16 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 1 0 23 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 1 0 19 106 97 118 97 47 108 97 110 103 47 84 104 114 111 119 97 98 108 101 1 0 37 110 97 110 111 115 101 99 111 110 100 32 116 105 109 101 111 117 116 32 118 97 108 117 101 32 111 117 116 32 111 102 32 114 97 110 103 101 1 0 6 110 111 116 105 102 121 1 0 9 110 111 116 105 102 121 65 108 108 1 0 15 114 101 103 105 115 116 101 114 78 97 116 105 118 101 115 1 0 25 116 105 109 101 111 117 116 32 118 97 108 117 101 32 105 115 32 110 101 103 97 116 105 118 101 1 0 11 116 111 72 101 120 83 116 114 105 110 103 1 0 8 116 111 83 116 114 105 110 103 1 0 4 119 97 105 116 7 0 28 7 0 29 7 0 30 7 0 31 7 0 32 7 0 33 7 0 34 7 0 35 1 0 19 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 59 1 0 22 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 60 42 62 59 1 0 45 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 59 12 0 27 0 5 12 0 15 0 8 12 0 39 0 8 12 0 43 0 10 12 0 25 0 52 12 0 26 0 7 12 0 42 0 7 12 0 41 0</span><br><span class=\"line\">9 12 0 15 0 13 12 0 21 0 54 10 0 44 0 60 10 0 46 0 63 10 0 47 0 62 10 0 49 0 55 10 0 49 0 57 10 0 49 0 58 10 0 49 0 59 10 0 50 0 56 10 0 50 0 61 10 0 50 0 64 0 33 0 49 0 0 0 0 0 0 0 14 0 1 0 15 0 8 0 1 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 1 10 0 39 0 8 0 0 1 17 0 25 0 52 0 1 0 19 0 0 0 2 0 53 1 1 0 27 0 5 0 0 0 1 0 23 0 12 0 1 0 17 0 0 0 34 0 2 0 2 0 0 0 11 42 43 166 0 7 4 167 0 4 3 172 0 0 0 1 0 20 0 0 0 5</span><br><span class=\"line\">0 2 9 64 1 1 4 0 22 0 6 0 1 0 18 0 0 0 4 0 1 0 45 0 1 0 42 0 7 0 1 0 17 0 0 0 48 0 2 0 1 0 0 0 36 187 0 50 89 183 0 72 42 182 0 71 182 0 65 182 0 74 18 2 182 0 74 42 182 0 68 184 0 67 182 0 74 182 0 73 176 0</span><br><span class=\"line\">0 0 0 1 17 0 37 0 8 0 0 1 17 0 38 0 8 0 0 1 17 0 43 0 10 0 1 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 11 0 2 0 17 0 0 0 74 0 4 0 4 0 0 0 50 31 9 148 156 0 13 187 0 46 89 18 4 183 0 66 191 29 155 0 9 29 18 1 164 0 13 187 0 46 89 18 3 183 0 66 191 29 158 0 7 31 10 97 64 42 31 182 0 70 177 0 0 0 1 0 20 0 0 0 6 0 4 16 9 9 7 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 8 0 2 0 17 0 0 0 18 0 3 0 1 0 0 0 6 42 9 182 0 70 177 0 0 0 0 0 18</span><br><span class=\"line\">0 0 0 4 0 1 0 48 0 4 0 24 0 8 0 2 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 0 18 0 0 0 4 0 1 0 51 0 8 0 14 0 8 0 1 0 17 0 0 0 16 0 0 0 0 0 0 0 4 184 0 69 177 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"_categories":[{"name":"Technology","path":"categories/Technology/"}],"_tags":[{"name":"JVM","path":"tags/JVM/"},{"name":"Java","path":"tags/Java/"},{"name":"Go","path":"tags/Go/"}],"excerpt":"<h2 id=\"实现cp-classpath-参数搜索class文件\"><a href=\"#实现cp-classpath-参数搜索class文件\" class=\"headerlink\" title=\"实现cp/classpath 参数搜索class文件\"></a>实现cp/classpath 参数搜索class文件</h2><h3 id=\"java-class-path-搜索顺序：\"><a href=\"#java-class-path-搜索顺序：\" class=\"headerlink\" title=\"java class path 搜索顺序：\"></a>java class path 搜索顺序：</h3><ol>\n<li>启动类路径（bootstrap classpath）:jre\\lib （可通过-Xbootclasspath参数修改该路径）</li>\n<li>扩展类路径（extension classpath）:jre\\lib\\ext</li>\n<li>用户类路径（user classpath）:用户自己指定</li>\n</ol>","more":"<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ol>\n<li>Entry接口用来定义启动类的基本功能</li>\n</ol>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pathListSeparator = <span class=\"keyword\">string</span>(os.PathListSeparator) <span class=\"comment\">//获取当前操作系统分隔符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Entry <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\treadClass(classNme <span class=\"keyword\">string</span>) ([]<span class=\"keyword\">byte</span>,Entry,error) <span class=\"comment\">//定义按class名读取class文件的方</span></span><br><span class=\"line\">\tString() <span class=\"keyword\">string</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据classpath生成对应的启动类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">Entry</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.Contains(path,pathListSeparator)&#123; <span class=\"comment\">//classpath路径包含系统分割符时，new组合启动类</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newCompositeEntry(path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.HasSuffix(path,<span class=\"string\">\"*\"</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> newWildcardEntry(path) <span class=\"comment\">//classpath路径包含*时，new通配符启动类</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> strings.HasSuffix(path, <span class=\"string\">\".jar\"</span>) || strings.HasSuffix(path, <span class=\"string\">\".JAR\"</span>) ||</span><br><span class=\"line\">      strings.HasSuffix(path, <span class=\"string\">\".zip\"</span>) || strings.HasSuffix(path, <span class=\"string\">\".ZIP\"</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> newZipEntry(path) <span class=\"comment\">//classpath路径包含jar、JAR、zip、ZIP时，new文件夹启动类</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newDirEntry(path)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>Entry接口的具体实现</p>\n<ul>\n<li><p>DirEntry，按照文件路径读取文件二进制流 </p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> DirEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tabsDir <span class=\"keyword\">string</span> <span class=\"comment\">//存储文件夹路径</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newDirEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> *<span class=\"title\">DirEntry</span></span> &#123;</span><br><span class=\"line\">\tabsDir,err := filepath.Abs(path) <span class=\"comment\">//如果文件路径存在，获取文件夹路径</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err) <span class=\"comment\">//文件路径不存在时提示错误</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;DirEntry&#123;absDir&#125; <span class=\"comment\">//返回DirEntry实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *DirEntry)</span> <span class=\"title\">readClass</span><span class=\"params\">(className <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\tfileName := filepath.Join(self.absDir,className) <span class=\"comment\">//拼接文件夹路径和classname</span></span><br><span class=\"line\">\tdata,err := ioutil.ReadFile(fileName) <span class=\"comment\">//读取文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data,self,err <span class=\"comment\">//返回文件内容</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(self *DirEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.absDir <span class=\"comment\">//返回文件夹路径</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ZipEntry,读取压缩文件夹内的文件</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ZipEnty <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tabsPath <span class=\"keyword\">string</span> <span class=\"comment\">//文件夹路径</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newZipEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> *<span class=\"title\">ZipEnty</span></span> &#123;</span><br><span class=\"line\">\tabsPath, err := filepath.Abs(path) <span class=\"comment\">//如果文件路径存在，获取文件夹路径</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ZipEnty&#123;absPath&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ZipEnty)</span> <span class=\"title\">readClass</span><span class=\"params\">(className <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\tr, err := zip.OpenReader(self.absPath) <span class=\"comment\">//以压缩文件格式解压</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> r.Close() <span class=\"comment\">//最后关闭文件流</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, f := <span class=\"keyword\">range</span> r.File &#123; <span class=\"comment\">//循环解压出来的文件</span></span><br><span class=\"line\">\t   <span class=\"keyword\">if</span> f.Name == className &#123; <span class=\"comment\">//如果当前文件为指定文件</span></span><br><span class=\"line\">\t\t  rc, err := f.Open() <span class=\"comment\">//打开该文件</span></span><br><span class=\"line\">\t\t  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">defer</span> rc.Close() <span class=\"comment\">//最后关闭文件</span></span><br><span class=\"line\">\t\t  data, err := ioutil.ReadAll(rc) <span class=\"comment\">//读取文件流</span></span><br><span class=\"line\">\t\t  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> data, self, <span class=\"literal\">nil</span> <span class=\"comment\">//返回文件流</span></span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, errors.New(<span class=\"string\">\"class not found: \"</span> + className)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *ZipEnty)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.absPath</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CompositeEntry,读取符合文件类型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CompositeEntry []Entry <span class=\"comment\">//CompositeEntry为多种Entry的数组（Dir、Zip）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newCompositeEntry</span><span class=\"params\">(pathList <span class=\"keyword\">string</span>)</span> <span class=\"title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\tcompositeEntry := []Entry&#123;&#125; <span class=\"comment\">//实例Entry接口数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _,path := <span class=\"keyword\">range</span> strings.Split(pathList,pathListSeparator)&#123; <span class=\"comment\">//按照系统分割符截取path列表，并循环</span></span><br><span class=\"line\">\t\tentry := newEntry(path) <span class=\"comment\">//按照每种path实例化不同的Entry(Dir、Zip、Wildcard)</span></span><br><span class=\"line\">\t\tcompositeEntry = <span class=\"built_in\">append</span>(compositeEntry,entry) <span class=\"comment\">//将实例化的不同Entry放入CompositeEntry数组中</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> compositeEntry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self CompositeEntry)</span> <span class=\"title\">readClass</span><span class=\"params\">(className <span class=\"keyword\">string</span>)</span><span class=\"params\">([]<span class=\"keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, entry := <span class=\"keyword\">range</span> self &#123; <span class=\"comment\">//循环compositeEntry数组</span></span><br><span class=\"line\">\t\tdata, from, err := entry.readClass(className) <span class=\"comment\">//根据不同Entry(Dir、Zip、Wildcard)，按指定classname读取文件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">return</span> data, from, <span class=\"literal\">nil</span> <span class=\"comment\">//返回读取结果</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>, errors.New(<span class=\"string\">\"class not found: \"</span> + className) <span class=\"comment\">//无结果是返回错误信息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self CompositeEntry)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tstrs := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(self)) <span class=\"comment\">//按照CompositeEntry的长度申明该长度的Sring数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, entry := <span class=\"keyword\">range</span> self &#123; <span class=\"comment\">//循环CompositeEntry</span></span><br><span class=\"line\">\t   strs[i] = entry.String() <span class=\"comment\">//调用每个Entry(Dir、Zip、Wildcard)实现类的String()方法,并放入String数组中</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> strings.Join(strs, pathListSeparator) <span class=\"comment\">//将String数组中的结果以系统分隔符拼接并返回</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>WildcardEntry，按照通配符解析文件</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newWildcardEntry</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">CompositeEntry</span></span> &#123;</span><br><span class=\"line\">\tbaseDir := path[:<span class=\"built_in\">len</span>(path)<span class=\"number\">-1</span>] <span class=\"comment\">// remove *</span></span><br><span class=\"line\">\tcompositeEntry := []Entry&#123;&#125; <span class=\"comment\">//申明compositeEntry对象(Entry的数组)</span></span><br><span class=\"line\">\twalkFn := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(path <span class=\"keyword\">string</span>, info os.FileInfo, err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t   <span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> info.IsDir() &amp;&amp; path != baseDir &#123; <span class=\"comment\">//如果当前目录是文件夹，并且是根目录</span></span><br><span class=\"line\">\t\t   <span class=\"keyword\">return</span> filepath.SkipDir <span class=\"comment\">//返回SkipDir的错误</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> strings.HasSuffix(path, <span class=\"string\">\".jar\"</span>) || strings.HasSuffix(path, <span class=\"string\">\".JAR\"</span>) &#123; <span class=\"comment\">//如果当前路径是以.jar或.JAR结尾的</span></span><br><span class=\"line\">\t\t\tjarEntry := newZipEntry(path) <span class=\"comment\">//实例化ZipEntry</span></span><br><span class=\"line\">\t\t\tcompositeEntry = <span class=\"built_in\">append</span>(compositeEntry, jarEntry) <span class=\"comment\">//将实例化的ZipEntry对象放入compositeEntry数组中</span></span><br><span class=\"line\">\t\t &#125;</span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\tfilepath.Walk(baseDir, walkFn) <span class=\"comment\">//将walkFn方法传递给filepath.Walk</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> compositeEntry <span class=\"comment\">//返回结果</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>Classpath，-cp|classpath参数解析实现的入口方法</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Classpath <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">//Classpath包含java的三种基础启动路径</span></span><br><span class=\"line\">\tbootClasspath Entry </span><br><span class=\"line\">\textClasspath Entry</span><br><span class=\"line\">\tuserClasspath Entry</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">(jreOption, cpOption <span class=\"keyword\">string</span>)</span> * <span class=\"title\">Classpath</span></span>  &#123;</span><br><span class=\"line\">\tcp := &amp;Classpath&#123;&#125; <span class=\"comment\">//实例化Classpath对象</span></span><br><span class=\"line\">\tcp.parseBootAndExtClasspath(jreOption) <span class=\"comment\">//按照-Xjre参数解析Boot和Ext启动路径</span></span><br><span class=\"line\">\tcp.parseUserClasspath(cpOption) <span class=\"comment\">//按照-cp|classpath参数解析User启动路径</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cp <span class=\"comment\">//返回设置好启动路径的Classpath对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">ReadClass</span><span class=\"params\">(className <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>,Entry,error)</span></span>&#123;</span><br><span class=\"line\">\tclassName = className + <span class=\"string\">\".class\"</span> <span class=\"comment\">//初始化className文件名</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> data, entry, err := self.bootClasspath.readClass(className); err == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">//先扫描Boot启动路径下是否存在该className.class文件</span></span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> data, entry, err <span class=\"comment\">//存在则返回</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> data, entry, err := self.extClasspath.readClass(className); err == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">//再扫描Ext启动路径下是否存在该className.class文件</span></span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> data, entry, err <span class=\"comment\">//存在则返回</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.userClasspath.readClass(className) <span class=\"comment\">//以上两个路径下都不存在，则扫描User启动路径</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> self.userClasspath.String()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">parseBootAndExtClasspath</span><span class=\"params\">(jreOption <span class=\"keyword\">string</span>)</span></span> &#123; <span class=\"comment\">//按照-Xjre参数解析Boot和Ext启动路径</span></span><br><span class=\"line\">\tjreDir := getJreDir(jreOption) <span class=\"comment\">//获取jre路径</span></span><br><span class=\"line\">   <span class=\"comment\">// jre/lib/*</span></span><br><span class=\"line\">   jreLibPath := filepath.Join(jreDir, <span class=\"string\">\"lib\"</span>, <span class=\"string\">\"*\"</span>)</span><br><span class=\"line\">   self.bootClasspath = newWildcardEntry(jreLibPath)</span><br><span class=\"line\">   <span class=\"comment\">// jre/lib/ext/*</span></span><br><span class=\"line\">   jreExtPath := filepath.Join(jreDir, <span class=\"string\">\"lib\"</span>, <span class=\"string\">\"ext\"</span>, <span class=\"string\">\"*\"</span>)</span><br><span class=\"line\">   self.extClasspath = newWildcardEntry(jreExtPath)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getJreDir</span><span class=\"params\">(jreOption <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> jreOption != <span class=\"string\">\"\"</span> &amp;&amp; exists(jreOption) &#123; <span class=\"comment\">//jreOption不为空且存在时返回该路径</span></span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> jreOption</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> exists(<span class=\"string\">\"./jre\"</span>) &#123; <span class=\"comment\">//./jre路径存在时，返回.jre</span></span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> <span class=\"string\">\"./jre\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> jh := os.Getenv(<span class=\"string\">\"JAVA_HOME\"</span>); jh != <span class=\"string\">\"\"</span> &#123; <span class=\"comment\">//环境变量JAVA_HOME存在并且不为空时</span></span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> filepath.Join(jh, <span class=\"string\">\"jre\"</span>) <span class=\"comment\">//返回JAVA_HOME + \"jre\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"Can not find jre folder!\"</span>)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">exists</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(path); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t   <span class=\"keyword\">if</span> os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(self *Classpath)</span> <span class=\"title\">parseUserClasspath</span><span class=\"params\">(cpOption <span class=\"keyword\">string</span>)</span></span> &#123; <span class=\"comment\">//按照-cp|classpath参数解析User启动参数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> cpOption == <span class=\"string\">\"\"</span> &#123; <span class=\"comment\">//cpOption为空时</span></span><br><span class=\"line\">\t   cpOption = <span class=\"string\">\".\"</span> <span class=\"comment\">//返回相对路劲</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tself.userClasspath = newEntry(cpOption) <span class=\"comment\">//根据-cp|classpath参数实例化对应的Entry</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>main，修改启动类<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startJVM</span><span class=\"params\">(cmd *Cmd)</span></span>&#123;</span><br><span class=\"line\">\tcp := classpath.Parse(cmd.XjreOption, cmd.cpOption) <span class=\"comment\">//根据-Xjre和-cp|classpath参数实例化classpath对象实例</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"classpath:%v class:%v args:%v\\n\"</span>,</span><br><span class=\"line\">\t   cp, cmd.class, cmd.args)</span><br><span class=\"line\">\tclassName := strings.Replace(cmd.class, <span class=\"string\">\".\"</span>, <span class=\"string\">\"/\"</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\">\tclassData, _, err := cp.ReadClass(className) <span class=\"comment\">//按照3个启动路径查找并读取className文件</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t   fmt.Printf(<span class=\"string\">\"Could not find or load main class %s\\n\"</span>, cmd.class)</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"class data:%v\\n\"</span>, classData)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>试运行<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS D:\\work\\workspace_go\\src\\jvmgo\\ch02&gt; go install</span><br><span class=\"line\"></span><br><span class=\"line\">PS D:\\work\\workspace_go\\bin&gt; .\\ch02.exe -Xjre \"C:\\Program Files\\Java\\jre1.8.0_202\" java.lang.Object</span><br><span class=\"line\">classpath:D:\\work\\workspace_go\\bin class:java.lang.Object args:[]</span><br><span class=\"line\">class data:[202 254 186 190 0 0 0 52 0 75 3 0 15 66 63 8 0 16 8 0 36 8 0 40 1 0 3 40 41 73 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 3 40 41 86 1 0 21 40 73 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 1 0 4 40 74 41 86 1 0 5 40 74 73 41 86 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 59 41 90 1 0 21 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 86 1 0 8 60 99 108 105 110 105 116 62 1 0 6 60 105 110 105 116 62 1 0 1 64 1 0 4 67 111 100</span><br><span class=\"line\">101 1 0 10 69 120 99 101 112 116 105 111 110 115 1 0 9 83 105 103 110 97 116 117 114 101 1 0 13 83 116 97 99 107 77 97 112 84 97 98 108 101 1 0 6 97 112 112 101 110 100 1 0 5 99 108 111 110 101 1 0 6 101 113</span><br><span class=\"line\">117 97 108 115 1 0 8 102 105 110 97 108 105 122 101 1 0 8 103 101 116 67 108 97 115 115 1 0 7 103 101 116 78 97 109 101 1 0 8 104 97 115 104 67 111 100 101 1 0 15 106 97 118 97 47 108 97 110 103 47 67 108 97</span><br><span class=\"line\">115 115 1 0 36 106 97 118 97 47 108 97 110 103 47 67 108 111 110 101 78 111 116 83 117 112 112 111 114 116 101 100 69 120 99 101 112 116 105 111 110 1 0 34 106 97 118 97 47 108 97 110 103 47 73 108 108 101 103 97 108 65 114 103 117 109 101 110 116 69 120 99 101 112 116 105 111 110 1 0 17 106 97 118 97 47 108 97 110 103 47 73 110 116 101 103 101 114 1 0 30 106 97 118 97 47 108 97 110 103 47 73 110 116 101 114 114</span><br><span class=\"line\">117 112 116 101 100 69 120 99 101 112 116 105 111 110 1 0 16 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116 1 0 23 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 1 0 19 106 97 118 97 47 108 97 110 103 47 84 104 114 111 119 97 98 108 101 1 0 37 110 97 110 111 115 101 99 111 110 100 32 116 105 109 101 111 117 116 32 118 97 108 117 101 32 111 117 116 32 111 102 32 114 97 110 103 101 1 0 6 110 111 116 105 102 121 1 0 9 110 111 116 105 102 121 65 108 108 1 0 15 114 101 103 105 115 116 101 114 78 97 116 105 118 101 115 1 0 25 116 105 109 101 111 117 116 32 118 97 108 117 101 32 105 115 32 110 101 103 97 116 105 118 101 1 0 11 116 111 72 101 120 83 116 114 105 110 103 1 0 8 116 111 83 116 114 105 110 103 1 0 4 119 97 105 116 7 0 28 7 0 29 7 0 30 7 0 31 7 0 32 7 0 33 7 0 34 7 0 35 1 0 19 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 59 1 0 22 40 41 76 106 97 118 97 47 108 97 110 103 47 67 108 97 115 115 60 42 62 59 1 0 45 40 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 66 117 105 108 100 101 114 59 12 0 27 0 5 12 0 15 0 8 12 0 39 0 8 12 0 43 0 10 12 0 25 0 52 12 0 26 0 7 12 0 42 0 7 12 0 41 0</span><br><span class=\"line\">9 12 0 15 0 13 12 0 21 0 54 10 0 44 0 60 10 0 46 0 63 10 0 47 0 62 10 0 49 0 55 10 0 49 0 57 10 0 49 0 58 10 0 49 0 59 10 0 50 0 56 10 0 50 0 61 10 0 50 0 64 0 33 0 49 0 0 0 0 0 0 0 14 0 1 0 15 0 8 0 1 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 1 10 0 39 0 8 0 0 1 17 0 25 0 52 0 1 0 19 0 0 0 2 0 53 1 1 0 27 0 5 0 0 0 1 0 23 0 12 0 1 0 17 0 0 0 34 0 2 0 2 0 0 0 11 42 43 166 0 7 4 167 0 4 3 172 0 0 0 1 0 20 0 0 0 5</span><br><span class=\"line\">0 2 9 64 1 1 4 0 22 0 6 0 1 0 18 0 0 0 4 0 1 0 45 0 1 0 42 0 7 0 1 0 17 0 0 0 48 0 2 0 1 0 0 0 36 187 0 50 89 183 0 72 42 182 0 71 182 0 65 182 0 74 18 2 182 0 74 42 182 0 68 184 0 67 182 0 74 182 0 73 176 0</span><br><span class=\"line\">0 0 0 1 17 0 37 0 8 0 0 1 17 0 38 0 8 0 0 1 17 0 43 0 10 0 1 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 11 0 2 0 17 0 0 0 74 0 4 0 4 0 0 0 50 31 9 148 156 0 13 187 0 46 89 18 4 183 0 66 191 29 155 0 9 29 18 1 164 0 13 187 0 46 89 18 3 183 0 66 191 29 158 0 7 31 10 97 64 42 31 182 0 70 177 0 0 0 1 0 20 0 0 0 6 0 4 16 9 9 7 0 18 0 0 0 4 0 1 0 48 0 17 0 43 0 8 0 2 0 17 0 0 0 18 0 3 0 1 0 0 0 6 42 9 182 0 70 177 0 0 0 0 0 18</span><br><span class=\"line\">0 0 0 4 0 1 0 48 0 4 0 24 0 8 0 2 0 17 0 0 0 13 0 0 0 1 0 0 0 1 177 0 0 0 0 0 18 0 0 0 4 0 1 0 51 0 8 0 14 0 8 0 1 0 17 0 0 0 16 0 0 0 0 0 0 0 4 184 0 69 177 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>"}],"PostAsset":[{"_id":"source/_posts/hexo搭建问题【-no-layout-index-html】/nolayout.jpg","slug":"nolayout.jpg","post":"ck791jei00006isnyzl1z02zq","modified":0,"renderable":0},{"_id":"source/_posts/记一次序列化失败导致的生产问题/wenti.png","slug":"wenti.png","post":"ck791jeib000iisny00fcmgo5","modified":0,"renderable":0},{"_id":"source/_posts/自己动手写Java虚拟机-笔记4/运行时数据区.png","slug":"运行时数据区.png","post":"ck791jeih000visnymvxbjqg3","modified":0,"renderable":0},{"_id":"source/_posts/自己动手写Java虚拟机-笔记1/gopath.png","slug":"gopath.png","post":"ck791jeid000lisnymg58a2dr","modified":0,"renderable":0},{"_id":"source/_posts/一个事故引起的缓存/springCache.png","slug":"springCache.png","post":"ck791jehw0002isnyer96cx6a","modified":0,"renderable":0},{"_id":"source/_posts/一个事故引起的缓存/多级缓存.png","slug":"多级缓存.png","post":"ck791jehw0002isnyer96cx6a","modified":0,"renderable":0},{"_id":"source/_posts/🐇/全景.jpeg","slug":"全景.jpeg","post":"ck791jeig000sisnyqbw0piyh","modified":0,"renderable":0},{"_id":"source/_posts/🐇/牌子.jpeg","slug":"牌子.jpeg","post":"ck791jeig000sisnyqbw0piyh","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck791jei30008isnyqd769a2j","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeia000eisnyu5pzmnqt"},{"post_id":"ck791jehs0000isnyc0svlri0","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeic000jisnyciasupq6"},{"post_id":"ck791jei40009isnyd9cbjfav","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeid000misny6flrfo9c"},{"post_id":"ck791jei8000cisnydqswz9pj","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeif000risny4i47ou8w"},{"post_id":"ck791jehw0002isnyer96cx6a","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeig000tisnym6oyf5q4"},{"post_id":"ck791jeib000iisny00fcmgo5","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeii000wisnyzqm75upy"},{"post_id":"ck791jei00006isnyzl1z02zq","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeii000yisny2ohb79ft"},{"post_id":"ck791jeid000lisnymg58a2dr","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeij0010isnyrx25g274"},{"post_id":"ck791jeie000qisny2cn2a0sv","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeij0012isny1nw1lltg"},{"post_id":"ck791jei9000disnypxbryp3k","category_id":"ck791jeid000nisnyxpdshmtw","_id":"ck791jeik0014isnylr8ow8tf"},{"post_id":"ck791jeih000visnymvxbjqg3","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeil0017isnym76c5ayi"},{"post_id":"ck791jeig000sisnyqbw0piyh","category_id":"ck791jeii000xisnyvqum1so6","_id":"ck791jeil0019isnyle9sfmks"},{"post_id":"ck791jeiu0020isnysiaoimzc","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeiw0024isnyghlbh17z"},{"post_id":"ck791jeiu0021isnyood8385o","category_id":"ck791jehz0004isnynhmvwyta","_id":"ck791jeiw0026isnyg6ng2as1"}],"PostTag":[{"post_id":"ck791jei8000cisnydqswz9pj","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeib000hisnypc85hp7j"},{"post_id":"ck791jehs0000isnyc0svlri0","tag_id":"ck791jei00005isnyf25ur8vm","_id":"ck791jeic000kisnyyqj9al1m"},{"post_id":"ck791jehs0000isnyc0svlri0","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeie000pisnyp242p3f2"},{"post_id":"ck791jehw0002isnyer96cx6a","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeij0011isnyaioy5hl3"},{"post_id":"ck791jehw0002isnyer96cx6a","tag_id":"ck791jeie000oisnytt55djfu","_id":"ck791jeik0013isny5w2tcn79"},{"post_id":"ck791jehw0002isnyer96cx6a","tag_id":"ck791jeih000uisnysqvi1tbm","_id":"ck791jeik0016isny7rew8ywt"},{"post_id":"ck791jei00006isnyzl1z02zq","tag_id":"ck791jeij000zisnydlxfi00k","_id":"ck791jeil0018isnyib7dqkav"},{"post_id":"ck791jei30008isnyqd769a2j","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeim001cisnyz2if3sb2"},{"post_id":"ck791jei30008isnyqd769a2j","tag_id":"ck791jeil001aisnyum9fssb5","_id":"ck791jeim001disnyph2gt53u"},{"post_id":"ck791jei40009isnyd9cbjfav","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jein001fisnyj3j80ooc"},{"post_id":"ck791jei9000disnypxbryp3k","tag_id":"ck791jeim001eisny7bk00sli","_id":"ck791jeio001iisnybgks0xyk"},{"post_id":"ck791jei9000disnypxbryp3k","tag_id":"ck791jein001gisnyczgcjwwn","_id":"ck791jeio001jisny1mbmnguj"},{"post_id":"ck791jeib000iisny00fcmgo5","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeio001lisnymk71gc8d"},{"post_id":"ck791jeib000iisny00fcmgo5","tag_id":"ck791jein001hisnygxmj9w7m","_id":"ck791jeio001misnyb851ierg"},{"post_id":"ck791jeid000lisnymg58a2dr","tag_id":"ck791jei00005isnyf25ur8vm","_id":"ck791jeip001oisnyz0cnc1o2"},{"post_id":"ck791jeid000lisnymg58a2dr","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeip001pisny8j7qc8b3"},{"post_id":"ck791jeid000lisnymg58a2dr","tag_id":"ck791jeio001kisny9t84hm4n","_id":"ck791jeiq001risny3uxkwh8u"},{"post_id":"ck791jeie000qisny2cn2a0sv","tag_id":"ck791jei00005isnyf25ur8vm","_id":"ck791jeiq001sisnyyfotmlxd"},{"post_id":"ck791jeie000qisny2cn2a0sv","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeir001uisnyxts5w4yi"},{"post_id":"ck791jeie000qisny2cn2a0sv","tag_id":"ck791jeio001kisny9t84hm4n","_id":"ck791jeir001visnyhcjwbd65"},{"post_id":"ck791jeig000sisnyqbw0piyh","tag_id":"ck791jeiq001qisnywnbgu9yf","_id":"ck791jeir001wisnywa9rgqhr"},{"post_id":"ck791jeih000visnymvxbjqg3","tag_id":"ck791jei00005isnyf25ur8vm","_id":"ck791jeir001xisnyx7rln77v"},{"post_id":"ck791jeih000visnymvxbjqg3","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeis001yisny9vzzj4xv"},{"post_id":"ck791jeih000visnymvxbjqg3","tag_id":"ck791jeio001kisny9t84hm4n","_id":"ck791jeis001zisny2dax0elw"},{"post_id":"ck791jeiu0021isnyood8385o","tag_id":"ck791jei00005isnyf25ur8vm","_id":"ck791jeiv0023isnyxhpe6nlt"},{"post_id":"ck791jeiu0021isnyood8385o","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeiw0025isnyieypc77r"},{"post_id":"ck791jeiu0021isnyood8385o","tag_id":"ck791jeio001kisny9t84hm4n","_id":"ck791jeiw0027isny2g2ebqje"},{"post_id":"ck791jeiu0020isnysiaoimzc","tag_id":"ck791jei6000bisnyou5ublhd","_id":"ck791jeix0028isny2z31bzmz"},{"post_id":"ck791jeiu0020isnysiaoimzc","tag_id":"ck791jeiv0022isnyzfg8a6ch","_id":"ck791jeix0029isnywcqm0iau"}],"Tag":[{"name":"JVM","_id":"ck791jei00005isnyf25ur8vm"},{"name":"Java","_id":"ck791jei6000bisnyou5ublhd"},{"name":"Redis","_id":"ck791jeie000oisnytt55djfu"},{"name":"Cache","_id":"ck791jeih000uisnysqvi1tbm"},{"name":"Hexo","_id":"ck791jeij000zisnydlxfi00k"},{"name":"IO","_id":"ck791jeil001aisnyum9fssb5"},{"name":"AI","_id":"ck791jeim001eisny7bk00sli"},{"name":"APP","_id":"ck791jein001gisnyczgcjwwn"},{"name":"Spring Boot","_id":"ck791jein001hisnygxmj9w7m"},{"name":"Go","_id":"ck791jeio001kisny9t84hm4n"},{"name":"Food","_id":"ck791jeiq001qisnywnbgu9yf"},{"name":"Springboot","_id":"ck791jeiv0022isnyzfg8a6ch"}]}}