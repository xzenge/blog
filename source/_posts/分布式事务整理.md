---
title: 分布式事务其实很简单
date: 2020-03-01 20:54:06
tags: 
    - Java
categories :
    - Technology
---

# 什么是分布式事务？为什么我们要有分布式事务？

## 先聊聊我们的项目开发
工作中随着业务的逐渐扩展，我们的业务系统也会慢慢变得庞大。
拿借贷系统来说，从金融借贷产品的上架，商户的申请、审核，贷款的进件、KYC、放贷，再到用户的还款甚至催收。
而业务往往为了快速落地，我们会将所有业务融入到一个服务中，快速开发、快速上线。
好处自然是公司业务蹭蹭往上走，业务提出的需求也能快速落地并投放至市场，但长此以往开发测试人员会变得疲惫不堪。
这里我们就要聊到服务的拆分，由于这次主要讲的是分布式事务，我们下次有时间再来讨论讨论微服务的拆分和现在大热门的DDD领域模型。

## 服务拆分后。。。
在互联网公司工作的话，大家应该都经历过一个大系统，经过不停的迭代，最后拆成数个微服务的过程。
其中的好处自然不用说，系统解耦、业务解耦、快速发版、更少的维护等等等等。
但是一旦拆出多个微服务，我们也会遇到一个棘手问题。
<!-- more -->
## 为什么我们要有分布式事务？这个问题凸显了出来
假设我们有这样一个业务：客户申请了一个贷款，这个时候我们需要做的是
1. 收集用户信息
2. 审核用户信息
3. 创建贷款订单及分期订单等
4. 选取投资人
5. 放款
   
其中收集用户信息和审核用户信息并不是一个实时操作，我们可能会交由消息去异步处理。
但是第三、四、五步是审核通过后一一执行的，当然我们也可以交由消息异步处理，但是试想一个场景。用户再分期购买产品的时候虽然对用户只是一次交易操作，但是我们后台可能已经把这笔交易作为一笔分期借款进行了落款。但是客户不知道，不是说异步处理不好，但如果能实时的告诉用户支付结果，是不是能提高用户体验和转换率呢。
回头看下我们的系统，已经被拆成订单服务、用户体系服务、放款服务了，随之带来的是每个微服务有自己对应的数据库，分别保存的是订单信息、投资人|借款人信息、放款信息。
一不做二不休，我们把以前同一个服务内的方法调用改成不同服务之间的异步调用，但随之而来的是生产上不时会出现漏数据或订单无法正常完成的问题。
聪明的小伙伴应该早就发现了，为了保证分布式服务间调用的事务性，分布式事务就孕育而生了。


## 两阶段提交/XA

常见于单系统操作多数据源。
由于依赖数据库的事务，导致效率低，不适合高并发场景。

### 事务管理器

### 流程

- 第一阶段

	- 发起事务
	- 取消事务

- 第二阶段

	- 通知执行每一个任务

## TCC

适合对分布式一致性要求要的系统，如支付、交易等

### 流程

- Try

  对各个服务的资源进行检查，业务校验等。

- Confirm

  进行实际的操作

- Cancel

  错误发生时，对之前的操作进行回滚

### 问题

业务耦合比较大，需要大量的业务代码支持

## 本地消息表

可以保证事务的最终一致性，但不适用于高并发场景

### 流程

- A系统业务操作后落消息表并MQ通知B系统
- B系统接收消息后执行业务操作，并更新A、B信息消息状态
- B系统未成功时，A系统会一直重试到成功

## 可靠消息最终一致性

依赖RMQ的消息事务，和高可用，保证消息一定通知到，并最终保证事务的一致性

### 流程

- A系统发送prepare消息至MQ，并处理业务
- A系统处理业务成功后发送Confirm消息至MQ
- B系统收到Confirm消息后执行业务

## 最大努力通知方案

可以允许一定程度上的事务失败，一般用在对分布式事务不要个的系统，比如日志收集等

### A系统发送消息至MQ

### 最大努力系统接收MQ通知并调用B系统

*XMind: ZEN - Trial Version*