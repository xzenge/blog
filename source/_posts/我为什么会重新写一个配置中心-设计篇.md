---
title: 我为什么会手撸一个配置中心-设计篇（一）
date: 2020-03-24 14:12:24
tags: 
    - Java
    - Redis
    - 配置中心
categories :
    - Technology
---
## 开篇
从这篇开始，我们开始介绍整个配置中心的设计思想和架构的流程，主要会分为下面几个部分：

1. 配置中心基础功能分析
2. 配置中心技术选型
3. 配置中心架构部署

## 基础功能分析
开始设计前我们先分析下一个配置中心到底需要哪些功能，同时工作中有哪些痛点是可以通过配置中心来解决的。

#### 1.配置的管理
原始的配置项管理大量采用了代码维护的方式，如spring的yml配置文件、代码中的@Value注解、各种中间件的配置文件等。不仅不利于配置的动态变更，更不利于统一管理配置信息，因此现有的配置中心解决方案会通常会将配置中心分为客户端和服务端。
* 客户端负责业务系统的配置收集与实时同步等。
* 服务端负责配置的统一管理和实时更新等。

结合上面的思路，我们在设计的初期也会将整个配置中心的技术架构分为客户端和服务端两部分。

回到配置管理的话题上，我们还需要考虑一个重要的功能点【如何管理配置】。这里的“管理”不单单只是将配置在某个页面上给用户展示而已，还要细化到：
* 配置如何划分范围？
* 配置差异化如何处理？
* 配置权限如何处理？

###### 配置如何划分范围？
各个业务服务连接到配置中心后，他们都有怎么不同的配置，我们不能把他们的配置全部混为一谈。不同的服务的配置有自己的作用域，多个相同服务共享同一个作用域下的配置。

通过服务来划分配置范围是一个办法，我们在编写代码的时候其实也是这么处理的。但是仅仅如此是不够的。我们可以想象一个场景，业务场景上我们经常会遇到AB test，我们解决的办法常常是通过灰度发布或蓝绿发版。通过不同的规则将前端流量引向相同服务的不同版本从而实现生产上的差异化。

如果我们只是简单的通过服务来划分配置，但遇到上诉问题的时候往往痛疼不已。1.0 Ver需要看到A文案，1.1 Ver需要看到B文案。我们假象下，如果通过过去的配置文件方式，我们要怎么处理？首先要在代码里判断当前服务的版本，然后根据不同的版本读取不同的配置，最终达到不同版本不同展示效果的功能。

```Java

@Vaule("{test.a}")
private String testA;

@Vaule("{test.b}")
private String testB;

public void getTest(String version) {
    if('1.0'.equel(version)){
        System.out.println(testA);
    }else if('1.1'.equel(version)){
        System.out.println(testB);
    }
}
```

可能会有更好的处理方法，但大多数情况下我们会像上面写代码。长此以往可想而知，后面的同学不知道之前的逻辑就看不懂这段代码在写什么。而且每次有版本的变更，都需要硬编码。

那有没有更优雅的解决方案，既然我们都有配置中心了，同时我们的配置也都交由配置中心管理了，配置变更时我们也能实时的同步配置。那么我们能不能区分出相同服务的差异化配置呢？

答案肯定是可以的。在已服务作为配置的作用域下，我们再定义一个组的概念：

|Application|Group|
---|---
Service1|Default
Service1|V1.0
Service1|V1.1
Service2|Default

同一个应用可以划分多个组，每个组中的配置存在差异化，相同配置的服务可以使用同一个组的配置。

以上就是我们划分配置范围的过程，既可以解决配置的差异化，也可以将各个服务的配置统一管理起来。当然这个配置的模型还需要不断的进化，比如：我们是否可以提炼出相同的配置，类似于jar在我们服务中相互引用的方式一样，在我们给个应用中共享。未来我们也会针对类似的需求不断的优化。



